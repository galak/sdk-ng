From a50a2e6a0144bb0cd561f6132f5b162982b11d95 Mon Sep 17 00:00:00 2001
From: Alexey Brodkin <abrodkin@synopsys.com>
Date: Tue, 4 May 2021 23:59:49 +0300
Subject: [PATCH] Add ARC64 support

Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
---
 config.sub                                         |    2 +-
 gcc/common/config/arc64/arc64-common.c             |   52 +
 gcc/config.gcc                                     |   38 +-
 gcc/config/arc64/arc64-c.c                         |   72 +
 gcc/config/arc64/arc64-c.def                       |   32 +
 gcc/config/arc64/arc64-modes.def                   |   37 +
 gcc/config/arc64/arc64-opts.h                      |   34 +
 gcc/config/arc64/arc64-protos.h                    |   44 +
 gcc/config/arc64/arc64.c                           | 4827 ++++++++++++++++++++
 gcc/config/arc64/arc64.h                           |  658 +++
 gcc/config/arc64/arc64.md                          | 2429 ++++++++++
 gcc/config/arc64/arc64.opt                         |  109 +
 gcc/config/arc64/arith.md                          | 1868 ++++++++
 gcc/config/arc64/atomic.md                         |  268 ++
 gcc/config/arc64/builtins.def                      |   42 +
 gcc/config/arc64/constraints.md                    |  375 ++
 gcc/config/arc64/elf.h                             |   42 +
 gcc/config/arc64/generate/arith.md                 | 1395 ++++++
 gcc/config/arc64/generate/logic.md                 | 2190 +++++++++
 gcc/config/arc64/hand_fixed/arith.md               | 1395 ++++++
 gcc/config/arc64/linux.h                           |   92 +
 gcc/config/arc64/predicates.md                     |  206 +
 gcc/config/arc64/t-arc64                           |   25 +
 gcc/config/arc64/t-multilib                        |   21 +
 gcc/configure                                      |   14 +-
 gcc/configure.ac                                   |   14 +-
 gcc/testsuite/gcc.c-torture/execute/20101011-1.c   |    2 +-
 gcc/testsuite/gcc.dg/builtin-apply2.c              |    2 +-
 .../gcc.dg/torture/stackalign/builtin-apply-2.c    |    2 +-
 gcc/testsuite/gcc.dg/torture/vshuf-4.inc           |   16 +-
 gcc/testsuite/gcc.target/arc/arc.exp               |    2 +-
 gcc/testsuite/gcc.target/arc64/addsubx-1.c         |   38 +
 .../gcc.target/{arc/arc.exp => arc64/arc64.exp}    |   21 +-
 gcc/testsuite/gcc.target/arc64/movd-1.c            |   38 +
 gcc/testsuite/gcc.target/arc64/movd-2.c            |   11 +
 gcc/testsuite/gcc.target/arc64/movd-3.c            |   13 +
 gcc/testsuite/gcc.target/arc64/movd-4.c            |   13 +
 gcc/testsuite/gcc.target/arc64/movd-5.c            |   19 +
 gcc/testsuite/gcc.target/arc64/movd-6.c            |   23 +
 gcc/testsuite/gcc.target/arc64/movd-7.c            |   14 +
 gcc/testsuite/gcc.target/arc64/movh-1.c            |   40 +
 gcc/testsuite/gcc.target/arc64/movh-2.c            |   11 +
 gcc/testsuite/gcc.target/arc64/movh-3.c            |   13 +
 gcc/testsuite/gcc.target/arc64/movh-4.c            |   13 +
 gcc/testsuite/gcc.target/arc64/movh-5.c            |   19 +
 gcc/testsuite/gcc.target/arc64/movh-6.c            |   23 +
 gcc/testsuite/gcc.target/arc64/movh-7.c            |   14 +
 gcc/testsuite/gcc.target/arc64/movh-8.c            |   15 +
 gcc/testsuite/gcc.target/arc64/movh-9.c            |   31 +
 gcc/testsuite/gcc.target/arc64/movq-1.c            |   42 +
 gcc/testsuite/gcc.target/arc64/movq-2.c            |   11 +
 gcc/testsuite/gcc.target/arc64/movq-3.c            |   13 +
 gcc/testsuite/gcc.target/arc64/movq-4.c            |   13 +
 gcc/testsuite/gcc.target/arc64/movq-5.c            |   19 +
 gcc/testsuite/gcc.target/arc64/movq-6.c            |   22 +
 gcc/testsuite/gcc.target/arc64/movq-7.c            |   14 +
 gcc/testsuite/gcc.target/arc64/movq-8.c            |   14 +
 gcc/testsuite/lib/target-supports.exp              |   20 +-
 libgcc/config.host                                 |   17 +-
 libgcc/config/arc64/lib2funcs.c                    |  151 +
 libgcc/config/arc64/sfp-machine.h                  |   57 +
 libgcc/config/arc64/t-arc64                        |   21 +
 libgcc/config/arc64/t-softfp                       |    8 +
 63 files changed, 17058 insertions(+), 38 deletions(-)
 create mode 100644 gcc/common/config/arc64/arc64-common.c
 create mode 100644 gcc/config/arc64/arc64-c.c
 create mode 100644 gcc/config/arc64/arc64-c.def
 create mode 100644 gcc/config/arc64/arc64-modes.def
 create mode 100644 gcc/config/arc64/arc64-opts.h
 create mode 100644 gcc/config/arc64/arc64-protos.h
 create mode 100644 gcc/config/arc64/arc64.c
 create mode 100644 gcc/config/arc64/arc64.h
 create mode 100644 gcc/config/arc64/arc64.md
 create mode 100644 gcc/config/arc64/arc64.opt
 create mode 100644 gcc/config/arc64/arith.md
 create mode 100644 gcc/config/arc64/atomic.md
 create mode 100644 gcc/config/arc64/builtins.def
 create mode 100644 gcc/config/arc64/constraints.md
 create mode 100644 gcc/config/arc64/elf.h
 create mode 100644 gcc/config/arc64/generate/arith.md
 create mode 100644 gcc/config/arc64/generate/logic.md
 create mode 100644 gcc/config/arc64/hand_fixed/arith.md
 create mode 100644 gcc/config/arc64/linux.h
 create mode 100644 gcc/config/arc64/predicates.md
 create mode 100644 gcc/config/arc64/t-arc64
 create mode 100644 gcc/config/arc64/t-multilib
 create mode 100644 gcc/testsuite/gcc.target/arc64/addsubx-1.c
 copy gcc/testsuite/gcc.target/{arc/arc.exp => arc64/arc64.exp} (88%)
 create mode 100644 gcc/testsuite/gcc.target/arc64/movd-1.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movd-2.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movd-3.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movd-4.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movd-5.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movd-6.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movd-7.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movh-1.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movh-2.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movh-3.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movh-4.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movh-5.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movh-6.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movh-7.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movh-8.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movh-9.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movq-1.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movq-2.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movq-3.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movq-4.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movq-5.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movq-6.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movq-7.c
 create mode 100644 gcc/testsuite/gcc.target/arc64/movq-8.c
 create mode 100644 libgcc/config/arc64/lib2funcs.c
 create mode 100644 libgcc/config/arc64/sfp-machine.h
 create mode 100644 libgcc/config/arc64/t-arc64
 create mode 100644 libgcc/config/arc64/t-softfp

diff --git a/config.sub b/config.sub
index a318a468685..2d22e038811 100755
--- a/config.sub
+++ b/config.sub
@@ -1163,7 +1163,7 @@ case $cpu-$vendor in
 			| alphapca5[67] | alpha64pca5[67] \
 			| am33_2.0 \
 			| amdgcn \
-			| arc | arceb \
+			| arc | arceb | arc64 \
 			| arm  | arm[lb]e | arme[lb] | armv* \
 			| avr | avr32 \
 			| asmjs \
diff --git a/gcc/common/config/arc64/arc64-common.c b/gcc/common/config/arc64/arc64-common.c
new file mode 100644
index 00000000000..f325265da4c
--- /dev/null
+++ b/gcc/common/config/arc64/arc64-common.c
@@ -0,0 +1,52 @@
+/* Common hooks for Synopsys DesignWare ARC
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "diagnostic-core.h"
+#include "tm.h"
+#include "common/common-target.h"
+#include "opts.h"
+#include "flags.h"
+
+/* Set default optimization options.  */
+/* The conditions are incomplete, so we rely on the evaluation order here,
+   which goes from first to last, i.e. the last match prevails.  */
+/* ??? But this trick only works for reject_negative options.  Approximate
+   missing option combination.  */
+#define OPT_LEVELS_3_PLUS_SPEED_ONLY OPT_LEVELS_3_PLUS
+static const struct default_options arc_option_optimization_table[] =
+  {
+    { OPT_LEVELS_SIZE, OPT_ftree_loop_optimize, NULL, 0},
+    { OPT_LEVELS_SIZE, OPT_fmove_loop_invariants, NULL, 0},
+    { OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1 },
+    { OPT_LEVELS_NONE, 0, NULL, 0 }
+  };
+
+
+#undef  TARGET_OPTION_OPTIMIZATION_TABLE
+#define TARGET_OPTION_OPTIMIZATION_TABLE arc_option_optimization_table
+
+#undef  TARGET_DEFAULT_TARGET_FLAGS
+#define TARGET_DEFAULT_TARGET_FLAGS (MASK_BITSCAN)
+
+#include "common/common-target-def.h"
+
+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 6fcdd771d4c..d8e2ee763c5 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -336,13 +336,18 @@ amdgcn*)
 am33_2.0-*-linux*)
 	cpu_type=mn10300
 	;;
-arc*-*-*)
+arc-*-* | arc[eb]*-*-*)
 	cpu_type=arc
 	c_target_objs="arc-c.o"
 	cxx_target_objs="arc-c.o"
 	extra_options="${extra_options} arc/arc-tables.opt g.opt"
 	extra_headers="arc-simd.h"
 	;;
+arc64-*-*)
+	cpu_type=arc64
+	c_target_objs="arc64-c.o"
+	cxx_target_objs="arc64-c.o"
+	;;
 arm*-*-*)
 	cpu_type=arm
 	extra_objs="arm-builtins.o aarch-common.o"
@@ -1168,7 +1173,7 @@ alpha*-dec-*vms*)
 	tm_file="${tm_file} vms/vms.h alpha/vms.h"
 	tmake_file="${tmake_file} alpha/t-vms alpha/t-alpha"
 	;;
-arc*-*-elf*)
+arc-*-elf* | arc[eb]*-*-*)
 	tm_file="arc/arc-arch.h dbxelf.h elfos.h newlib-stdint.h arc/elf.h ${tm_file}"
 	tmake_file="arc/t-multilib arc/t-arc"
 	extra_gcc_objs="driver-arc.o"
@@ -1189,7 +1194,7 @@ arc*-*-elf*)
 	big*)	tm_file="arc/big.h ${tm_file}"
 	esac
 	;;
-arc*-*-linux*)
+arc-*-linux* | arc[eb]*-*linux*)
 	tm_file="arc/arc-arch.h dbxelf.h elfos.h gnu-user.h linux.h linux-android.h glibc-stdint.h arc/linux.h ${tm_file}"
 	tmake_file="${tmake_file} arc/t-multilib-linux arc/t-arc"
 	extra_gcc_objs="driver-arc.o"
@@ -1213,6 +1218,17 @@ arc*-*-linux*)
 	# automatically detect that GAS supports it, yet we require it.
 	gcc_cv_initfini_array=yes
 	;;
+arc64-*-elf*)
+	tm_file="dbxelf.h elfos.h newlib-stdint.h arc64/elf.h ${tm_file}"
+	tmake_file="${tmake_file} arc64/t-multilib arc64/t-arc64"
+	;;
+arc64-*-linux*)
+	tm_file="dbxelf.h elfos.h gnu-user.h linux.h arc64/linux.h linux-android.h glibc-stdint.h ${tm_file}"
+	tmake_file="${tmake_file} arc64/t-arc64"
+	# Force .init_array support.  The configure script cannot always
+	# automatically detect that GAS supports it, yet we require it.
+	gcc_cv_initfini_array=yes
+	;;
 arm-wrs-vxworks7*)
 	# We only support VxWorks 7 now on ARM, post SR600.  Pre SR600
 	# VxWorks 7 was transitory and major versions prior to 7 were based
@@ -4249,7 +4265,7 @@ case "${target}" in
 		done
 		;;
 
-	arc*-*-*)
+	arc-*-* | arc[eb]*-*-*)
 		supported_defaults="cpu"
 
 		if [ x"$with_cpu" = x ] \
@@ -4264,6 +4280,20 @@ case "${target}" in
 		fi
 		;;
 
+	arc64-*-*)
+		supported_defaults="fpu"
+		case "$with_fpu" in
+		"" | fpus | fpud)
+			# OK
+			;;
+		*)
+			echo "Unknown floating point type used in "\
+			     "--with-fpu=$with-fpu" 1>&2
+			exit 1
+			;;
+		esac
+		;;
+
     csky-*-*)
 	supported_defaults="cpu endian float"
 	;;
diff --git a/gcc/config/arc64/arc64-c.c b/gcc/config/arc64/arc64-c.c
new file mode 100644
index 00000000000..a0ea2adaf97
--- /dev/null
+++ b/gcc/config/arc64/arc64-c.c
@@ -0,0 +1,72 @@
+/* Copyright (C) 2016-2019 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.
+*/
+
+#define IN_TARGET_CODE 1
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "tree.h"
+#include "memmodel.h"
+#include "tm_p.h"
+#include "cpplib.h"
+#include "c-family/c-common.h"
+#include "target.h"
+
+#define builtin_define(TXT) cpp_define (pfile, TXT)
+#define builtin_assert(TXT) cpp_assert (pfile, TXT)
+
+/* Define or undefine macros based on the current target.  */
+
+static void
+def_or_undef_macro (cpp_reader* pfile, const char *name, bool def_p)
+{
+  if (def_p)
+    cpp_define (pfile, name);
+  else
+    cpp_undef (pfile, name);
+}
+
+/* Helper for TARGET_CPU_CPP_BUILTINS hook.  */
+
+void
+arc64_cpu_cpp_builtins (cpp_reader * pfile)
+{
+  builtin_assert ("cpu=arc64");
+  builtin_assert ("machine=arc64");
+
+  builtin_define ("__ARC64__");
+  builtin_define ("__LITTLE_ENDIAN__");
+  builtin_define ("__ARCV3__");
+
+  if (arc64_cmodel_var == ARC64_CMODEL_SMALL)
+    builtin_define ("__ARC64_CMODEL_SMALL__");
+  else if (arc64_cmodel_var == ARC64_CMODEL_MEDIUM)
+    builtin_define ("__ARC64_CMODEL_MEDIUM__");
+  else if (arc64_cmodel_var == ARC64_CMODEL_LARGE)
+    builtin_define ("__ARC64_CMODEL_LARGE__");
+
+#undef ARC64_C_DEF
+#define ARC64_C_DEF(NAME, CONDITION)		\
+  def_or_undef_macro (pfile, NAME, CONDITION);
+
+#include "arc64-c.def"
+#undef ARC64_C_DEF
+}
diff --git a/gcc/config/arc64/arc64-c.def b/gcc/config/arc64/arc64-c.def
new file mode 100644
index 00000000000..2dde4d9db2e
--- /dev/null
+++ b/gcc/config/arc64/arc64-c.def
@@ -0,0 +1,32 @@
+/* Copyright (C) 2020 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.
+*/
+
+ARC64_C_DEF ("__ARC64_ATOMIC_1__", arc64_atomic_option == 1)
+ARC64_C_DEF ("__ARC64_ATOMIC_2__", arc64_atomic_option == 2)
+ARC64_C_DEF ("__ARC64_ATOMIC_3__", arc64_atomic_option == 3)
+ARC64_C_DEF ("__ARC64_UNALIGNED__", unaligned_access)
+ARC64_C_DEF ("__ARC64_FPUS__", ARC64_HAS_FPUS)
+ARC64_C_DEF ("__ARC64_FPUD__", ARC64_HAS_FPUD)
+ARC64_C_DEF ("__ARC64_M128__", TARGET_WIDE_LDST)
+ARC64_C_DEF ("__ARC64_WIDE_VECTOR__", TARGET_WIDE_SIMD)
+
+
+/* Local Variables: */
+/* mode: c */
+/* End: */
diff --git a/gcc/config/arc64/arc64-modes.def b/gcc/config/arc64/arc64-modes.def
new file mode 100644
index 00000000000..4407090322b
--- /dev/null
+++ b/gcc/config/arc64/arc64-modes.def
@@ -0,0 +1,37 @@
+/* Machine description for arc64 architecture.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+CC_MODE (CC_ZN);    /* Only N and Z bits of condition flags are valid.  */
+CC_MODE (CC_Z);     /* Only Z bit of condition flags is valid.  */
+CC_MODE (CC_C);     /* C represents unsigned overflow of a simple addition.  */
+CC_MODE (CC_FPU);
+CC_MODE (CC_FPUE);
+
+/* Half-precision floating point for __fp16.  */
+FLOAT_MODE (HF, 2, 0);
+ADJUST_FLOAT_FORMAT (HF, &ieee_half_format);
+
+/* Int vector modes.  */
+VECTOR_MODES (INT, 4);        /* V2HI */
+VECTOR_MODES (INT, 8);        /* V4HI V2SI */
+
+/* FP vector modes.  */
+VECTOR_MODE (FLOAT, HF, 2);   /* V2HF */
+VECTOR_MODES (FLOAT, 8);      /* V4HF V2SF */
+VECTOR_MODES (FLOAT, 16);     /* V8HF V4SF V2DF */
diff --git a/gcc/config/arc64/arc64-opts.h b/gcc/config/arc64/arc64-opts.h
new file mode 100644
index 00000000000..fe188200598
--- /dev/null
+++ b/gcc/config/arc64/arc64-opts.h
@@ -0,0 +1,34 @@
+/* Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef ARC64_OPTS_H
+#define ARC64_OPTS_H
+
+/* The code model defines the address generation strategy.  */
+enum arc64_code_model {
+  /* Static code and data fit within a 1MB region.
+     The default non-PIC code model.  */
+  ARC64_CMODEL_SMALL,
+  /* The default for PIC code model, static code and data fit within
+     4GB region.  Local calls will fit within 16MB region.  */
+  ARC64_CMODEL_MEDIUM,
+  /* No assumptions about addresses of code and data.  */
+  ARC64_CMODEL_LARGE
+};
+
+#endif /* ARC64_OPTS_H */
diff --git a/gcc/config/arc64/arc64-protos.h b/gcc/config/arc64/arc64-protos.h
new file mode 100644
index 00000000000..5e0a5995abe
--- /dev/null
+++ b/gcc/config/arc64/arc64-protos.h
@@ -0,0 +1,44 @@
+#ifndef GCC_ARC64_PROTOS_H
+#define GCC_ARC64_PROTOS_H
+
+extern int arc64_epilogue_uses (int);
+extern int arc64_eh_uses (int);
+extern HOST_WIDE_INT arc64_initial_elimination_offset (unsigned, unsigned);
+extern void arc64_init_expanders (void);
+extern void arc64_cpu_cpp_builtins (cpp_reader *);
+
+#ifdef RTX_CODE
+
+extern rtx arc64_return_addr (int, rtx);
+extern machine_mode arc64_select_cc_mode (enum rtx_code, rtx, rtx);
+extern bool arc64_check_mov_const (HOST_WIDE_INT );
+extern bool arc64_split_mov_const (rtx *);
+extern bool arc64_can_use_return_insn_p (void);
+extern void arc64_expand_call (rtx, rtx, bool);
+extern rtx arc64_gen_compare_reg (enum rtx_code, rtx, rtx);
+extern bool arc64_prepare_move_operands (rtx, rtx, machine_mode);
+extern void arc64_expand_prologue (void);
+extern void arc64_expand_epilogue (bool);
+extern bool arc64_limm_addr_p (rtx);
+extern bool arc64_is_long_call_p (rtx);
+extern bool arc64_legitimate_store_address_p (machine_mode, rtx);
+extern bool arc64_short_access_p (rtx, machine_mode, bool);
+extern rtx arc64_eh_return_handler_rtx (void);
+extern int arc64_asm_preferred_eh_data_format (int, int);
+
+extern void arc64_expand_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx);
+extern void arc64_pre_atomic_barrier (enum memmodel);
+extern void arc64_post_atomic_barrier (enum memmodel);
+extern void arc64_expand_compare_and_swap (rtx []);
+extern void arc64_split_compare_and_swap (rtx []);
+extern bool arc64_allow_direct_access_p (rtx);
+extern bool arc64_use_fp_regs (machine_mode);
+extern bool arc64_fp_access_p (rtx, machine_mode);
+extern void arc64_expand_casesi (rtx []);
+extern bool arc64_simd64x_split_move_p (rtx *, machine_mode);
+extern void arc64_simd128_split_move (rtx *, machine_mode);
+extern unsigned arc64_dbx_register_number (unsigned);
+extern bool arc64_expand_fvect_shr (rtx *);
+#endif /* RTX_CODE */
+
+#endif /* GCC_ARC64_PROTOS_H */
diff --git a/gcc/config/arc64/arc64.c b/gcc/config/arc64/arc64.c
new file mode 100644
index 00000000000..17a1cee36d6
--- /dev/null
+++ b/gcc/config/arc64/arc64.c
@@ -0,0 +1,4827 @@
+#define IN_TARGET_CODE 1
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "memmodel.h"
+#include "backend.h"
+#include "target.h"
+#include "rtl.h"
+#include "tree.h"
+#include "cfghooks.h"
+#include "df.h"
+#include "tm_p.h"
+#include "stringpool.h"
+#include "attribs.h"
+#include "optabs.h"
+#include "regs.h"
+#include "emit-rtl.h"
+#include "recog.h"
+#include "diagnostic.h"
+#include "fold-const.h"
+#include "varasm.h"
+#include "stor-layout.h"
+#include "calls.h"
+#include "output.h"
+#include "insn-attr.h"
+#include "flags.h"
+#include "explow.h"
+#include "expr.h"
+#include "langhooks.h"
+#include "tm-constrs.h"
+#include "cfgrtl.h"
+#include "tree-pass.h"
+#include "context.h"
+#include "builtins.h"
+#include "rtl-iter.h"
+#include "alias.h"
+#include "opts.h"
+#include "dwarf2.h"
+#include "hw-doloop.h"
+
+/* This file should be included last.  */
+#include "target-def.h"
+
+/* Return true if REGNO is suited for short instructions.  */
+#define COMPACT_REG_P(REGNO)						\
+  (((signed)(REGNO) >= R0_REGNUM && (REGNO) <= R3_REGNUM)		\
+   || ((REGNO) >= R12_REGNUM && (REGNO) <= R15_REGNUM))
+
+/* Defined for convenience.  */
+#define POINTER_BYTES (POINTER_SIZE / BITS_PER_UNIT)
+
+/* Maximum size of a loop.  */
+#define MAX_LOOP_LENGTH 4094
+#define MIN_LOOP_LENGTH -4092
+
+/* Implement REGNO_REG_CLASS.  */
+const enum reg_class arc64_regno_to_regclass[FIRST_PSEUDO_REGISTER] =
+  {
+   AC16_REGS,    AC16_REGS,    AC16_REGS,    AC16_REGS,
+   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,
+   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,
+   AC16_REGS,    AC16_REGS,    AC16_REGS,    AC16_REGS,
+   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,
+   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,
+   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,
+   GENERAL_REGS, NO_REGS,      GENERAL_REGS, GENERAL_REGS,
+
+   NO_REGS, NO_REGS, NO_REGS, NO_REGS,
+   NO_REGS, NO_REGS, NO_REGS, NO_REGS,
+   NO_REGS, NO_REGS, NO_REGS, NO_REGS,
+   NO_REGS, NO_REGS, NO_REGS, NO_REGS,
+
+   NO_REGS, NO_REGS, NO_REGS, NO_REGS,
+   NO_REGS, NO_REGS, NO_REGS, NO_REGS,
+   NO_REGS, NO_REGS, GENERAL_REGS, NO_REGS,
+   NO_REGS, NO_REGS, NO_REGS, NO_REGS,
+
+   FP_REGS, FP_REGS, FP_REGS, FP_REGS,
+   FP_REGS, FP_REGS, FP_REGS, FP_REGS,
+   FP_REGS, FP_REGS, FP_REGS, FP_REGS,
+   FP_REGS, FP_REGS, FP_REGS, FP_REGS,
+   FP_REGS, FP_REGS, FP_REGS, FP_REGS,
+   FP_REGS, FP_REGS, FP_REGS, FP_REGS,
+   FP_REGS, FP_REGS, FP_REGS, FP_REGS,
+   FP_REGS, FP_REGS, FP_REGS, FP_REGS,
+
+   GENERAL_REGS, GENERAL_REGS, NO_REGS,
+  };
+
+enum arc_cc_code_index
+{
+  ARC_CC_AL, ARC_CC_EQ = ARC_CC_AL+2, ARC_CC_NE, ARC_CC_P, ARC_CC_N,
+  ARC_CC_C,  ARC_CC_NC, ARC_CC_V, ARC_CC_NV,
+  ARC_CC_GT, ARC_CC_LE, ARC_CC_GE, ARC_CC_LT, ARC_CC_HI, ARC_CC_LS, ARC_CC_PNZ,
+  ARC_CC_LO = ARC_CC_C, ARC_CC_HS = ARC_CC_NC
+};
+
+typedef enum arc64_symb_type
+{
+  ARC64_UNK = 0, ARC64_LO32, ARC64_LARGE, ARC64_PIC, ARC64_LPIC, ARC64_TLS
+} arc64_symb;
+
+/* Information about single argument.  */
+struct arc64_arg_info {
+  /* Number of integer registers allocated to this argument.  */
+  unsigned int ngpr;
+  /* Number of floating-point registers allocated to this argument.  */
+  unsigned int nfpr;
+
+  /* Offset.  */
+  unsigned int off_gpr;
+  unsigned int off_fpr;
+
+  /* Goes on stack.  */
+  bool stack_p;
+};
+
+/* Frame and machine specific info.  */
+
+struct GTY (()) arc64_frame
+{
+  HOST_WIDE_INT reg_offset[FIRST_PSEUDO_REGISTER];
+
+  /* The size of the saved callee-save int/FP registers. */
+  HOST_WIDE_INT saved_regs_size;
+
+  /* The number of extra stack bytes taken up by register varargs.
+     This area is allocated by the callee at the very top of the
+     frame.  This value is rounded up to a multiple of
+     STACK_BOUNDARY.  */
+  HOST_WIDE_INT saved_varargs_size;
+
+  HOST_WIDE_INT saved_outargs_size;
+
+  HOST_WIDE_INT saved_locals_size;
+
+  /* The size of the frame.  This value is the offset from base of the
+     frame (incomming SP) to the stack_pointer.  This value is always
+     a multiple of STACK_BOUNDARY.  */
+  HOST_WIDE_INT frame_size;
+
+  bool layout_p;
+};
+
+typedef struct GTY (()) machine_function
+{
+  struct arc64_frame frame;
+  /* Record if the function has a variable argument list.  */
+  int uses_anonymous_args;
+} machine_function;
+
+/* IDs for all the ARC builtins.  */
+
+enum arc64_builtin_id
+  {
+#define DEF_BUILTIN(NAME, N_ARGS, TYPE, ICODE, MASK)	\
+    ARC64_BUILTIN_ ## NAME,
+#include "builtins.def"
+#undef DEF_BUILTIN
+
+    ARC64_BUILTIN_COUNT
+  };
+
+struct GTY(()) arc64_builtin_description
+{
+  enum insn_code icode;
+  int n_args;
+  tree fndecl;
+};
+
+static GTY(()) struct arc64_builtin_description
+arc_bdesc[ARC64_BUILTIN_COUNT] =
+{
+#define DEF_BUILTIN(NAME, N_ARGS, TYPE, ICODE, MASK)		\
+  { (enum insn_code) CODE_FOR_ ## ICODE, N_ARGS, NULL_TREE },
+#include "builtins.def"
+#undef DEF_BUILTIN
+};
+
+/* vec_perm support.  */
+struct e_vec_perm_d
+{
+  rtx target, op0, op1;
+  vec_perm_indices perm;
+  machine_mode vmode;
+  bool one_vector_p;
+  bool testing_p;
+};
+
+/* Local variable true if we output scalled address.  */
+static bool scalled_p = false;
+/* Simple LUT for log2.  */
+static const int lutlog2[] = {0, 0, 1, 0, 2, 0, 0, 0,
+			      3, 0, 0, 0, 0, 0, 0, 0 };
+
+/* Safe access lut log2 table.  */
+#define ARC64LOG2(X) (((X) > 15) ? 3 : lutlog2[((X) & 0x0f)])
+
+/* Check if an offset fits in signed 8 bit immediate field.  */
+#define ARC64_CHECK_SMALL_IMMEDIATE(indx, mode)				\
+  (CONST_INT_P (indx)							\
+   && VERIFY_SHIFT (INTVAL (indx), ARC64LOG2 (GET_MODE_SIZE (mode)))	\
+   && SIGNED_INT9 (INTVAL (indx) >> ARC64LOG2 (GET_MODE_SIZE (mode))))
+
+/* ALIGN FRAMES on word boundaries.  */
+#define ARC64_STACK_ALIGN(LOC)						\
+  (((LOC) + STACK_BOUNDARY / BITS_PER_UNIT - 1) & -STACK_BOUNDARY/BITS_PER_UNIT)
+
+/* ARC64 stack frame generated by this compiler looks like:
+
+	+-------------------------------+
+	|                               |
+	|  incoming stack arguments     |
+	|                               |
+	+-------------------------------+ <-- incoming stack pointer (aligned)
+	|                               |
+	|  callee-allocated save area   |
+	|  for register varargs         |
+	|                               |
+	+-------------------------------+ <-- arg_pointer_rtx
+	|                               |
+	|  GPR save area                |
+	|                               |
+	+-------------------------------+
+	|  Return address register      |
+	|  (if required)                |
+	+-------------------------------+
+	|  FP (if required)             |
+	+-------------------------------+ <-- (hard) frame_pointer_rtx
+	|                               |
+	|  Local variables              |
+	|                               |
+	+-------------------------------+
+	|  outgoing stack arguments     |
+	|                               |
+	+-------------------------------+ <-- stack_pointer_rtx (aligned)
+
+  Dynamic stack allocations such as alloca insert data after local
+  variables.  */
+
+/* Return TRUE if a register needs to be saved, exception making
+   BLINK, and FP registers.  BLINK is never check by this routine,
+   while FP is only checked if `frame_pointer_required` is FALSE.  */
+
+static bool
+arc64_save_reg_p (int regno)
+{
+  bool call_saved;
+  bool might_clobber;
+
+  gcc_assert (regno <= F31_REGNUM);
+  gcc_assert (regno >= R0_REGNUM);
+
+  switch (regno)
+    {
+    case ILINK_REGNUM:
+    case BLINK_REGNUM:
+    case SP_REGNUM:
+      /* Special registers, they are handled separately.  */
+      return false;
+
+    case R27_REGNUM:
+      if (frame_pointer_needed)
+	return false;
+      break;
+
+    case F0_REGNUM ... F31_REGNUM:
+      if (!ARC64_HAS_FP_BASE)
+	return false;
+      break;
+
+    default:
+      break;
+    }
+
+  call_saved = !global_regs[regno] && !call_used_regs[regno];
+  might_clobber = df_regs_ever_live_p (regno) || crtl->saves_all_registers;
+
+  if (call_saved && might_clobber)
+    return true;
+  return false;
+}
+
+/* Compute the frame info.  */
+
+static void
+arc64_compute_frame_info (void)
+{
+  int regno;
+  HOST_WIDE_INT offset;
+  struct arc64_frame *frame = &cfun->machine->frame;
+
+  gcc_assert (!frame->layout_p);
+
+  memset (frame, 0, sizeof (*frame));
+
+  /* Find out which GPR need to be saved.  */
+  for (regno = R0_REGNUM, offset = 0;
+       regno <= F31_REGNUM;
+       regno++)
+    if (arc64_save_reg_p (regno))
+      {
+	/* TBI: probably I need to make the saving of the FP registers
+	   separate bulk from GPIs such that I can use latter on
+	   enter/leave instruction seamlessly (i.e. first save
+	   FPregs/latter GPI, the leave return feature will not
+	   work).  */
+	/* TBI: the FPUS only configuration is having only 32bit
+	   registers, thus I can stack 2 FP registers in one stack
+	   slot ;).  */
+	frame->reg_offset[regno] = offset;
+	offset += UNITS_PER_WORD;
+      }
+    else
+      frame->reg_offset[regno] = -1;
+
+  /* Check if we need to save the return address.  */
+  if (!crtl->is_leaf || df_regs_ever_live_p (BLINK_REGNUM))
+    {
+      frame->reg_offset[BLINK_REGNUM] = offset;
+      offset += UNITS_PER_WORD;
+    }
+
+  /* Check if we need frame pointer.  It is mutual exclusive with
+     arc64_save_reg_p call.  */
+  if (frame_pointer_needed)
+    {
+      frame->reg_offset[R27_REGNUM] = offset;
+      offset += UNITS_PER_WORD;
+    }
+
+  /* 1. At the bottom of the stack are any outgoing stack
+     arguments.  */
+  frame->saved_outargs_size = ARC64_STACK_ALIGN (crtl->outgoing_args_size);
+
+  /* 2. Size of locals and temporaries.  */
+  frame->saved_locals_size = ARC64_STACK_ALIGN (get_frame_size ());
+
+  /* 3. Size of the saved registers (including FP/BLINK).
+     FIXME! FPR registers.  */
+  frame->saved_regs_size = ARC64_STACK_ALIGN (offset);
+
+  /* 4. Size of the callee-allocated area for pretend stack
+     arguments.  */
+  frame->saved_varargs_size = ARC64_STACK_ALIGN (crtl->args.pretend_args_size);
+
+  /* Total size.  */
+  frame->frame_size = frame->saved_outargs_size + frame->saved_locals_size
+    + frame->saved_regs_size + frame->saved_varargs_size;
+
+  gcc_assert (frame->frame_size == ARC64_STACK_ALIGN (frame->frame_size));
+  frame->layout_p = reload_completed;
+}
+
+/* Emit a frame insn which adjusts stack pointer by OFFSET.  */
+
+static void
+frame_stack_add (HOST_WIDE_INT offset)
+{
+  rtx tmp;
+  HOST_WIDE_INT lo = sext_hwi (offset, 32);
+  unsigned HOST_WIDE_INT hi = sext_hwi (offset >> 32, 32);
+
+  if (hi != 0xffffffffULL || hi != 0ULL)
+    tmp = gen_rtx_SET (stack_pointer_rtx,
+		       gen_rtx_PLUS (Pmode, stack_pointer_rtx,
+				     gen_rtx_HIGH (Pmode, GEN_INT (hi))));
+
+  tmp = gen_rtx_SET (stack_pointer_rtx,
+		     plus_constant (Pmode, stack_pointer_rtx, lo));
+  tmp = emit_insn (tmp);
+  RTX_FRAME_RELATED_P (tmp) = 1;
+  add_reg_note (tmp, REG_FRAME_RELATED_EXPR,
+		gen_rtx_SET (stack_pointer_rtx,
+			     plus_constant (Pmode, stack_pointer_rtx,
+					    offset)));
+}
+
+/* Helper for prologue: emit frame store with pre_modify or pre_dec to
+   save register REG on stack.  An initial offset OFFSET can be passed
+   to the function.  If a DISPLACEMENT is defined, it will be used to
+   generate pre_modify instead of pre_dec.  */
+
+static HOST_WIDE_INT
+frame_save_reg (rtx reg, HOST_WIDE_INT offset, HOST_WIDE_INT displacement)
+{
+  rtx addr, tmp;
+
+  if (offset)
+    {
+      tmp = plus_constant (Pmode, stack_pointer_rtx,
+			       offset - GET_MODE_SIZE (GET_MODE (reg)));
+      addr = gen_frame_mem (GET_MODE (reg),
+			    gen_rtx_PRE_MODIFY (Pmode,
+						stack_pointer_rtx,
+						tmp));
+    }
+  else if (displacement)
+    {
+      tmp = plus_constant (Pmode, stack_pointer_rtx, (-displacement));
+      addr = gen_frame_mem (GET_MODE (reg),
+			    gen_rtx_PRE_MODIFY (Pmode,
+						stack_pointer_rtx,
+						tmp));
+    }
+  else
+    addr = gen_frame_mem (GET_MODE (reg), gen_rtx_PRE_DEC (Pmode,
+							   stack_pointer_rtx));
+  tmp = emit_move_insn (addr, reg);
+  RTX_FRAME_RELATED_P (tmp) = 1;
+
+  return (displacement ? displacement : GET_MODE_SIZE (GET_MODE (reg)))
+    - offset;
+}
+
+/* ARC prologue saving regs routine.   */
+
+static HOST_WIDE_INT
+arc64_save_callee_saves (void)
+{
+  struct arc64_frame *frame = &cfun->machine->frame;
+  machine_mode save_mode = DImode;
+  int regno;
+  HOST_WIDE_INT offset = -frame->saved_varargs_size;
+  HOST_WIDE_INT frame_allocated = 0;
+  rtx reg;
+
+  for (regno = F31_REGNUM; regno >= R0_REGNUM; regno--)
+    {
+      HOST_WIDE_INT disp = 0;
+      if (frame->reg_offset[regno] == -1
+	  /* Hard frame pointer is saved in a different place.  */
+	  || (frame_pointer_needed && regno == R27_REGNUM)
+	  /* blink register is saved in a different place.  */
+	  || (regno == BLINK_REGNUM))
+	continue;
+
+      if (ARC64_HAS_FP_BASE && FP_REGNUM_P (regno))
+	{
+	  save_mode = ARC64_HAS_FPUD ? DFmode : SFmode;
+	  disp = UNITS_PER_WORD;
+	}
+      else if (TARGET_WIDE_LDST
+	       /* Use 128bit stores for context saving.  */
+	       && (regno > 1)
+	       && (((regno - 1) % 2) == 0)
+	       && (frame->reg_offset[regno - 1] != -1))
+	{
+	  save_mode = TImode;
+	  --regno;
+	}
+      else
+	save_mode = DImode;
+
+      reg = gen_rtx_REG (save_mode, regno);
+      frame_allocated += frame_save_reg (reg, offset, disp);
+      offset = 0;
+    }
+
+  /* Save BLINK if required.  */
+  if (frame->reg_offset[BLINK_REGNUM] != -1)
+    {
+      reg = gen_rtx_REG (Pmode, BLINK_REGNUM);
+      frame_allocated += frame_save_reg (reg, offset, 0);
+      offset = 0;
+    }
+
+  /* Save FP if required.  */
+  if (frame_pointer_needed)
+    {
+      frame_allocated += frame_save_reg (hard_frame_pointer_rtx, offset, 0);
+      offset = 0;
+    }
+
+  /* Emit mov fp,sp, if required.  */
+  if (frame_pointer_needed)
+    {
+      rtx tmp = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);
+      RTX_FRAME_RELATED_P (tmp) = 1;
+    }
+
+  return frame_allocated;
+}
+
+/* Helper for epilogue: emit frame load with post_modify or post_inc
+   to restore register REG from stack.  The initial offset is passed
+   via OFFSET.  */
+
+static HOST_WIDE_INT
+frame_restore_reg (rtx reg, HOST_WIDE_INT displacement)
+{
+  rtx addr, insn, tmp;
+
+  if (displacement)
+    {
+      tmp = plus_constant (Pmode, stack_pointer_rtx, displacement);
+      addr = gen_frame_mem (GET_MODE (reg),
+			    gen_rtx_POST_MODIFY (Pmode,
+						 stack_pointer_rtx,
+						 tmp));
+    }
+  else
+    addr = gen_frame_mem (GET_MODE (reg),
+			  gen_rtx_POST_INC (Pmode, stack_pointer_rtx));
+  insn = emit_move_insn (reg, addr);
+  RTX_FRAME_RELATED_P (insn) = 1;
+  add_reg_note (insn, REG_CFA_RESTORE, reg);
+
+  if (reg == hard_frame_pointer_rtx)
+    add_reg_note (insn, REG_CFA_DEF_CFA,
+		  plus_constant (Pmode, stack_pointer_rtx,
+				 GET_MODE_SIZE (GET_MODE (reg))));
+  else
+    add_reg_note (insn, REG_CFA_ADJUST_CFA,
+		  gen_rtx_SET (stack_pointer_rtx,
+			       plus_constant (Pmode, stack_pointer_rtx,
+					      GET_MODE_SIZE (GET_MODE (reg)))));
+
+  return displacement ? displacement : GET_MODE_SIZE (GET_MODE (reg));
+}
+
+/* ARC' epilogue restore regs routine.  */
+
+static HOST_WIDE_INT
+arc64_restore_callee_saves (bool sibcall_p ATTRIBUTE_UNUSED)
+{
+  struct arc64_frame *frame = &cfun->machine->frame;
+  HOST_WIDE_INT offset, frame_deallocated = 0;
+  rtx reg;
+  int regno;
+  machine_mode restore_mode = DImode;
+
+  /* Recover the frame_pointer location for the current frame.  */
+  offset = frame->frame_size - (frame->saved_regs_size
+				+ frame->saved_varargs_size);
+
+  /* Emit mov sp,fp if need.  Thus, we get rid of the offset without
+     using a possible expensive add3 instruction.  */
+  if (frame_pointer_needed)
+    {
+      rtx tmp = emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx);
+      RTX_FRAME_RELATED_P (tmp) = 1;
+    }
+  else if (offset)
+    frame_stack_add (offset);
+
+  frame_deallocated += offset;
+
+  if (frame_pointer_needed)
+    frame_deallocated += frame_restore_reg (hard_frame_pointer_rtx, 0);
+
+  if (frame->reg_offset[BLINK_REGNUM] != -1)
+    {
+      reg = gen_rtx_REG (Pmode, BLINK_REGNUM);
+      frame_deallocated += frame_restore_reg (reg, 0);
+    }
+
+  for (regno = R0_REGNUM; regno <= F31_REGNUM; regno++)
+    {
+      HOST_WIDE_INT disp = 0;
+      if (frame->reg_offset[regno] == -1
+	  /* Hard frame pointer has been restored.  */
+	  || (frame_pointer_needed && regno == R27_REGNUM)
+	  /* blink register has been restored.  */
+	  || (regno == BLINK_REGNUM))
+	continue;
+
+      if (ARC64_HAS_FP_BASE && FP_REGNUM_P (regno))
+	{
+	  restore_mode = ARC64_HAS_FPUD ? DFmode : SFmode;
+	  disp = UNITS_PER_WORD;
+	}
+      else if (TARGET_WIDE_LDST
+	       /* Use 128bit loads for context restoring.  */
+	       && ((regno % 2) == 0)
+	       && (!frame_pointer_needed || ((regno + 1) != R27_REGNUM))
+	       && (frame->reg_offset[regno + 1] != -1))
+	{
+	  restore_mode = TImode;
+	}
+      else
+	restore_mode = DImode;
+
+      reg = gen_rtx_REG (restore_mode, regno);
+      frame_deallocated += frame_restore_reg (reg, disp);
+
+      if (restore_mode == TImode)
+	regno ++;
+    }
+
+  return frame_deallocated;
+}
+
+/* Emit an insn that's a simple single-set.  Both the operands must be
+   known to be valid.  */
+inline static rtx_insn *
+emit_set_insn (rtx x, rtx y)
+{
+  return emit_insn (gen_rtx_SET (x, y));
+}
+
+/* Given FROM and TO register numbers, say whether this elimination is allowed.
+   Frame pointer elimination is automatically handled.
+
+   All eliminations are permissible. If we need a frame
+   pointer, we must eliminate ARG_POINTER_REGNUM into
+   FRAME_POINTER_REGNUM and not into STACK_POINTER_REGNUM.  */
+
+static bool
+arc64_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)
+{
+  return ((to == HARD_FRAME_POINTER_REGNUM) || (to == STACK_POINTER_REGNUM));
+}
+
+/* Giving a symbol, return how it will be addressed.  */
+
+static arc64_symb
+arc64_get_symbol_type (rtx x)
+{
+  bool is_local = false, is_tls = false;
+
+  /* Labels are always local, so a short access will suffice.  FIXME!
+     For large model, we should use a pc-rel accessing.  */
+  if (LABEL_REF_P (x))
+    return flag_pic ? ARC64_PIC :
+      (arc64_cmodel_var ==  ARC64_CMODEL_LARGE ? ARC64_LARGE : ARC64_LO32);
+
+  /* FIXME! Maybe I should assert here.  */
+  if (!SYMBOL_REF_P (x))
+    return ARC64_UNK;
+
+  is_local = SYMBOL_REF_DECL (x)
+    ? targetm.binds_local_p (SYMBOL_REF_DECL (x))
+    : SYMBOL_REF_LOCAL_P (x);
+  is_tls = SYMBOL_REF_TLS_MODEL (x);
+
+  if (is_tls)
+    return ARC64_TLS;
+
+  if (!flag_pic)
+    switch (arc64_cmodel_var)
+      {
+      case ARC64_CMODEL_SMALL:
+      case ARC64_CMODEL_MEDIUM:
+	return ARC64_LO32;
+      case ARC64_CMODEL_LARGE:
+	return ARC64_LARGE;
+      default:
+	gcc_unreachable ();
+      }
+  else if (flag_pic == 1)
+    return ARC64_PIC;
+  else if (is_local)
+    return ARC64_PIC;
+  else
+    return ARC64_LPIC;
+}
+
+/* Helper legitimate address. Extra takes an input to discriminate
+   among load or store addresses.  */
+static bool
+arc64_legitimate_address_1_p (machine_mode mode,
+			      rtx x,
+			      bool strict ATTRIBUTE_UNUSED,
+			      bool load_p,
+			      bool scaling_p)
+{
+  if (REG_P (x))
+    return true;
+
+  if (CONST_INT_P (x))
+    return true;
+
+  if (CONSTANT_P (x))
+    {
+      /* Don't allow constant + offset when we don't have native
+	 ld/st, as the compiler may use very large offsets.  These
+	 memory accesses are splited anyhow.  */
+      if (GET_MODE_SIZE (mode) == (UNITS_PER_WORD * 2)
+	  && !TARGET_WIDE_LDST)
+	return false;
+      if (GET_CODE (XEXP (x, 0)) == PLUS
+	  && CONST_INT_P (XEXP (XEXP (x, 0), 1))
+	  /* Reloc addendum is only 32bit.   */
+	  && UNSIGNED_INT32 (INTVAL (XEXP (XEXP (x, 0), 1))))
+	x = XEXP (XEXP (x, 0), 0);
+    }
+
+  if (GET_CODE (x) == SYMBOL_REF
+      || GET_CODE (x) == LABEL_REF)
+    return (arc64_get_symbol_type (x) == ARC64_LO32);
+
+  /* ST instruction can only accept a single register plus a small
+     offset as address.  */
+  if (GET_CODE (x) == PLUS
+      && REG_P (XEXP (x, 0))
+      && (ARC64_CHECK_SMALL_IMMEDIATE (XEXP (x, 1),
+				       scaling_p ? mode : QImode)
+	  || (load_p && CONST_INT_P (XEXP (x, 1))
+	      && !lra_in_progress && !optimize_size)))
+      return true;
+
+  /* Indexed addresses.  */
+  if (load_p
+      && GET_CODE (x) == PLUS
+      && REG_P (XEXP (x, 0))
+      && REG_P (XEXP (x, 1)))
+    return true;
+
+  /* Scalled addresses.  Permitted variants:
+     ld.as rx, [rb,ri]         addr = rb + ri * scaling
+     ld.as rx, [offset32, ri]  addr = offset32 + ri * scalling
+
+     The store address can have only immediate operands scalled.  This
+     case toghether with its load variant are handled by above
+     code.  */
+  if (scaling_p
+      && load_p
+      && GET_CODE (x) == PLUS
+      && (REG_P (XEXP (x, 1)) || CONST_INT_P (XEXP (x, 1)))
+      /* Check multiplication.  */
+      && GET_CODE (XEXP (x, 0)) == MULT
+      && REG_P (XEXP (XEXP (x, 0), 0))
+      && CONST_INT_P (XEXP (XEXP (x, 0), 1)))
+    switch (GET_MODE_SIZE (mode))
+      {
+      case 2:
+      case 4:
+      case 8:
+	if (INTVAL (XEXP (XEXP (x, 0), 1)) == GET_MODE_SIZE (mode))
+	  return true;
+	break;
+      case 16:
+	if (INTVAL (XEXP (XEXP (x, 0), 1)) == UNITS_PER_WORD)
+	  return TARGET_WIDE_LDST;
+	break;
+      default:
+	break;
+      }
+
+  if ((GET_CODE (x) == PRE_DEC || GET_CODE (x) == PRE_INC
+       || GET_CODE (x) == POST_DEC || GET_CODE (x) == POST_INC)
+      && REG_P (XEXP (x, 0)))
+    return true;
+
+  if ((GET_CODE (x) == PRE_MODIFY || GET_CODE (x) == POST_MODIFY))
+    return arc64_legitimate_address_1_p (mode, XEXP (x, 1), strict,
+					 load_p, false);
+
+  /* PIC address (LARGE).  */
+  if (GET_CODE (x) == LO_SUM
+      && REG_P (XEXP (x, 0))
+      && GET_CODE (XEXP (x, 1)) == UNSPEC)
+    return true;
+
+  /* PIC address (small) or local symbol.  */
+  if (load_p
+      && GET_CODE (x) == UNSPEC
+      && (XINT (x, 1) == ARC64_UNSPEC_GOT32
+	  || XINT (x, 1) == ARC64_UNSPEC_TLS_IE
+	  || XINT (x, 1) == ARC64_UNSPEC_PCREL))
+    return true;
+
+  return false;
+}
+
+/* Return TRUE if X is a legitimate address for accessing memory in
+   mode MODE.  We do recognize addresses like:
+   - [Rb]
+   - [Rb, s9]
+   - [Rb, Ri] (ld only)
+   - [Rb, limm] (ld only)
+   - predec/postdec
+   - preinc/postinc
+   - premodif/postmodif
+*/
+
+static bool
+arc64_legitimate_address_p (machine_mode mode,
+			    rtx x,
+			    bool strict ATTRIBUTE_UNUSED)
+{
+  /* Allow all the addresses accepted by load.  */
+  return arc64_legitimate_address_1_p (mode, x, strict, true, true);
+}
+
+/* Implement TARGET_LEGITIMATE_CONSTANT_P hook.  Return true for constants
+   that should be rematerialized rather than spilled.  */
+
+static bool
+arc64_legitimate_constant_p (machine_mode mode, rtx x)
+{
+  switch (GET_CODE (x))
+    {
+    case CONST_DOUBLE:
+    case CONST_INT:
+    case CONST_WIDE_INT:
+    case HIGH:
+      if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)
+	return false;
+      return true;
+
+    case SYMBOL_REF:
+    case LABEL_REF:
+      return true;
+
+    case CONST:
+      if (GET_CODE (XEXP (x, 0)) == PLUS)
+	{
+	  rtx tmp = XEXP (x, 0);
+	  bool t1 = arc64_legitimate_constant_p (mode, XEXP (tmp, 0));
+	  bool t2 = arc64_legitimate_constant_p (mode, XEXP (tmp, 1));
+	  return (t1 && t2);
+	}
+      return false;
+
+    default:
+      return false;
+    }
+}
+
+/* Giving a mode, return true if we can pass it in fp registers.  */
+
+bool
+arc64_use_fp_regs (machine_mode mode)
+{
+  if (!FLOAT_MODE_P (mode))
+    return false;
+
+  /* FPU unit can have either 32 or 64 bit wide data path.  */
+  if ((ARC64_HAS_FPUS && (GET_MODE_SIZE (mode) == (UNITS_PER_WORD / 2)))
+      || (ARC64_HAS_FPUH && (GET_MODE_SIZE (mode) == (UNITS_PER_WORD / 4)))
+      || ARC64_HAS_FPUD)
+    return true;
+  return false;
+}
+
+static rtx
+arc64_gen_fp_pair (machine_mode mode, unsigned regno1,
+		 machine_mode mode1, HOST_WIDE_INT offset1,
+		 unsigned regno2, machine_mode mode2,
+		 HOST_WIDE_INT offset2)
+{
+  return gen_rtx_PARALLEL
+    (mode,
+     gen_rtvec (2,
+		gen_rtx_EXPR_LIST (VOIDmode,
+				   gen_rtx_REG (mode1, regno1),
+				   GEN_INT (offset1)),
+		gen_rtx_EXPR_LIST (VOIDmode,
+				   gen_rtx_REG (mode2, regno2),
+				   GEN_INT (offset2))));
+}
+
+static rtx
+arc64_layout_arg (struct arc64_arg_info *info, cumulative_args_t pcum_v,
+		  machine_mode mode, const_tree type, bool named)
+{
+  CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);
+  HOST_WIDE_INT size;
+  unsigned int nregs;
+
+  memset (info, 0, sizeof (*info));
+  info->off_fpr = pcum->fregs;
+  info->off_gpr = pcum->iregs;
+
+  /* Find out the size of argument.  */
+  size = type ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);
+  size = ROUND_UP (size, UNITS_PER_WORD);
+  nregs = size / UNITS_PER_WORD;
+
+  /* When named, we can pass FP types into FP registers if they
+     exists and they have the right size.  */
+  if (named && arc64_use_fp_regs (mode)
+      && (info->off_fpr + nregs < MAX_ARC64_PARM_REGS))
+    {
+      int fregno = F0_REGNUM + info->off_fpr;
+      info->nfpr = nregs;
+      switch (GET_MODE_CLASS (mode))
+	{
+	case MODE_VECTOR_FLOAT:
+	  /* FIXME! for double-sized vectors, we may need to use double
+	     register.  */
+	case MODE_FLOAT:
+	  return gen_rtx_REG (mode, fregno);
+
+	case MODE_COMPLEX_FLOAT:
+	  return arc64_gen_fp_pair (mode, fregno, GET_MODE_INNER (mode), 0,
+				    fregno + 1, GET_MODE_INNER (mode),
+				    GET_MODE_UNIT_SIZE (mode));
+
+	default:
+	  gcc_unreachable ();
+	}
+    }
+
+  /* Partition the argument between register and stack.  */
+  gcc_assert (info->nfpr == 0);
+  info->ngpr = MIN (nregs, MAX_ARC64_PARM_REGS - info->off_gpr);
+  info->stack_p = (nregs - info->ngpr) != 0;
+
+  if (info->ngpr)
+    return gen_rtx_REG (mode, R0_REGNUM + info->off_gpr);
+  return NULL_RTX;
+}
+
+/* Worker for return_in_memory.  */
+/* FIXME! shall we use pass_by_reference?  */
+
+static bool
+arc64_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)
+{
+  HOST_WIDE_INT size;
+
+  /* Maybe we may need to return simple scalar types in registers:
+  if (!AGGREGATE_TYPE_P (type)
+      && TREE_CODE (type) != COMPLEX_TYPE)
+    return false;
+  */
+  if (AGGREGATE_TYPE_P (type) || TREE_ADDRESSABLE (type))
+    return true;
+
+  size = int_size_in_bytes (type);
+
+  /* Double sized float vectors are mapped into even-odd register
+     pair, hence use the stack when someone wants to pass them to
+     the caller.  */
+  if (VECTOR_FLOAT_TYPE_P (type) && size > UNITS_PER_WORD)
+    return true;
+
+  /* Types larger than 2 registers returned in memory.  */
+  return ((size < 0) || (size > 2 * UNITS_PER_WORD));
+}
+
+/* Worker for pass_by_reference.  */
+
+static bool
+arc64_pass_by_reference (cumulative_args_t cum_v,
+			 const function_arg_info &arg)
+{
+  HOST_WIDE_INT size = arg.type_size_in_bytes ();
+  struct arc64_arg_info info;
+  CUMULATIVE_ARGS *pcum = get_cumulative_args (cum_v);
+
+  /* Double sized fp-vectors are passed on the stack.  */
+  if (arg.type
+      && VECTOR_FLOAT_TYPE_P (arg.type) && size > UNITS_PER_WORD)
+    return true;
+
+  /* N.B. std_gimplify_va_arg_expr passes NULL for cum.  However, we
+     do not use variadic arguments in fp-regs.  */
+  if (pcum != NULL)
+    {
+      /* Check if we can use fp regs.  */
+      arc64_layout_arg (&info, cum_v, arg.mode, arg.type, arg.named);
+      if (info.nfpr)
+	return false;
+    }
+
+  /* Variable sized arguments are always returned by reference, and
+     arguments which are variable sized or larger than 2 registers are
+     passed by reference.  */
+  return !IN_RANGE (size, 0, 2 * UNITS_PER_WORD);
+}
+
+/* The function to update the summarizer variable *CUM to advance past
+   an argument in the argument list.  The values MODE, TYPE and NAMED
+   describe that argument.  Once this is done, the variable *CUM is
+   suitable for analyzing the *following* argument with
+   `FUNCTION_ARG', etc.  */
+
+static void
+arc64_function_arg_advance (cumulative_args_t pcum_v,
+			    const function_arg_info &arg)
+{
+  struct arc64_arg_info info;
+  CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);
+
+  arc64_layout_arg (&info, pcum_v, arg.mode, arg.type, arg.named);
+
+  pcum->fregs = info.nfpr + info.off_fpr;
+  pcum->iregs = info.ngpr + info.off_gpr;
+}
+
+/* Implement TARGET_ARG_PARTIAL_BYTES.  */
+
+static int
+arc64_arg_partial_bytes (cumulative_args_t pcum_v,
+			 const function_arg_info &arg)
+{
+  struct arc64_arg_info info;
+
+  arc64_layout_arg (&info, pcum_v, arg.mode, arg.type, arg.named);
+  gcc_assert ((info.nfpr == 0) || (info.ngpr == 0));
+
+  return info.stack_p ? info.ngpr * UNITS_PER_WORD : 0;
+}
+
+/* This function is used to control a function argument is passed in a
+   register, and which register.
+
+   The arguments are CUM, of type CUMULATIVE_ARGS, which summarizes
+   (in a way defined by INIT_CUMULATIVE_ARGS and FUNCTION_ARG_ADVANCE)
+   all of the previous arguments so far passed in registers; MODE, the
+   machine mode of the argument; TYPE, the data type of the argument
+   as a tree node or 0 if that is not known (which happens for C
+   support library functions); and NAMED, which is 1 for an ordinary
+   argument and 0 for nameless arguments that correspond to `...' in
+   the called function's prototype.
+
+   The returned value should either be a `reg' RTX for the hard
+   register in which to pass the argument, or zero to pass the
+   argument on the stack.  */
+
+static rtx
+arc64_function_arg (cumulative_args_t pcum_v,
+		    const function_arg_info &arg)
+{
+  struct arc64_arg_info info;
+
+  return arc64_layout_arg (&info, pcum_v, arg.mode, arg.type, arg.named);
+}
+
+/* Define how to find the value returned by a function.  VALTYPE is
+   the data type of the value (as a tree).  If the precise function
+   being called is known, FN_DECL_OR_TYPE is its FUNCTION_DECL;
+   otherwise, FN_DECL_OR_TYPE is its type.  */
+
+static rtx
+arc64_function_value (const_tree type,
+		      const_tree func,
+		      bool outgoing ATTRIBUTE_UNUSED)
+{
+  machine_mode mode = TYPE_MODE (type);
+  int unsignedp = TYPE_UNSIGNED (type);
+
+  if (INTEGRAL_TYPE_P (type))
+    mode = promote_function_mode (type, mode, &unsignedp, func, 1);
+
+  if (arc64_use_fp_regs (mode))
+    {
+      switch (GET_MODE_CLASS (mode))
+	{
+	case MODE_VECTOR_FLOAT:
+	  /* FIXME! for double-sized vectors, we may need to use double
+	     register.  */
+	case MODE_FLOAT:
+	  return gen_rtx_REG (mode, F0_REGNUM);
+
+	case MODE_COMPLEX_FLOAT:
+	  return arc64_gen_fp_pair (mode, F0_REGNUM, GET_MODE_INNER (mode), 0,
+				    F1_REGNUM, GET_MODE_INNER (mode),
+				    GET_MODE_UNIT_SIZE (mode));
+
+	default:
+	  gcc_unreachable ();
+	}
+
+    }
+  return gen_rtx_REG (mode, R0_REGNUM);
+}
+
+/* Implements TARGET_FUNCTION_VALUE_REGNO_P.
+   Return true if REGNO is the number of a hard register in which the values
+   of called function may come back.  */
+
+static bool
+arc64_function_value_regno_p (const unsigned int regno)
+{
+  /* Maximum of 16 bytes can be returned in the general registers.  Examples
+     of 16-byte return values are: 128-bit integers and 16-byte small
+     structures (excluding homogeneous floating-point aggregates).
+
+     We need to implement untyped_call instruction pattern when
+     returning more than one value.  */
+
+  if (regno == R0_REGNUM)
+    return true;
+
+  if (regno == F0_REGNUM)
+    return ARC64_HAS_FP_BASE;
+
+  return false;
+}
+
+static bool
+arc64_split_complex_arg (const_tree)
+{
+  return true;
+}
+
+/* Implement TARGET_SETUP_INCOMING_VARARGS.  */
+
+static void
+arc64_setup_incoming_varargs (cumulative_args_t cum_v,
+			      const function_arg_info &arg,
+			      int *pretend_size, int no_rtl)
+{
+  CUMULATIVE_ARGS cum = *get_cumulative_args (cum_v);
+  int gpi_saved;
+
+  /* The caller has advanced CUM up to, but not beyond, the last named
+     argumend.  Advance a local copu of CUM past the last "real" named
+     argument, to find out how many registers are left over.  */
+  arc64_function_arg_advance (pack_cumulative_args (&cum), arg);
+
+  cfun->machine->uses_anonymous_args = 1;
+  if (!FUNCTION_ARG_REGNO_P (cum.iregs))
+    return;
+
+  gpi_saved = MAX_ARC64_PARM_REGS - cum.iregs;
+
+  if (!no_rtl && gpi_saved > 0)
+    {
+      rtx ptr, mem;
+      ptr = plus_constant (Pmode, arg_pointer_rtx, 0);
+      mem = gen_frame_mem (BLKmode, ptr);
+      set_mem_alias_set (mem, get_varargs_alias_set ());
+
+      move_block_from_reg (R0_REGNUM + cum.iregs, mem, gpi_saved);
+    }
+
+  /* FIXME! do I need to ROUND_UP (pretend, STACK_BOUNDARY /
+     BITS_PER_UNIT) ?  */
+  *pretend_size = gpi_saved * UNITS_PER_WORD;
+}
+
+/* Implement TARGET_HARD_REGNO_NREGS.  */
+
+static unsigned int
+arc64_hard_regno_nregs (unsigned int regno,
+			machine_mode mode)
+{
+  if (FP_REGNUM_P (regno))
+    return CEIL (GET_MODE_SIZE (mode), UNITS_PER_FP_REG);
+  return CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);
+}
+
+/* Implement TARGET_HARD_REGNO_MODE_OK.  */
+
+static bool
+arc64_hard_regno_mode_ok (unsigned int regno, machine_mode mode)
+{
+  if (GET_MODE_CLASS (mode) == MODE_CC)
+    return regno == CC_REGNUM;
+
+  if (regno == SP_REGNUM
+      || regno == FRAME_POINTER_REGNUM
+      || regno == ARG_POINTER_REGNUM)
+    return (mode == Pmode);
+
+  if (regno <= R58_REGNUM)
+    {
+      if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)
+	return true;
+      else if (GET_MODE_SIZE (mode) <= (UNITS_PER_WORD * 2))
+	return ((regno & 1) == 0);
+    }
+  else if (FLOAT_MODE_P (mode) && FP_REGNUM_P (regno))
+    {
+      /* FIXME! I should make the decision base on the WIDE option
+	 alone, if we need double regs or not.  */
+      if (ARC64_VFP_128
+	  && (GET_MODE_SIZE (mode) <= (UNITS_PER_FP_REG * 2))
+	  && (GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT))
+	return ((regno & 1) == 0);
+      return true;
+    }
+
+  return false;
+}
+
+/* Implement TARGET_MODES_TIEABLE_P.  Tie QI/HI/SI/DI modes together.  */
+
+static bool
+arc64_modes_tieable_p (machine_mode mode1, machine_mode mode2)
+{
+  if (GET_MODE_CLASS (mode1) == MODE_INT
+      && GET_MODE_CLASS (mode2) == MODE_INT
+      && GET_MODE_SIZE (mode1) <= UNITS_PER_WORD
+      && GET_MODE_SIZE (mode2) <= UNITS_PER_WORD)
+    return true;
+
+  return false;
+}
+
+static inline bool
+arc64_short_insn_p (rtx_insn *insn)
+{
+  enum attr_iscompact iscompact;
+
+  iscompact = get_attr_iscompact (insn);
+  if (iscompact == ISCOMPACT_YES)
+    return true;
+
+  if (iscompact == ISCOMPACT_MAYBE)
+    return (get_attr_length (insn) == 2)
+      || (get_attr_length (insn) == 6);
+
+  return (get_attr_length (insn) == 2);
+}
+
+/* Returns the index of the ARC condition code string in
+   `arc_condition_codes'.  COMPARISON should be an rtx like `(eq (...)
+   (...))'.  */
+
+static int
+get_arc64_condition_code (rtx comparison)
+{
+  switch (GET_MODE (XEXP (comparison, 0)))
+    {
+    case E_CCmode:
+    case E_SImode:
+      switch (GET_CODE (comparison))
+	{
+	case EQ : return ARC_CC_EQ;
+	case NE : return ARC_CC_NE;
+	case GT : return ARC_CC_GT;
+	case LE : return ARC_CC_LE;
+	case GE : return ARC_CC_GE;
+	case LT : return ARC_CC_LT;
+	case GTU : return ARC_CC_HI;
+	case LEU : return ARC_CC_LS;
+	case LTU : return ARC_CC_LO;
+	case GEU : return ARC_CC_HS;
+	default : gcc_unreachable ();
+	}
+    case E_CC_ZNmode:
+      switch (GET_CODE (comparison))
+	{
+	case EQ : return ARC_CC_EQ;
+	case NE : return ARC_CC_NE;
+	case GE: return ARC_CC_P;
+	case LT: return ARC_CC_N;
+	case GT : return ARC_CC_PNZ;
+	default : gcc_unreachable ();
+	}
+    case E_CC_Zmode:
+      switch (GET_CODE (comparison))
+	{
+	case EQ : return ARC_CC_EQ;
+	case NE : return ARC_CC_NE;
+	default : gcc_unreachable ();
+	}
+    case E_CC_Cmode:
+      switch (GET_CODE (comparison))
+	{
+	case LTU : return ARC_CC_C;
+	case GEU : return ARC_CC_NC;
+	default : gcc_unreachable ();
+	}
+    case E_CC_FPUmode:
+    case E_CC_FPUEmode:
+      switch (GET_CODE (comparison))
+	{
+	case EQ: return ARC_CC_EQ;
+	case NE: return ARC_CC_NE;
+	case GT: return ARC_CC_GT;
+	case GE: return ARC_CC_GE;
+	case LT:
+	  /* Equivalent with N, short insn friendly.  */
+	  return ARC_CC_C;
+	case LE: return ARC_CC_LS;
+	case UNORDERED: return ARC_CC_V;
+	case ORDERED: return ARC_CC_NV;
+	case UNGT: return ARC_CC_HI;
+	case UNGE:
+	   /* Equivalent with NV, short insn friendly.  */
+	  return ARC_CC_HS;
+	case UNLT: return ARC_CC_LT;
+	case UNLE: return ARC_CC_LE;
+	default: gcc_unreachable ();
+	}
+      break;
+    default : gcc_unreachable ();
+    }
+  gcc_unreachable ();
+}
+
+/* Print operand X (an rtx) in assembler syntax to file FILE.  CODE is
+   a letter or dot (`z' in `%z0') or 0 if no letter was specified.
+   For `%' followed by punctuation, CODE is the punctuation and X is
+   null.  Letters `acln' are reserved.  The acceptable formatting
+   commands given by CODE are:
+     '0': Print a normal operand, if it's a general register,
+	  then we assume DImode.
+     'U': Load/store update or scaling indicator.
+     'm': output condition code without 'dot'.
+     '?': Short instruction suffix.
+     'L': Lower 32bit of immediate or symbol.
+     'h': Higher 32bit of an immediate, 64b-register or symbol.
+     'C': Constant address, switches on/off @plt.
+     's': Scalled immediate.
+     'S': Scalled immediate, to be used in pair with 's'.
+     'N': Negative immediate, to be used in pair with 's'.
+*/
+
+static void
+arc64_print_operand (FILE *file, rtx x, int code)
+{
+  HOST_WIDE_INT ival;
+  static const char * const arc_condition_codes[] =
+    {
+     "al", 0, "eq", "ne", "p", "n", "lo", "hs", "v", "nv",
+     "gt", "le", "ge", "lt", "hi", "ls", "pnz", 0
+    };
+
+  int scalled = 0;
+  int sign = 1;
+
+  switch (code)
+    {
+    case '?':
+      if (arc64_short_insn_p (current_output_insn))
+	fputs ("_s", file);
+      break;
+
+    case 'U' :
+      /* Output a load/store with update indicator if appropriate.  */
+      if (!MEM_P (x))
+	{
+	  output_operand_lossage ("invalid operand for %%U code");
+	  return;
+	}
+
+      /* FIXME! consider volatile accesses as .di accesses, everything
+	 under an option.  */
+      if (MEM_VOLATILE_P (x) && TARGET_VOLATILE_DI)
+	fputs (".di", file);
+
+      switch (GET_CODE (XEXP (x, 0)))
+	{
+	case PRE_INC:
+	case PRE_DEC:
+	case PRE_MODIFY:
+	  fputs (".a", file);
+	  break;
+
+	case POST_INC:
+	case POST_DEC:
+	case POST_MODIFY:
+	  fputs (".ab", file);
+	  break;
+
+	case PLUS:
+	  if (GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT)
+	    fputs (".as", file);
+	  else if (REG_P (XEXP (XEXP (x, 0), 0))
+		   && ARC64LOG2 (GET_MODE_SIZE (GET_MODE (x)))
+		   && ARC64_CHECK_SMALL_IMMEDIATE (XEXP (XEXP (x, 0), 1),
+						   GET_MODE (x)))
+	    {
+	      fputs (".as", file);
+	      scalled_p = true;
+	    }
+	default:
+	  break;
+	}
+      break;
+
+    case 'L':
+      if (GET_CODE (x) == SYMBOL_REF
+	  || GET_CODE (x) == LABEL_REF)
+	{
+	  output_addr_const (asm_out_file, x);
+	  fputs ("@u32", file);
+	  break;
+	}
+      else if (!CONST_INT_P (x))
+	{
+	  output_operand_lossage ("invalid operand for %%L code");
+	  return;
+	}
+      ival = INTVAL (x);
+      ival &= 0xffffffffULL;
+      fprintf (file,"0x%08" PRIx32, (uint32_t) ival);
+      break;
+
+    case 'h':
+      if (GET_CODE (x) == SYMBOL_REF
+	  || GET_CODE (x) == LABEL_REF
+	  || GET_CODE (x) == UNSPEC)
+	{
+	  output_addr_const (asm_out_file, x);
+	  break;
+	}
+      else if (CONST_INT_P (x))
+	{
+	  ival = INTVAL (x);
+	  ival >>= 32;
+	  fprintf (file, "%d", (int32_t) ival);
+	}
+      else if (REG_P (x))
+	asm_fprintf (file, "%s", reg_names [REGNO (x) + 1]);
+      else
+	{
+	  output_operand_lossage ("invalid operand for %%h code");
+	  return;
+	}
+      break;
+
+    case 'm':
+      fputs (arc_condition_codes[get_arc64_condition_code (x)], file);
+      break;
+
+    case 'C':
+      if (GET_CODE (x) != SYMBOL_REF
+	  && GET_CODE (x) != LABEL_REF)
+	{
+	  output_operand_lossage ("invalid operand for %%C code");
+	  return;
+	}
+      output_addr_const (asm_out_file, x);
+      if (flag_pic
+	  && GET_CODE (x) == SYMBOL_REF
+	  && !SYMBOL_REF_LOCAL_P (x))
+	fputs ("@plt", file);
+      break;
+
+    case 's':
+      if (REG_P (x))
+	break;
+      if (!CONST_INT_P (x))
+	{
+	  output_operand_lossage ("invalid operand for %%s code");
+	  return;
+	}
+      ival = INTVAL (x);
+      if ((ival & 0x07) == 0)
+	  scalled = 3;
+      else if ((ival & 0x03) == 0)
+	  scalled = 2;
+      else if ((ival & 0x01) == 0)
+	  scalled = 1;
+
+      if (scalled)
+	asm_fprintf (file, "%d", scalled);
+      break;
+
+    case 'N':
+      if (REG_P (x))
+	{
+	  output_operand_lossage ("invalid operand for %%N code");
+	  return;
+	}
+      sign = -1;
+      /* fall through */
+    case 'S':
+      if (REG_P (x))
+	{
+	  asm_fprintf (file, "%s", reg_names [REGNO (x)]);
+	  return;
+	}
+      if (!CONST_INT_P (x))
+	{
+	  output_operand_lossage ("invalid operand for %%N or %%S code");
+	  return;
+	}
+      ival = sign * INTVAL (x);
+      if ((ival & 0x07) == 0)
+	  scalled = 3;
+      else if ((ival & 0x03) == 0)
+	  scalled = 2;
+      else if ((ival & 0x01) == 0)
+	  scalled = 1;
+
+      asm_fprintf (file, "%wd", (ival >> scalled));
+      break;
+
+    case 0:
+      if (x == NULL)
+	{
+	  output_operand_lossage ("missing operand");
+	  return;
+	}
+
+      switch (GET_CODE (x))
+	{
+	case REG :
+	  asm_fprintf (file, "%s", reg_names [REGNO (x)]);
+	  break;
+
+	case MEM :
+	  fputc ('[', file);
+	  output_address (GET_MODE (x), XEXP (x, 0));
+	  fputc (']', file);
+	  break;
+
+	case LABEL_REF:
+	case SYMBOL_REF:
+	case UNSPEC:
+	  output_addr_const (asm_out_file, x);
+	  break;
+
+	case CONST_DOUBLE:
+	  {
+	    long l;
+	    int msize;
+	    machine_mode mode = GET_MODE (x);
+	    /* Maybe I need to define TARGET_SUPPORTS_WIDE_INT.  */
+	    gcc_assert (mode != VOIDmode);
+	    /* GET_MODE_BITSIZE BITS_PER_WORD */
+	    msize = GET_MODE_SIZE (mode);
+	    if (msize > (UNITS_PER_WORD / 2))
+	      msize = UNITS_PER_WORD / 2;
+	    msize *= 8;
+	    l = real_to_target (NULL, CONST_DOUBLE_REAL_VALUE (x),
+				float_mode_for_size (msize).require ());
+	    asm_fprintf (file, "0x%08lx", l);
+	    break;
+	  }
+	case CONST_INT:
+	  asm_fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x));
+	  break;
+
+	default:
+	  output_operand_lossage ("invalid operand");
+	  return;
+	}
+      break;
+
+    default:
+      output_operand_lossage ("invalid operand prefix '%%%c'", code);
+    }
+}
+
+/* Print address 'addr' of a memory access with mode 'mode'.  */
+
+static void
+arc64_print_operand_address (FILE *file , machine_mode mode, rtx addr)
+{
+  register rtx base, index = 0;
+
+  switch (GET_CODE (addr))
+    {
+    case REG :
+      fputs (reg_names[REGNO (addr)], file);
+      break;
+
+    case CONST:
+      output_address (mode, XEXP (addr, 0));
+      break;
+
+    case PLUS :
+      if (GET_CODE (XEXP (addr, 0)) == MULT)
+	index = XEXP (XEXP (addr, 0), 0), base = XEXP (addr, 1);
+      else if (CONST_INT_P (XEXP (addr, 0)))
+	index = XEXP (addr, 0), base = XEXP (addr, 1);
+      else
+	base = XEXP (addr, 0), index = XEXP (addr, 1);
+
+      gcc_assert (OBJECT_P (base));
+      if (REG_P (base)
+	  && scalled_p
+	  && ARC64LOG2 (GET_MODE_SIZE (mode))
+	  && ARC64_CHECK_SMALL_IMMEDIATE (index, mode))
+	index = GEN_INT (INTVAL (index) >> ARC64LOG2 (GET_MODE_SIZE (mode)));
+      scalled_p = false;
+
+      arc64_print_operand_address (file, mode, base);
+      if (CONSTANT_P (base) && CONST_INT_P (index))
+	fputc ('+', file);
+      else
+	fputc (',', file);
+      gcc_assert (OBJECT_P (index));
+      arc64_print_operand_address (file, mode, index);
+      break;
+
+    case PRE_INC:
+    case POST_INC:
+      output_address (VOIDmode,
+		      plus_constant (Pmode, XEXP (addr, 0),
+				     GET_MODE_SIZE (mode)));
+      break;
+
+    case PRE_DEC:
+    case POST_DEC:
+      output_address (VOIDmode,
+		      plus_constant (Pmode, XEXP (addr, 0),
+				     -GET_MODE_SIZE (mode)));
+      break;
+
+    case PRE_MODIFY:
+    case POST_MODIFY:
+      output_address (VOIDmode, XEXP (addr, 1));
+      break;
+
+    case LO_SUM:
+      /* This type of address can be only accepted by LD instructions.  */
+      base = XEXP (addr, 0);
+      index = XEXP (addr, 1);
+      arc64_print_operand_address (file, mode, base);
+      fputc (',', file);
+      output_addr_const (file, index);
+      break;
+
+    case UNSPEC:
+      /* Small PIC.  */
+      fputs ("pcl,", file);
+      output_addr_const (file, addr);
+      break;
+
+    case LABEL_REF:
+    case SYMBOL_REF:
+    case CONST_INT:
+      output_addr_const (file, addr);
+      break;
+
+    default:
+      gcc_unreachable ();
+      break;
+    }
+}
+
+/* Target hook for indicating whether a punctuation character for
+   TARGET_PRINT_OPERAND is valid.  */
+
+static bool
+arc64_print_operand_punct_valid_p (unsigned char code)
+{
+  return (code == '?');
+}
+
+/* Implement TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA.  */
+
+static bool
+arc64_output_addr_const_extra (FILE *file, rtx x)
+{
+  rtx base;
+
+  if (GET_CODE (x) == UNSPEC)
+    {
+      base = XVECEXP (x, 0, 0);
+      output_addr_const (file, base);
+      switch (XINT (x, 1))
+	{
+	case ARC64_UNSPEC_PCREL:
+	  fputs ("@pcl", file);
+	  break;
+
+	case ARC64_UNSPEC_GOT32:
+	case ARC64_UNSPEC_GOT:
+	  fputs ("@gotpc", file);
+	  break;
+
+	case ARC64_UNSPEC_TLS_GD:
+	  fputs ("@tlsgd", file);
+	  break;
+
+	case ARC64_UNSPEC_TLS_IE:
+	  fputs ("@tlsie", file);
+	  break;
+
+	case ARC64_UNSPEC_TLS_OFF:
+	  fputs ("@tpoff", file);
+	  break;
+
+	default:
+	  gcc_unreachable ();
+	}
+      return true;
+    }
+
+  return false;
+}
+
+/* Wrap X in an unspec of kind KIND.  */
+
+static rtx
+gen_sym_unspec (rtx x, int kind)
+{
+  return gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), kind);
+}
+
+/* The __tls_get_attr symbol.  */
+static GTY(()) rtx arc_tls_symbol;
+
+/* Emit a call to __tls_get_addr.  TI is the argument to this function.
+   RET is an RTX for the return value location.  The entire insn sequence
+   is returned.  */
+
+static void
+arc64_tls_call (rtx dest, rtx arg)
+{
+  if (!arc_tls_symbol)
+    arc_tls_symbol = init_one_libfunc ("__tls_get_addr");
+
+  emit_library_call_value (arc_tls_symbol, dest, LCT_CONST, Pmode,
+			   arg, Pmode);
+}
+
+/* Create a legitimate mov instruction for the given BASE (unspec).  */
+
+static rtx
+arc64_legit_unspec (rtx base)
+{
+  rtx t1, ret;
+  gcc_assert (can_create_pseudo_p ());
+
+  switch (arc64_cmodel_var)
+    {
+    case ARC64_CMODEL_SMALL:
+    case ARC64_CMODEL_MEDIUM:
+      return base;
+
+    case ARC64_CMODEL_LARGE:
+      t1 = gen_reg_rtx (Pmode);
+      ret = gen_reg_rtx (Pmode);
+      emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, base)));
+      emit_insn (gen_rtx_SET (ret, gen_rtx_LO_SUM (Pmode, t1, base)));
+      return ret;
+
+    default:
+      break;
+    }
+  gcc_unreachable ();
+}
+
+/* Return a legitimized TLS address to access ADDR, which is a
+   SYMBOL_REF.  */
+
+static rtx
+arc64_legitimize_tls_address (rtx addr)
+{
+  rtx t1, t2;
+  rtx base;
+  enum tls_model model = SYMBOL_REF_TLS_MODEL (addr);
+
+  gcc_assert (can_create_pseudo_p ());
+
+  switch (model)
+    {
+    case TLS_MODEL_LOCAL_DYNAMIC:
+    case TLS_MODEL_GLOBAL_DYNAMIC:
+      /* Gen:
+	 addl r0,pcl,@ADDR@tlsgd
+	 bl __tls_get_addr@plt  */
+      t2 = gen_reg_rtx (Pmode);
+      base = gen_sym_unspec (addr, ARC64_UNSPEC_TLS_GD);
+      t1 = arc64_legit_unspec (base);
+      arc64_tls_call (t2, t1);
+      return t2;
+
+    case TLS_MODEL_INITIAL_EXEC:
+      /* Gen:
+	 ldl  rx,[pcl,@ADDR@tlsie]
+	 addl rx,rx,r30  */
+      addr = arc64_legit_unspec (gen_sym_unspec (addr, ARC64_UNSPEC_TLS_IE));
+      addr = copy_to_mode_reg (Pmode, gen_const_mem (Pmode, addr));
+      return gen_rtx_PLUS (Pmode, addr, gen_rtx_REG (Pmode, R30_REGNUM));
+
+    case TLS_MODEL_LOCAL_EXEC:
+      /* Gen:
+	 addl rx,r30,@ADDR@tpoff  */
+      addr = arc64_legit_unspec (gen_sym_unspec (addr, ARC64_UNSPEC_TLS_OFF));
+      return gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, R30_REGNUM), addr);
+
+    default:
+      gcc_unreachable ();
+    }
+}
+
+/* Helper function.  Returns a valid ARC64 RTX that represents the
+   argument X which is an invalid address RTX.  The argument SCRATCH
+   may be used as a temp when building affresses.  */
+
+static rtx
+arc64_legitimize_address_1 (rtx x, rtx scratch)
+{
+  rtx base, addend, t1;
+  bool is_local = true, ATTRIBUTE_UNUSED is_weak = false;
+
+  switch (GET_CODE (x))
+    {
+    case SYMBOL_REF:
+      is_local = SYMBOL_REF_DECL (x)
+	? targetm.binds_local_p (SYMBOL_REF_DECL (x))
+	: SYMBOL_REF_LOCAL_P (x);
+      is_weak = SYMBOL_REF_WEAK (x);
+      if (SYMBOL_REF_TLS_MODEL (x))
+	return arc64_legitimize_tls_address (x);
+      /* FALLTHRU */
+
+    case LABEL_REF:
+      t1 = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : scratch;
+      gcc_assert (t1);
+      if (!flag_pic)
+	{
+	  switch (arc64_cmodel_var)
+	    {
+	    case ARC64_CMODEL_SMALL:
+	    case ARC64_CMODEL_MEDIUM:
+	      return x;
+	    default:
+	      emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, x)));
+	      return gen_rtx_LO_SUM (Pmode, t1, x);
+	    }
+	}
+      else if (is_local)
+	{
+	  /* Local symbol, we can access it using a simple
+	     PCL-relative access.  */
+	  base = gen_sym_unspec (x, ARC64_UNSPEC_PCREL);
+	  return base;
+	}
+      else if (flag_pic)
+	{
+	  /* Global symbol, we access it via a load from the GOT
+	     (small model).  I.e., load pointer address via GOT, do
+	     the access of the datum using the loaded pointer.  */
+	  /* FIXME! to enable LARGE/small pic models make the above
+	     condition flag_pic == 1.  */
+	  base = gen_sym_unspec (x, ARC64_UNSPEC_GOT32);
+	  return gen_const_mem (Pmode, base);
+	}
+      else
+	{
+	  /* Global symbol, we access it via a load from the GOT
+	     (LARGE model).  */
+	  base = gen_sym_unspec (x, ARC64_UNSPEC_GOT);
+	  emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, base)));
+	  t1 = gen_rtx_LO_SUM (Pmode, t1, copy_rtx (base));
+	  return gen_const_mem (Pmode, t1);
+	}
+
+    case LO_SUM:
+      return x;
+
+    case CONST:
+      /* We expect something like: const (plus (symbol_ref) (const_int))
+	 A c-function which will generate this should be:
+	 int a;
+	 void b (void) { a = "" ? "" + 8 : 3; }
+       */
+      gcc_assert (can_create_pseudo_p ());
+      split_const (x, &base, &addend);
+      base = force_reg (Pmode, base);
+      if (addend == const0_rtx)
+	return base;
+      return gen_rtx_PLUS (Pmode, base, addend);
+
+    default:
+      break;
+    }
+
+  gcc_unreachable ();
+}
+
+
+/* Nested function support.  */
+
+/* Output assembler code for a block containing the constant parts of
+   a trampoline, leaving space for variable parts.  A trampoline looks
+   like this:
+
+   nop
+   ldl  r12,[pcl,12]
+   ldl  r11,[pcl,16]
+   j    [r12]
+   .xword function's address
+   .xword static chain value
+
+*/
+
+static void
+arc64_asm_trampoline_template (FILE *f)
+{
+  asm_fprintf (f, "\tnop\n");
+  asm_fprintf (f, "\tldl\t%s,[pcl,12]\n", reg_names[12]);
+  asm_fprintf (f, "\tldl\t%s,[pcl,16]\n", reg_names[STATIC_CHAIN_REGNUM]);
+  asm_fprintf (f, "\tj\t[%s]\n", reg_names[12]);
+  assemble_aligned_integer (POINTER_BYTES, const0_rtx);
+  assemble_aligned_integer (POINTER_BYTES, const0_rtx);
+}
+
+/* Helper initialize trampoline.  */
+
+static void
+arc64_initialize_trampoline (rtx tramp, tree fndecl, rtx cxt)
+{
+  rtx fnaddr = XEXP (DECL_RTL (fndecl), 0);
+
+  emit_block_move (tramp, assemble_trampoline_template (),
+		   GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);
+  emit_move_insn (adjust_address (tramp, Pmode, 12+4), fnaddr);
+  emit_move_insn (adjust_address (tramp, Pmode, 20+4), cxt);
+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, "__clear_cache"),
+		     LCT_NORMAL, VOIDmode, XEXP (tramp, 0), Pmode,
+		     plus_constant (Pmode, XEXP (tramp, 0), TRAMPOLINE_SIZE),
+		     Pmode);
+}
+
+/* Implement FUNCTION_OK_FOR_SIBCALL hook.  */
+
+static bool
+arc64_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,
+			     tree exp ATTRIBUTE_UNUSED)
+{
+  return true;
+}
+
+/* Implement INIT_LIBFUNCS hook.  */
+
+static void
+arc64_init_libfuncs (void)
+{
+  set_optab_libfunc (ffs_optab, SImode, "__ffssi2");
+  set_optab_libfunc (clz_optab, SImode, "__clzsi2");
+  set_optab_libfunc (ctz_optab, SImode, "__ctzsi2");
+  set_optab_libfunc (popcount_optab, SImode, "__popcountsi2");
+  set_optab_libfunc (parity_optab, SImode, "__paritysi2");
+}
+
+/* Helper evp_dump_stack_info.  */
+
+static void
+arc64_print_format_registers(FILE *stream,
+			     unsigned regno,
+			     enum machine_mode mode)
+{
+  unsigned int  j, nregs = arc64_hard_regno_nregs (regno, mode);
+  unsigned int ll = 0;
+  for (j = regno+nregs; j > regno; j--)
+    {
+      asm_fprintf (stream,"%s", reg_names[j-1]);
+      ll += strlen (reg_names[j-1]);
+    }
+  asm_fprintf (stream,"`");
+  for (j = ll; j <20; j++)
+    asm_fprintf (stream, " ");
+
+  asm_fprintf (stream,"\t(%d)\n",
+	   GET_MODE_SIZE (mode));
+}
+
+/* Place some comment into assembler stream describing the current
+   function.  */
+
+static void
+arc64_output_function_prologue (FILE *f)
+{
+  int regno, i;
+  struct arc64_frame *frame = &cfun->machine->frame;
+  tree parm = DECL_ARGUMENTS (current_function_decl);
+
+  asm_fprintf (f, "\t# args = %wd, pretend = %ld, frame = %wd\n",
+	       (HOST_WIDE_INT) crtl->args.size,
+	       frame->saved_varargs_size,
+	       (HOST_WIDE_INT) get_frame_size ());
+  asm_fprintf (f, "\t# frame_needed = %d, uses_anonymous_args = %d\n",
+	       frame_pointer_needed,
+	       cfun->machine->uses_anonymous_args);
+  asm_fprintf (f, "\t# size = %wd bytes\n",
+	       frame->frame_size);
+  asm_fprintf (f, "\t# outargs = %wd bytes\n",
+	       frame->saved_outargs_size);
+  asm_fprintf (f, "\t# locals = %wd bytes\n",
+	       frame->saved_locals_size);
+  asm_fprintf (f, "\t# regs = %wd bytes\n",
+	       frame->saved_regs_size);
+  asm_fprintf (f, "\t# varargs = %wd bytes\n",
+	       frame->saved_varargs_size);
+
+  if (crtl->calls_eh_return)
+    asm_fprintf (f, "\t# Calls __builtin_eh_return.\n");
+
+  for (regno = R0_REGNUM; regno <= F31_REGNUM; regno++)
+    if (frame->reg_offset[regno] != -1)
+      asm_fprintf (f, "\t# regsave[%s] => %ld\n", reg_names[regno],
+		   frame->reg_offset[regno]);
+
+  asm_fprintf(f, "\t# Parameters:\n");
+  while (parm)
+    {
+      rtx  rtl = DECL_INCOMING_RTL (parm);
+      if (rtl)
+	{
+	  asm_fprintf(f,"\t#  ");
+	  tree decl_name;
+	  decl_name = DECL_NAME (parm);
+	  if (decl_name != NULL && IDENTIFIER_POINTER (decl_name) != NULL)
+	    {
+	      const char *name =  lang_hooks.dwarf_name (parm, 0);
+	      if(name)
+		asm_fprintf(f, "%-20.20s =`", name);
+	      else
+		asm_fprintf(f, "N.A.`");
+	    }
+	  if (REG_P (rtl))
+	    {
+	      unsigned regno = REGNO (rtl);
+	      enum machine_mode mode = GET_MODE (rtl);
+	      arc64_print_format_registers (f, regno, mode);
+	    }
+	  else if (MEM_P (rtl))
+	    {
+	      rtx addr = XEXP (rtl, 0);
+	      long argPtrOfs = frame->frame_size -
+		arc64_initial_elimination_offset (ARG_POINTER_REGNUM,
+						  (frame_pointer_needed ?
+						   HARD_FRAME_POINTER_REGNUM :
+						   STACK_POINTER_REGNUM));
+	      if (GET_CODE (addr) == PLUS)
+		{
+		  rtx ofs = XEXP (addr, 1);
+		  gcc_assert (CONST_INT_P (ofs));
+		  argPtrOfs += INTVAL (ofs);
+		}
+	      asm_fprintf (f, "%s[%4ld]`                 (%d)\n",
+			   (frame_pointer_needed ? "fp" : "sp"),
+			   argPtrOfs,
+			   GET_MODE_SIZE (GET_MODE (rtl)));
+	    }
+	  else if (GET_CODE (rtl) == PARALLEL)
+	    {
+	      asm_fprintf (f,"xvec`                 (%d)\n",
+			   GET_MODE_SIZE (GET_MODE (rtl)));
+	      for (i = 0; i < XVECLEN (rtl, 0); i++)
+		{
+		  rtx xv = XEXP (XVECEXP (rtl, 0, i), 0);
+		  if (REG_P (xv))
+		    {
+		      unsigned regno = REGNO (xv);
+		      enum machine_mode mode = GET_MODE (xv);
+		      asm_fprintf (f,"#                         `");
+		      arc64_print_format_registers (f, regno, mode);
+		    }
+		}
+	    }
+	  else
+	    {
+	      asm_fprintf(f,"N.A. `\n");
+	    }
+	}
+      parm = TREE_CHAIN (parm);
+    }
+}
+
+/* Helper for INSN_COST.
+
+   Per Segher Boessenkool: rtx_costs computes the cost for any rtx (an
+   insn, a set, a set source, any random piece of one).  set_src_cost,
+   set_rtx_cost, etc. are helper functions that use that.
+
+   Those functions do not work for parallels.  Also, costs are not
+   additive like this simplified model assumes.  Also, more complex
+   backends tend to miss many cases in their rtx_costs function.
+
+   Many passes that want costs want to know the cost of a full insn.  Like
+   combine.  That's why I created insn_cost: it solves all of the above
+   problems.  */
+
+static int
+arc64_insn_cost (rtx_insn *insn, bool speed)
+{
+  int cost;
+
+  /* Needed for ifcvt.  */
+  if (GET_CODE (PATTERN (insn)) == USE)
+    return 1;
+
+  if (recog_memoized (insn) < 0)
+    return 0;
+
+
+  /* Use cost if provided.  */
+  cost = get_attr_cost (insn);
+  if (cost > 0)
+    return cost;
+
+  cost = pattern_cost (PATTERN (insn), speed);
+  return cost;
+#if 0
+  /* If optimizing for size, we want the insn size.  */
+  if (!speed)
+    return get_attr_length (insn);
+
+  /* Use cost if provided.  */
+  cost = get_attr_cost (insn);
+  if (cost > 0)
+    return cost;
+
+  /* For speed make a simple cost model: memory access is more
+     expensive than any other instruction.  */
+  enum attr_type type = get_attr_type (insn);
+
+  switch (type)
+    {
+    case TYPE_LD:
+    case TYPE_ST:
+      cost = COSTS_N_INSNS (2);
+      break;
+
+    default:
+      cost = COSTS_N_INSNS (1);
+      break;
+    }
+
+  return cost;
+#endif
+}
+
+/* Helper for arc64_short_access_p.  */
+
+static bool
+check_short_insn_register_p (rtx op, bool hclass_p)
+{
+  if (!REG_P (op))
+    return false;
+
+  return (REGNO (op) >= FIRST_PSEUDO_REGISTER
+	  || COMPACT_REG_P (REGNO (op))
+	  || (hclass_p && (REGNO (op) <= R30_REGNUM)));
+}
+
+/* Helper for arc64_short_access_p.  */
+
+static bool
+check_short_insn_constant_p (rtx op, machine_mode mode)
+{
+  HOST_WIDE_INT ival;
+
+  if (!CONST_INT_P (op))
+    return false;
+
+  ival = INTVAL (op);
+
+  /* Check u5, u6, u7 short immediates.  */
+  if (VERIFY_SHIFT (ival, ARC64LOG2 (GET_MODE_SIZE (mode)))
+      && UNSIGNED_INT5 (ival >> ARC64LOG2 (GET_MODE_SIZE (mode))))
+    return true;
+
+  return false;
+}
+
+/* Output code to add DELTA to the first argument, and then jump to
+   FUNCTION.  Used for C++ multiple inheritance.  */
+
+static void
+arc64_output_mi_thunk (FILE *file,
+		       tree thunk_fndecl,
+		       HOST_WIDE_INT delta,
+		       HOST_WIDE_INT vcall_offset,
+		       tree function)
+{
+  const char *fnname = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (thunk_fndecl));
+  rtx this_rtx, fnaddr, temp1;
+  rtx_insn *insn;
+
+  /* Pretend to be a post-reload pass while generating rtl.  */
+  reload_completed = 1;
+
+  /* Mark the end of the (empty) prologue.  */
+  emit_note (NOTE_INSN_PROLOGUE_END);
+
+  /* Determine if we can use a sibcall to call FUNCTION directly.  */
+  fnaddr = gen_rtx_MEM (FUNCTION_MODE, XEXP (DECL_RTL (function), 0));
+
+  /* We need one temporary register in some cases.  */
+  temp1 = gen_rtx_REG (Pmode, R12_REGNUM);
+
+  /* Find out which register contains the "this" pointer.  */
+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))
+    this_rtx = gen_rtx_REG (Pmode, R1_REGNUM);
+  else
+    this_rtx = gen_rtx_REG (Pmode, R0_REGNUM);
+
+  /* Add DELTA to THIS_RTX.  */
+  if (delta != 0)
+    {
+      rtx offset = GEN_INT (delta);
+      /* FIXME! check if delta fits in 32bit immediate.  Also we can
+	 switch from an ADD to a SUB instruction.  */
+      gcc_assert (UNSIGNED_INT32 (delta) || SIGNED_INT32 (delta));
+      emit_insn (gen_rtx_SET (this_rtx,
+			      gen_rtx_PLUS (Pmode, this_rtx, offset)));
+    }
+
+  if (vcall_offset != 0)
+    {
+      rtx addr;
+
+      /* Set TEMP1 to *THIS_RTX.  */
+      emit_insn (gen_rtx_SET (temp1, gen_rtx_MEM (Pmode, this_rtx)));
+
+      /* Set ADDR to a legitimate address for *THIS_RTX + VCALL_OFFSET.  */
+      /* FIXME! check if vcall_offset fits in 32bit immediate. */
+      gcc_assert (UNSIGNED_INT32 (vcall_offset) || SIGNED_INT32 (vcall_offset));
+      addr = plus_constant (Pmode, temp1, vcall_offset);
+
+      /* Load the offset and add it to THIS_RTX.  */
+      emit_insn (gen_rtx_SET (temp1, gen_rtx_MEM (Pmode, addr)));
+      emit_insn (gen_add3_insn (this_rtx, this_rtx, temp1));
+    }
+
+  /* Jump to the target function.  */
+  insn = emit_call_insn (gen_sibcall (fnaddr, const0_rtx, const0_rtx));
+  SIBLING_CALL_P (insn) = 1;
+
+  /* Run just enough of rest_of_compilation.  This sequence was
+     "borrowed" from alpha.c.  */
+  insn = get_insns ();
+  split_all_insns_noflow ();
+  shorten_branches (insn);
+  assemble_start_function (thunk_fndecl, fnname);
+  final_start_function (insn, file, 1);
+  final (insn, file, 1);
+  final_end_function ();
+  assemble_end_function (thunk_fndecl, fnname);
+
+  /* Stop pretending to be a post-reload pass.  */
+  reload_completed = 0;
+}
+
+/* Helper INIT_EXPANDERS.  */
+
+static struct machine_function *
+arc64_init_machine_status (void)
+{
+  struct machine_function *machine;
+  machine = ggc_cleared_alloc<machine_function> ();
+  return machine;
+}
+
+static tree
+arc64_builtin_decl (unsigned id, bool initialize_p ATTRIBUTE_UNUSED)
+{
+  if (id < ARC64_BUILTIN_COUNT)
+    return arc_bdesc[id].fndecl;
+
+  return error_mark_node;
+}
+
+/* Transform UP into lowercase and write the result to LO.
+   You must provide enough space for LO.  Return LO.  */
+
+static char*
+arc64_tolower (char *lo, const char *up)
+{
+  char *lo0 = lo;
+
+  for (; *up; up++, lo++)
+    *lo = TOLOWER (*up);
+
+  *lo = '\0';
+
+  return lo0;
+}
+
+/* Helper for adding the builtins.  */
+static void
+arc64_init_builtins (void)
+{
+  tree void_ftype_usint_usint
+    = build_function_type_list (void_type_node, unsigned_type_node,
+				unsigned_type_node, NULL_TREE);
+  tree usint_ftype_usint
+    = build_function_type_list  (long_unsigned_type_node,
+				 unsigned_type_node, NULL_TREE);
+  tree void_ftype_void
+    = build_function_type_list (void_type_node, NULL_TREE);
+  tree void_ftype_usint
+    = build_function_type_list (void_type_node, unsigned_type_node,
+				NULL_TREE);
+  tree long_ftype_long
+    = build_function_type_list (long_long_integer_type_node,
+				long_long_integer_type_node, NULL_TREE);
+
+  tree void_ftype_long_long
+    = build_function_type_list (void_type_node, long_long_integer_type_node,
+				long_long_integer_type_node, NULL_TREE);
+
+  /* Add the builtins.  */
+#define DEF_BUILTIN(NAME, N_ARGS, TYPE, ICODE, MASK)			\
+  {									\
+    int id = ARC64_BUILTIN_ ## NAME;					\
+    const char *Name = "__builtin_arc_" #NAME;				\
+    char *name = (char*) alloca (1 + strlen (Name));			\
+									\
+    gcc_assert (id < ARC64_BUILTIN_COUNT);				\
+    if (MASK)								\
+      arc_bdesc[id].fndecl						\
+	= add_builtin_function (arc64_tolower(name, Name), TYPE, id,	\
+				BUILT_IN_MD, NULL, NULL_TREE);		\
+  }
+#include "builtins.def"
+#undef DEF_BUILTIN
+}
+
+/* Helper arc_expand_builtin, generates a pattern for the given icode
+   and arguments.  */
+
+static rtx_insn *
+apply_GEN_FCN (enum insn_code icode, rtx *arg)
+{
+  switch (insn_data[icode].n_generator_args)
+    {
+    case 0:
+      return GEN_FCN (icode) ();
+    case 1:
+      return GEN_FCN (icode) (arg[0]);
+    case 2:
+      return GEN_FCN (icode) (arg[0], arg[1]);
+    case 3:
+      return GEN_FCN (icode) (arg[0], arg[1], arg[2]);
+    case 4:
+      return GEN_FCN (icode) (arg[0], arg[1], arg[2], arg[3]);
+    case 5:
+      return GEN_FCN (icode) (arg[0], arg[1], arg[2], arg[3], arg[4]);
+    default:
+      gcc_unreachable ();
+    }
+}
+
+/* Expand an expression EXP that calls a built-in function,
+   with result going to TARGET if that's convenient
+   (and in mode MODE if that's convenient).
+   SUBTARGET may be used as the target for computing one of EXP's operands.
+   IGNORE is nonzero if the value is to be ignored.  */
+
+static rtx
+arc64_expand_builtin (tree exp,
+		      rtx target,
+		      rtx subtarget ATTRIBUTE_UNUSED,
+		      machine_mode mode ATTRIBUTE_UNUSED,
+		      int ignore ATTRIBUTE_UNUSED)
+{
+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);
+  unsigned int id = DECL_FUNCTION_CODE (fndecl);
+  const struct arc64_builtin_description *d = &arc_bdesc[id];
+  int i, j, n_args = call_expr_nargs (exp);
+  rtx pat = NULL_RTX;
+  rtx xop[5];
+  enum insn_code icode = d->icode;
+  machine_mode tmode = insn_data[icode].operand[0].mode;
+  int nonvoid;
+  tree arg0;
+  rtx op0;
+
+  if (id >= ARC64_BUILTIN_COUNT)
+    internal_error ("bad builtin fcode");
+
+  /* 1st part: Expand special builtins.  */
+  switch (id)
+    {
+    case ARC64_BUILTIN_NOP:
+      emit_insn (gen_nopv ());
+      return NULL_RTX;
+
+    case ARC64_BUILTIN_BRK:
+      gcc_assert (icode != 0);
+      emit_insn (GEN_FCN (icode) (const1_rtx));
+      return NULL_RTX;
+
+    case ARC64_BUILTIN_TRAP_S:
+      arg0 = CALL_EXPR_ARG (exp, 0);
+      fold (arg0);
+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);
+
+      gcc_assert (icode != 0);
+      emit_insn (GEN_FCN (icode) (op0));
+      return NULL_RTX;
+    default:
+      break;
+    }
+
+  /* 2nd part: Expand regular builtins.  */
+  if (icode == 0)
+    internal_error ("bad builtin fcode");
+
+  nonvoid = TREE_TYPE (TREE_TYPE (fndecl)) != void_type_node;
+  j = 0;
+
+  if (nonvoid)
+    {
+      if (target == NULL_RTX
+	  || GET_MODE (target) != tmode
+	  || !insn_data[icode].operand[0].predicate (target, tmode))
+	{
+	  target = gen_reg_rtx (tmode);
+	}
+      xop[j++] = target;
+    }
+
+  gcc_assert (n_args <= 4);
+  for (i = 0; i < n_args; i++, j++)
+    {
+      tree arg = CALL_EXPR_ARG (exp, i);
+      machine_mode mode = insn_data[icode].operand[j].mode;
+      rtx op = expand_expr (arg, NULL_RTX, mode, EXPAND_NORMAL);
+      machine_mode opmode = GET_MODE (op);
+
+      if (CONST_INT_P (op))
+	opmode = mode;
+
+      if ((opmode == SImode) && (mode == HImode))
+	{
+	  opmode = HImode;
+	  op = gen_lowpart (HImode, op);
+	}
+
+      /* In case the insn wants input operands in modes different from
+	 the result, abort.  */
+      gcc_assert (opmode == mode || opmode == VOIDmode);
+
+      if (!insn_data[icode].operand[i + nonvoid].predicate (op, mode))
+	op = copy_to_mode_reg (mode, op);
+
+      xop[j] = op;
+    }
+
+  pat = apply_GEN_FCN (icode, xop);
+  if (pat == NULL_RTX)
+    return NULL_RTX;
+
+  emit_insn (pat);
+
+  if (nonvoid)
+    return target;
+  else
+    return const0_rtx;
+}
+
+/* A callback for the hw-doloop pass.  Called when a loop we have discovered
+   turns out not to be optimizable; we have to split the loop_end pattern into
+   a subtract and a test.  */
+
+static void
+hwloop_fail (hwloop_info loop)
+{
+  rtx test;
+  rtx insn;
+
+  emit_insn_before (gen_adddi_cmp0 (loop->iter_reg,
+				    loop->iter_reg,
+				    constm1_rtx),
+		    loop->loop_end);
+  test = gen_rtx_NE (VOIDmode, gen_rtx_REG (CC_ZNmode, CC_REGNUM), const0_rtx);
+  test = gen_rtx_IF_THEN_ELSE (VOIDmode, test,
+			       gen_rtx_LABEL_REF (Pmode, loop->start_label),
+			       pc_rtx);
+  insn = emit_jump_insn_before (gen_rtx_SET (pc_rtx, test),
+				loop->loop_end);
+
+  JUMP_LABEL (insn) = loop->start_label;
+  LABEL_NUSES (loop->start_label)++;
+  delete_insn (loop->loop_end);
+}
+
+/* Optimize LOOP.  We just are checking that the loop isn't too long,
+   returns true if so.  Return true if successful, false if the loop
+   should be marked bad.  If it returns false, the FAIL function is
+   called.  */
+
+static bool
+hwloop_optimize (hwloop_info loop)
+{
+  unsigned int length;
+
+  /* Call shorten_branches to calculate the insn lengths.  */
+  shorten_branches (get_insns());
+
+  if (!INSN_ADDRESSES_SET_P ())
+    {
+      fprintf (dump_file, ";; loop %d has an unknown length\n", loop->loop_no);
+      return false;
+    }
+
+  length = INSN_ADDRESSES (INSN_UID (loop->loop_end))
+    - INSN_ADDRESSES (INSN_UID (loop->start_label));
+  loop->length = length;
+  if (dump_file)
+    fprintf (dump_file, ";; loop %d with lenght %d\n", loop->loop_no,
+	     loop->length);
+  if (loop->length > MAX_LOOP_LENGTH
+      || loop->length < MIN_LOOP_LENGTH)
+    {
+      if (dump_file)
+	fprintf (dump_file, ";; loop %d is too long\n", loop->loop_no);
+      return false;
+    }
+  if (loop->length == 0)
+    {
+      if (dump_file)
+	fprintf (dump_file, ";; loop %d is empty\n", loop->loop_no);
+      return false;
+    }
+
+  return true;
+}
+
+/* A callback for the hw-doloop pass.  This function examines INSN; if
+   it is a loop_end pattern we recognize, return the reg rtx for the
+   loop counter.  Otherwise, return NULL_RTX.  */
+
+static rtx
+hwloop_pattern_reg (rtx_insn *insn)
+{
+  rtx reg;
+
+  if (!JUMP_P (insn) || recog_memoized (insn) != CODE_FOR_dbnz)
+    return NULL_RTX;
+
+  reg = SET_DEST (XVECEXP (PATTERN (insn), 0, 1));
+  if (!REG_P (reg))
+    return NULL_RTX;
+  return reg;
+}
+
+static struct hw_doloop_hooks arc64_doloop_hooks =
+{
+  hwloop_pattern_reg,
+  hwloop_optimize,
+  hwloop_fail
+};
+
+/* Machine specific reorg step.  */
+static void
+arc64_reorg (void)
+{
+  compute_bb_for_insn ();
+  df_analyze ();
+  reorg_loops (true, &arc64_doloop_hooks);
+}
+
+/* Expand a compare and swap pattern.  */
+
+static void
+emit_unlikely_jump (rtx insn)
+{
+  rtx_insn *jump = emit_jump_insn (insn);
+  add_reg_br_prob_note (jump, profile_probability::very_unlikely ());
+}
+
+/* Expand code to perform a 8 or 16-bit compare and swap by doing
+   32-bit compare and swap on the word containing the byte or
+   half-word.  The difference between a weak and a strong CAS is that
+   the weak version may simply fail.  The strong version relies on two
+   loops, one checks if the SCOND op is succsfully or not, the other
+   checks if the 32 bit accessed location which contains the 8 or 16
+   bit datum is not changed by other thread.  The first loop is
+   implemented by the atomic_compare_and_swapsdi_1 pattern.  The second
+   loops is implemented by this routine.  */
+
+static void
+arc_expand_compare_and_swap_qh (rtx bool_result, rtx result, rtx mem,
+				rtx oldval, rtx newval, rtx weak,
+				rtx mod_s, rtx mod_f)
+{
+  rtx addr1 = force_reg (Pmode, XEXP (mem, 0));
+  rtx addr = gen_reg_rtx (Pmode);
+  rtx off = gen_reg_rtx (SImode);
+  rtx oldv = gen_reg_rtx (SImode);
+  rtx newv = gen_reg_rtx (SImode);
+  rtx oldvalue = gen_reg_rtx (SImode);
+  rtx newvalue = gen_reg_rtx (SImode);
+  rtx res = gen_reg_rtx (SImode);
+  rtx resv = gen_reg_rtx (SImode);
+  rtx memsi, val, mask, end_label, loop_label, cc, x;
+  machine_mode mode;
+  bool is_weak = (weak != const0_rtx);
+
+  /* Truncate the address.  */
+  emit_insn (gen_rtx_SET (addr,
+			  gen_rtx_AND (Pmode, addr1, GEN_INT (-4))));
+
+  /* Compute the datum offset.  */
+
+  emit_insn (gen_rtx_SET (off, gen_rtx_AND (SImode,
+					    gen_lowpart(SImode, addr1),
+					    GEN_INT (3))));
+
+  /* Normal read from truncated address.  */
+  memsi = gen_rtx_MEM (SImode, addr);
+  set_mem_alias_set (memsi, ALIAS_SET_MEMORY_BARRIER);
+  MEM_VOLATILE_P (memsi) = MEM_VOLATILE_P (mem);
+
+  val = copy_to_reg (memsi);
+
+  /* Convert the offset in bits.  */
+  emit_insn (gen_rtx_SET (off,
+			  gen_rtx_ASHIFT (SImode, off, GEN_INT (3))));
+
+  /* Get the proper mask.  */
+  if (GET_MODE (mem) == QImode)
+    mask = force_reg (SImode, GEN_INT (0xff));
+  else
+    mask = force_reg (SImode, GEN_INT (0xffff));
+
+  emit_insn (gen_rtx_SET (mask,
+			  gen_rtx_ASHIFT (SImode, mask, off)));
+
+  /* Prepare the old and new values.  */
+  emit_insn (gen_rtx_SET (val,
+			  gen_rtx_AND (SImode, gen_rtx_NOT (SImode, mask),
+				       val)));
+
+  oldval = gen_lowpart (SImode, oldval);
+  emit_insn (gen_rtx_SET (oldv,
+			  gen_rtx_ASHIFT (SImode, oldval, off)));
+
+  newval = gen_lowpart_common (SImode, newval);
+  emit_insn (gen_rtx_SET (newv,
+			  gen_rtx_ASHIFT (SImode, newval, off)));
+
+  emit_insn (gen_rtx_SET (oldv,
+			  gen_rtx_AND (SImode, oldv, mask)));
+
+  emit_insn (gen_rtx_SET (newv,
+			  gen_rtx_AND (SImode, newv, mask)));
+
+  if (!is_weak)
+    {
+      end_label = gen_label_rtx ();
+      loop_label = gen_label_rtx ();
+      emit_label (loop_label);
+    }
+
+  /* Make the old and new values.  */
+  emit_insn (gen_rtx_SET (oldvalue,
+			  gen_rtx_IOR (SImode, oldv, val)));
+
+  emit_insn (gen_rtx_SET (newvalue,
+			  gen_rtx_IOR (SImode, newv, val)));
+
+  /* Try an 32bit atomic compare and swap.  It clobbers the CC
+     register.  */
+  if (GET_MODE (mem) == SImode)
+    emit_insn (gen_atomic_compare_and_swapsi_1 (res, memsi, oldvalue, newvalue,
+						weak, mod_s, mod_f));
+  else /* DImode */
+    emit_insn (gen_atomic_compare_and_swapdi_1 (res, memsi, oldvalue, newvalue,
+						weak, mod_s, mod_f));
+
+  /* Regardless of the weakness of the operation, a proper boolean
+     result needs to be provided.  */
+  x = gen_rtx_REG (CC_Zmode, CC_REGNUM);
+  x = gen_rtx_EQ (SImode, x, const0_rtx);
+  emit_insn (gen_rtx_SET (bool_result, x));
+
+  if (!is_weak)
+    {
+      /* Check the results: if the atomic op is successfully the goto
+	 to end label.  */
+      x = gen_rtx_REG (CC_Zmode, CC_REGNUM);
+      x = gen_rtx_EQ (VOIDmode, x, const0_rtx);
+      x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,
+				gen_rtx_LABEL_REF (Pmode, end_label), pc_rtx);
+      emit_jump_insn (gen_rtx_SET (pc_rtx, x));
+
+      /* Wait for the right moment when the accessed 32-bit location
+	 is stable.  */
+      emit_insn (gen_rtx_SET (resv,
+			      gen_rtx_AND (SImode, gen_rtx_NOT (SImode, mask),
+					   res)));
+      mode = SELECT_CC_MODE (NE, resv, val);
+      cc = gen_rtx_REG (mode, CC_REGNUM);
+      emit_insn (gen_rtx_SET (cc, gen_rtx_COMPARE (mode, resv, val)));
+
+      /* Set the new value of the 32 bit location, proper masked.  */
+      emit_insn (gen_rtx_SET (val, resv));
+
+      /* Try again if location is unstable.  Fall through if only
+	 scond op failed.  */
+      x = gen_rtx_NE (VOIDmode, cc, const0_rtx);
+      x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,
+				gen_rtx_LABEL_REF (Pmode, loop_label), pc_rtx);
+      emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));
+
+      emit_label (end_label);
+    }
+
+  /* End: proper return the result for the given mode.  */
+  emit_insn (gen_rtx_SET (res,
+			  gen_rtx_AND (SImode, res, mask)));
+
+  emit_insn (gen_rtx_SET (res,
+			  gen_rtx_LSHIFTRT (SImode, res, off)));
+
+  emit_move_insn (result, gen_lowpart (GET_MODE (result), res));
+}
+
+/* On some RISC architectures with 64-bit registers, the processor
+   also maintains 32-bit condition codes that make it possible to do
+   real 32-bit arithmetic, although the operations are performed on
+   the full registers.  This hook needs to be define if
+   WORD_REGISTER_OPERATIONS is not defined to 1.  */
+
+static unsigned int
+arc64_min_arithmeric_precision (void)
+{
+  return 32;
+}
+
+/* This hook may conditionally modify five variables: fixed_regs,
+   call_used_regs, global_regs, reg_names and reg_class_contents.  */
+
+static void
+arc64_conditional_register_usage (void)
+{
+  int regno;
+
+  if (ARC64_HAS_FP_BASE)
+    {
+      for (regno = F0_REGNUM; regno <= F31_REGNUM; regno++)
+	{
+	  fixed_regs[regno] = 0;
+	  call_used_regs[regno] = (regno < (F0_REGNUM + 14)) ? 1 : 0;
+	}
+    }
+}
+
+/* Implement TARGET_LIBGCC_FLOATING_POINT_MODE_SUPPORTED_P - return TRUE
+   if MODE is HFmode, and punt to the generic implementation otherwise.  */
+
+static bool
+arc64_libgcc_floating_mode_supported_p (scalar_float_mode mode)
+{
+  return (mode == HFmode
+	  ? ARC64_HAS_FPUH
+	  : default_libgcc_floating_mode_supported_p (mode));
+}
+
+/* Implement TARGET_SCALAR_MODE_SUPPORTED_P - return TRUE
+   if MODE is HFmode, and punt to the generic implementation otherwise.  */
+
+static bool
+arc64_scalar_mode_supported_p (scalar_mode mode)
+{
+  return (mode == HFmode
+	  ? ARC64_HAS_FPUH
+	  : default_scalar_mode_supported_p (mode));
+}
+
+/* Implements target hook vector_mode_supported_p.  */
+
+static bool
+arc64_vector_mode_supported_p (machine_mode mode)
+{
+  switch (mode)
+    {
+      /* 32-bit fp SIMD vectors.  */
+    case E_V2HFmode:
+      return ARC64_VFP_32;
+      /* 64-bit fp SIMD vectors.  */
+    case E_V4HFmode:
+    case E_V2SFmode:
+      return ARC64_VFP_64;
+      /* 128-bit fp SIMD vectors.  */
+    case E_V8HFmode:
+    case E_V4SFmode:
+    case E_V2DFmode:
+      return ARC64_VFP_128;
+
+      /* 32-bit SIMD vectors.  */
+    case E_V2HImode:
+      /* 64-bit SIMD vectors.  */
+    case E_V4HImode:
+    case E_V2SImode:
+      return TARGET_SIMD;
+
+    default:
+      return false;
+    }
+}
+
+/* Implements target hook TARGET_VECTORIZE_PREFERRED_SIMD_MODE.  */
+
+static machine_mode
+arc64_preferred_simd_mode (scalar_mode mode)
+{
+  switch (mode)
+    {
+    case E_HFmode:
+      if (ARC64_VFP_128)
+	return V8HFmode;
+      if (ARC64_VFP_64)
+	return V4HFmode;
+      if (ARC64_VFP_32)
+	return V2HFmode;
+      return word_mode;
+
+    case E_SFmode:
+      if (ARC64_VFP_128)
+	return V4SFmode;
+      if (ARC64_VFP_64)
+	return V2SFmode;
+      return word_mode;
+
+    case E_DFmode:
+      if (ARC64_VFP_128)
+	return V2DFmode;
+      return word_mode;
+
+    case E_HImode:
+      return TARGET_SIMD ? V4HImode : word_mode;
+    case E_SImode:
+      return TARGET_SIMD ? V2SImode : word_mode;
+
+    default:
+      return word_mode;
+    }
+}
+
+/* Implements target hook
+   TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES.  */
+
+static unsigned int
+arc64_autovectorize_vector_modes (vector_modes *modes, bool)
+{
+  if (ARC64_VFP_128)
+    {
+      modes->quick_push (V8HFmode);
+      modes->quick_push (V4SFmode);
+      modes->quick_push (V2DFmode);
+    }
+  else if (ARC64_VFP_64)
+    {
+      modes->quick_push (V4HFmode);
+      modes->quick_push (V2SFmode);
+    }
+  else if (ARC64_VFP_32)
+    modes->quick_push (V2HFmode);
+
+  if (TARGET_SIMD)
+    {
+      modes->quick_push (V4HImode);
+      modes->quick_push (V2SImode);
+    }
+  return 0;
+}
+
+/* Vectorization costs.  */
+static int
+arc64_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,
+				  tree vectype,
+				  int misalign ATTRIBUTE_UNUSED)
+{
+  unsigned elements;
+
+  switch (type_of_cost)
+    {
+    case scalar_stmt:
+      return 1;
+
+    case scalar_load:
+      return 1;
+
+    case scalar_store:
+      return 1;
+
+    case vector_stmt:
+      return 1; /* fp operations are more efficient than int.  */
+
+    case vector_load:
+      return 1;
+
+    case vector_store:
+      return 1;
+
+    case vec_to_scalar:
+      return 1; /* We have extract instructions.  */
+
+    case scalar_to_vec:
+      return 1; /* fp is more efficient than int.  */
+
+    case unaligned_load:
+    case vector_gather_load:
+      return 1; /* Maybe I need to reflect unaligned flag here.  */
+
+    case unaligned_store:
+    case vector_scatter_store:
+      return 1; /* Likewise.  */
+
+    case cond_branch_taken:
+      return 3; /* A jump is always expensive.  */
+
+    case cond_branch_not_taken:
+      return 1;
+
+    case vec_perm:
+      return 3; /* We don't really have vec_perm.  */
+
+    case vec_promote_demote:
+      return 1;
+
+    case vec_construct:
+      elements = estimated_poly_value (TYPE_VECTOR_SUBPARTS (vectype));
+      return elements / 2;
+
+    default:
+      gcc_unreachable ();
+    }
+}
+
+/* Return a new RTX holding the result of moving POINTER forward by
+   AMOUNT bytes.  */
+
+static rtx
+arc64_move_pointer (rtx pointer, poly_int64 amount)
+{
+  rtx next = plus_constant (Pmode, XEXP (pointer, 0), amount);
+
+  return adjust_automodify_address (pointer, GET_MODE (pointer),
+				    next, amount);
+}
+
+/* Moving f regs to r regs is not a very good idea. */
+static int
+arc64_register_move_cost (machine_mode,
+			  reg_class_t from_class, reg_class_t to_class)
+{
+  if ((from_class == FP_REGS && to_class == GENERAL_REGS)
+      || (to_class == FP_REGS && from_class == GENERAL_REGS))
+    return 200;
+  return 2;
+}
+
+/* Check/emit vector duplicate instructions.  */
+
+static bool
+arc64_simd_dup (struct e_vec_perm_d *d)
+{
+  machine_mode vmode = d->vmode;
+  HOST_WIDE_INT elt;
+  rtx t0, parallel, select;
+  rtx in0 = d->op0;
+  rtx out = d->target;
+
+  if (!d->one_vector_p)
+    return false;
+
+  if (d->perm.encoding ().encoded_nelts () != 1
+      || !d->perm[0].is_constant (&elt))
+    return false;
+  /* elt is zero, then the vec_dup pattern does as good as we do
+     here.  */
+  if (elt == 0)
+    return false;
+
+  if (d->testing_p)
+    return true;
+
+  switch (vmode)
+    {
+    case E_V8HFmode:
+    case E_V4HFmode:
+    case E_V2HFmode:
+    case E_V2SFmode:
+    case E_V4SFmode:
+      if (elt != 0)
+	{
+	  t0 = gen_reg_rtx (GET_MODE_INNER (vmode));
+	  parallel = gen_rtx_PARALLEL (vmode, gen_rtvec (1, GEN_INT (elt)));
+	  select = gen_rtx_VEC_SELECT (GET_MODE_INNER (vmode), in0, parallel);
+	  emit_set_insn (t0, select);
+	  emit_set_insn (out, gen_rtx_VEC_DUPLICATE (vmode, t0));
+	  return true;
+	}
+
+      /* FALLTHRU */
+    case E_V2DFmode:
+    case E_V2SImode:
+      parallel = gen_rtx_PARALLEL (vmode, gen_rtvec (1, GEN_INT (elt)));
+      select = gen_rtx_VEC_SELECT (GET_MODE_INNER (vmode), in0, parallel);
+      emit_set_insn (out, gen_rtx_VEC_DUPLICATE (vmode, select));
+      return true;
+
+    case E_V4HImode:
+      if (elt == 0)
+	{
+	  t0 = gen_reg_rtx (vmode);
+	  emit_insn (gen_arc64_sel_lane2_0v4hi (t0, in0, in0));
+	  emit_insn (gen_arc64_sel_lane2_0v4hi (out, t0, t0));
+	  return true;
+	}
+      else if (elt == 1)
+	{
+	  t0 = gen_reg_rtx (vmode);
+	  emit_insn (gen_arc64_sel_lane3_1v4hi (t0, in0, in0));
+	  emit_insn (gen_arc64_sel_lane2_0v4hi (out, t0, t0));
+	  return true;
+	}
+      else if (elt == 2)
+	{
+	  t0 = gen_reg_rtx (vmode);
+	  emit_insn (gen_arc64_sel_lane2_0v4hi (t0, in0, in0));
+	  emit_insn (gen_arc64_sel_lane3_1v4hi (out, t0, t0));
+	  return true;
+	}
+      else if (elt == 3)
+	{
+	  t0 = gen_reg_rtx (vmode);
+	  emit_insn (gen_arc64_sel_lane3_1v4hi (t0, in0, in0));
+	  emit_insn (gen_arc64_sel_lane3_1v4hi (out, t0, t0));
+	  return true;
+	}
+      break;
+    default:
+      gcc_unreachable ();
+    }
+  gcc_unreachable ();
+}
+
+/* Recognize VPACK instructions.  */
+
+static bool
+arc64_simd_vpack (struct e_vec_perm_d *d)
+{
+  HOST_WIDE_INT odd;
+  poly_uint64 nelt = d->perm.length ();
+  rtx out, in0, in1;
+  machine_mode vmode = d->vmode;
+
+  if (GET_MODE_UNIT_SIZE (vmode) > 4
+      || FLOAT_MODE_P (vmode))
+    return false;
+
+  if (!d->perm[0].is_constant (&odd)
+      || (odd != 0 && odd != 1)
+      || !d->perm.series_p (0, 1, odd, 2)
+      || !d->perm.series_p (2, 1, nelt + odd, 2))
+    return false;
+
+  /* Success!  */
+  if (d->testing_p)
+    return true;
+
+  in0 = d->op0;
+  in1 = d->op1;
+  out = d->target;
+  switch (vmode)
+    {
+    case E_V4HImode:
+      if (odd)
+	emit_insn (gen_arc64_sel_lane3_1v4hi (out, in0, in1));
+      else
+	emit_insn (gen_arc64_sel_lane2_0v4hi (out, in0, in1));
+      break;
+
+    case E_V2SImode:
+      if (odd)
+	emit_insn (gen_arc64_sel_lane1_v2si (out, in0, in1));
+      else
+	emit_insn (gen_arc64_sel_lane0_v2si (out, in0, in1));
+      break;
+
+    default:
+      gcc_unreachable ();
+    }
+  return true;
+}
+
+/* Reverse vector, recognize swapl instruction.  */
+
+static bool
+arc64_simd_swapl (struct e_vec_perm_d *d)
+{
+  poly_uint64 nelt = d->perm.length ();
+  machine_mode vmode = d->vmode;
+  rtx t0, t1, t2, out, in0;
+
+  if (GET_MODE_UNIT_SIZE (vmode) > 4
+      || FLOAT_MODE_P (vmode))
+    return false;
+
+  if (!d->one_vector_p)
+    return false;
+
+  if (!d->perm.series_p (0, 1, nelt - 1, -1))
+    return false;
+
+  /* Success! */
+  if (d->testing_p)
+    return true;
+
+  in0 = d->op0;
+  out = d->target;
+
+  switch (vmode)
+    {
+    case E_V4HImode:
+      t0 = gen_reg_rtx (vmode);
+      t1 = gen_reg_rtx (vmode);
+      t2 = gen_reg_rtx (vmode);
+      emit_insn (gen_arc64_swapl (t0, in0));
+      emit_insn (gen_arc64_swapv4hi (t1, in0));
+      emit_insn (gen_arc64_swapv4hi (t2, t0));
+      emit_insn (gen_arc64_swp_lane0_v4hi (out, t2, t1));
+      break;
+
+    case E_V2SImode:
+      emit_insn (gen_arc64_swaplv2si (out, in0));
+      break;
+
+    default:
+      gcc_unreachable ();
+    }
+  return true;
+}
+
+/* Detect cases when we can use swap instruction.  */
+
+static bool
+arc64_simd_swap (struct e_vec_perm_d *d)
+{
+  rtx t0, t1, t2, out, in0;
+  machine_mode vmode = d->vmode;
+
+  if (vmode != E_V4HImode)
+    return false;
+
+  if (!d->one_vector_p)
+    return false;
+
+  if (!d->perm.series_p (0, 2, 1, 2)
+      || !d->perm.series_p (1, 2, 0, 2))
+    return false;
+
+  /* Success! */
+  if (d->testing_p)
+    return true;
+
+  in0 = d->op0;
+  out = d->target;
+
+  t0 = gen_reg_rtx (vmode);
+  t1 = gen_reg_rtx (vmode);
+  t2 = gen_reg_rtx (vmode);
+  emit_insn (gen_arc64_swapl (t0, in0));
+  emit_insn (gen_arc64_swapv4hi (t1, in0));
+  emit_insn (gen_arc64_swapv4hi (t2, t0));
+  emit_insn (gen_arc64_swp_lane0_v4hi (out, t1, t2));
+  return true;
+}
+
+/* Detect cases when we can use vapck2wl for 4xVectors.  */
+
+static bool
+arc64_simd_vpack2wl (struct e_vec_perm_d *d)
+{
+  machine_mode vmode = d->vmode;
+
+  if (vmode != E_V4HImode)
+    return false;
+
+  if (d->perm[0] != 0
+      || d->perm[1] != 1
+      || (d->perm[2] != 4 && d->perm[2] != 0)
+      || (d->perm[3] != 5 && d->perm[3] != 1))
+    return false;
+
+  /* Success! */
+  if (d->testing_p)
+    return true;
+
+  emit_insn (gen_arc64_swp_lane0_v4hi (d->target, d->op0, d->op1));
+  return true;
+}
+
+static bool
+arc64_simd_vpack2wm (struct e_vec_perm_d *d)
+{
+  machine_mode vmode = d->vmode;
+
+  if (vmode != E_V4HImode)
+    return false;
+
+  if (d->perm[0] != 2
+      || d->perm[1] != 3
+      || (d->perm[2] != 6 && d->perm[2] != 2)
+      || (d->perm[3] != 7 && d->perm[3] != 3))
+    return false;
+
+  /* Success! */
+  if (d->testing_p)
+    return true;
+
+  emit_insn (gen_arc64_swp_lane1_v4hi (d->target, d->op0, d->op1));
+  return true;
+}
+
+/* Implement TARGET_VECTORIZE_VEC_PERM_CONST.  */
+
+static bool
+arc64_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,
+				rtx op1, const vec_perm_indices &sel)
+{
+  struct e_vec_perm_d d;
+
+  /* Check whether the mask can be applied to a single vector.  */
+  if (sel.ninputs () == 1
+      || (op0 && rtx_equal_p (op0, op1)))
+    d.one_vector_p = true;
+  else if (sel.all_from_input_p (0))
+    {
+      d.one_vector_p = true;
+      op1 = op0;
+    }
+  else if (sel.all_from_input_p (1))
+    {
+      d.one_vector_p = true;
+      op0 = op1;
+    }
+  else
+    d.one_vector_p = false;
+
+  d.perm.new_vector (sel.encoding (), d.one_vector_p ? 1 : 2,
+		     sel.nelts_per_input ());
+  d.vmode = vmode;
+  d.target = target;
+  d.op0 = op0;
+  d.op1 = op1;
+  d.testing_p = !target;
+
+  /* The pattern matching functions above are written to look for a small
+     number to begin the sequence (0, 1, N/2).  If we begin with an index
+     from the second operand, we can swap the operands.  */
+  poly_int64 nelt = d.perm.length ();
+  if (known_ge (d.perm[0], nelt))
+    {
+      d.perm.rotate_inputs (1);
+      std::swap (d.op0, d.op1);
+    }
+  if (known_gt (nelt, 1))
+    {
+      if (arc64_simd_dup (&d))
+	return true;
+      else if (arc64_simd_vpack (&d))
+	return true;
+      else if (arc64_simd_swapl (&d))
+	return true;
+      else if (arc64_simd_swap (&d))
+	return true;
+      else if (arc64_simd_vpack2wl (&d))
+	return true;
+      else if (arc64_simd_vpack2wm (&d))
+	return true;
+    }
+  return false;
+}
+
+/* Provide the costs of an addressing mode that contains ADDR.
+   LOAD_P is true when address is used to load a value.  */
+
+static int
+arc64_address_cost (rtx addr, machine_mode mode,
+		    addr_space_t as  ATTRIBUTE_UNUSED,
+		    bool speed)
+{
+  const int cost_limm = speed ? 0 : COSTS_N_INSNS (1);
+
+  if (CONSTANT_P (addr))
+    return cost_limm;
+
+  /* The cheapest construct are the addresses which fit a store
+     instruction (or a fp load/store instruction).  */
+  if (arc64_legitimate_address_1_p (mode, addr, true, false, true))
+    return 0;
+
+  /* Anything else has a limm.  */
+  return cost_limm + 1;
+}
+
+/* Compute the rtx cost.  */
+
+static bool
+arc64_rtx_costs (rtx x, machine_mode mode, rtx_code outer,
+                int opno ATTRIBUTE_UNUSED, int *cost, bool speed)
+{
+  rtx op0, op1;
+  const int cost_limm = speed ? 0 : COSTS_N_INSNS (1);
+
+  /* Everything cost 1, unless specified.  */
+  *cost = COSTS_N_INSNS (1);
+
+  switch (GET_CODE (x))
+    {
+    case SET:
+      op0 = SET_DEST (x);
+      op1 = SET_SRC (x);
+
+      switch (GET_CODE (op0))
+	{
+	case MEM:
+	  /* Store instruction.  */
+	  *cost += arc64_address_cost (XEXP (op0, 0), mode, 0, speed);
+	  if (CONST_INT_P (op1))
+	    {
+	      *cost += speed ? 0 :
+		satisfies_constraint_S06S0 (op1) ? 0 : cost_limm;
+	      return true;
+	    }
+
+	  *cost += rtx_cost (op1, mode, SET, 1, speed);
+	  return true;
+
+	case SUBREG:
+	  if (!REG_P (SUBREG_REG (op0)))
+	    *cost += rtx_cost (SUBREG_REG (op0), VOIDmode, SET, 0, speed);
+
+	  /* Fall through.  */
+	case REG:
+	  /* Cost is just the cost of the RHS of the set.  */
+	  *cost += rtx_cost (op1, mode, SET, 1, speed);
+	  return true;
+
+	default:
+	  break;
+	}
+      return false;
+
+    case MEM:
+      /* Generic/loads.  */
+      *cost += arc64_address_cost (XEXP (x, 0), mode, 0, speed);
+      return true;
+
+    case MINUS:
+    case PLUS:
+      op0 = XEXP (x, 0);
+      op1 = XEXP (x, 1);
+
+      /* Check if we have add{1,2,3} instruction.  */
+      if ((GET_CODE (op0) == ASHIFT
+	   && _1_2_3_operand (XEXP (op0, 1), VOIDmode))
+	  || (GET_CODE (op0) == MULT
+	      && _2_4_8_operand (XEXP (op0, 1), VOIDmode)))
+	{
+	  /* Check if 2nd instruction operand is constant int.  This
+	     always goes as limm.  */
+	  if (CONST_INT_P (op1))
+	    *cost += cost_limm ;
+	}
+      return true;
+      break;
+
+    case COMPARE:
+      op0 = XEXP (x, 0);
+      op1 = XEXP (x, 1);
+
+      /* Vitually, any instruction can do compare with zero.  */
+      if (op1 == const0_rtx)
+	*cost = 0;
+      return true;
+
+    case ZERO_EXTEND:
+      op0 = XEXP (x, 0);
+
+      /* Zero extending from an SI operation is cheap.  */
+      if (mode == DImode
+	  && GET_MODE (op0) == SImode
+	  && outer == SET)
+	{
+	  int op_cost = rtx_cost (op0, VOIDmode, ZERO_EXTEND, 0, speed);
+	  if (op_cost)
+	    *cost = op_cost;
+	  return true;
+	}
+      else if (MEM_P (op0))
+	{
+	  /* All loads can zero extend to any size for free.  */
+	  *cost = rtx_cost (op0, VOIDmode, ZERO_EXTEND, 0, speed);
+	  return true;
+	}
+      break;
+
+    case SIGN_EXTEND:
+      op0 = XEXP (x, 0);
+      if (MEM_P (op0))
+	{
+	  /* All loads can sign extend to any size for free.  */
+	  *cost = rtx_cost (op0, VOIDmode, SIGN_EXTEND, 0, speed);
+	  return true;
+	}
+      break;
+
+    case CONST_INT:
+      {
+	bool limm_p = true;
+	HOST_WIDE_INT imm = INTVAL (x);
+
+	/* In general any 32bit constant can be loaded immediately,
+	   however, when we compile for speed, we try to avoid
+	   them.  */
+	if (UNSIGNED_INT6 (imm))
+	  limm_p = false;
+	else
+	  switch (outer)
+	    {
+	    case SET:
+	      if (SIGNED_INT12 (imm))
+		limm_p = false;
+	      break;
+
+	    default:
+	      break;
+	    }
+
+	*cost = limm_p ? cost_limm : 0;
+	return true;
+      }
+
+    case ASHIFT:
+    case ASHIFTRT:
+    case LSHIFTRT:
+    case DIV:
+    case UDIV:
+    case MULT:
+      return true;
+
+    default:
+      break;
+    }
+  return false;
+}
+
+/* Wrapper around arc64_rtx_costs, dumps the partial, or total cost
+   calculated for X.  This cost is stored in *COST.  Returns true
+   if the total cost of X was calculated.  */
+static bool
+arc64_rtx_costs_wrapper (rtx x, machine_mode mode, int outer,
+			 int param, int *cost, bool speed)
+{
+  bool result = arc64_rtx_costs (x, mode, (rtx_code) outer, param, cost, speed);
+
+  if (dump_file)
+    {
+      print_rtl_single (dump_file, x);
+      fprintf (dump_file, "\nARC: %s cost: %d (%s)\n",
+	       speed ? "Speed" : "Size",
+	       *cost, result ? "final" : "partial");
+    }
+
+  return result;
+}
+
+/*
+  Global functions.
+*/
+
+/* Returns TRUE if CALLEE should be treated as long-calls (i.e. called
+   via a register).  */
+
+bool
+arc64_is_long_call_p (rtx sym)
+{
+  const_tree decl;
+
+  if (!SYMBOL_REF_P (sym))
+    return false;
+
+  /* If my memory model is small everything can go via usual bl/jl
+     instructions.  */
+  if (arc64_cmodel_var == ARC64_CMODEL_SMALL)
+    return false;
+
+  decl = SYMBOL_REF_DECL (sym);
+  if (flag_pic
+      && decl
+      && !targetm.binds_local_p (decl))
+    return true;
+
+  /* If the symbol binds local then it is a short call.  */
+  if (decl && targetm.binds_local_p (decl))
+    return false;
+
+  /* If the model is large then make it a long one.  */
+  if (arc64_cmodel_var == ARC64_CMODEL_LARGE)
+    return !SYMBOL_REF_LOCAL_P (sym);
+  return false;
+}
+
+/* X and Y are two things to compare using CODE.  Emit the compare insn and
+   return the rtx for the cc reg in the proper mode.  */
+
+rtx
+arc64_gen_compare_reg (enum rtx_code code, rtx x, rtx y)
+{
+  machine_mode mode = SELECT_CC_MODE (code, x, y);
+  rtx cc_reg = gen_rtx_REG (mode, CC_REGNUM);
+
+  emit_set_insn (cc_reg, gen_rtx_COMPARE (mode, x, y));
+  return cc_reg;
+}
+
+/* Prepare operands for move in MODE.  Return true iff the move has
+   been emitted.  */
+
+bool
+arc64_prepare_move_operands (rtx op0, rtx op1, machine_mode mode)
+{
+  if (MEM_P (op0) && !REG_P (op1))
+    {
+      if (mode == E_DImode
+	  || !satisfies_constraint_S06S0 (op1))
+	op1 = force_reg (mode, op1);
+    }
+  else if (GET_MODE_SIZE (mode) == UNITS_PER_WORD
+	   && CONSTANT_P (op1))
+    {
+      unsigned HOST_WIDE_INT lo;
+      unsigned HOST_WIDE_INT hi;
+      rtx tmp;
+
+      switch (GET_CODE (op1))
+	{
+	case CONST_INT:
+	  gcc_assert (mode == DImode);
+	  if (!SIGNED_INT32 (INTVAL (op1)) && !UNSIGNED_INT32 (INTVAL (op1)))
+	    {
+	      HOST_WIDE_INT val;
+	      /* We have a large 64bit immediate:
+		 movhl rA, (val64 >> 32)
+		 orl   rA,rA, (val64 & 0xffffffff)
+		 FIXME! add strategies to minimize the size.  */
+
+	      val = INTVAL (op1);
+	      lo = zext_hwi (val, 32);
+	      hi = zext_hwi (val >> 32, 32);
+	      tmp = op0;
+
+	      if (can_create_pseudo_p ())
+		tmp = gen_reg_rtx (mode);
+
+	      /* Maybe do first a move cnst to movsi to get the
+		 constants minimized.  */
+	      emit_insn (gen_rtx_SET (tmp,
+				      gen_rtx_ASHIFT (mode, GEN_INT (hi),
+						      GEN_INT (32))));
+	      emit_insn (gen_rtx_SET (op0,
+				      gen_rtx_LO_SUM (mode, tmp,
+						      GEN_INT (lo))));
+	      return true;
+	    }
+	  break;
+
+	case CONST_WIDE_INT:
+	  gcc_unreachable ();
+
+	case CONST_DOUBLE:
+	  {
+	    long res[2];
+	    unsigned HOST_WIDE_INT ival;
+	    scalar_int_mode imode = int_mode_for_mode (mode).require ();
+
+	    gcc_assert (mode == DFmode);
+
+	    real_to_target (res, CONST_DOUBLE_REAL_VALUE (op1),
+			    REAL_MODE_FORMAT (mode));
+	    lo = zext_hwi (res[0], 32);
+	    hi = zext_hwi (res[1], 32);
+
+	    ival = lo | (hi << 32);
+	    tmp = gen_reg_rtx (imode);
+	    emit_move_insn (tmp, gen_int_mode (ival, imode));
+	    emit_move_insn (op0, gen_lowpart (mode, tmp));
+	    return true;
+	  }
+
+	case CONST:
+	case SYMBOL_REF:
+	case LABEL_REF:
+	  op1 = arc64_legitimize_address_1 (op1, op0);
+	  break;
+
+	default:
+	  break;
+	}
+    }
+
+  /* Check and fix unsupported store addresses.  */
+  if (MEM_P (op0)
+      && !arc64_legitimate_address_1_p (mode, XEXP (op0, 0), false,
+					false, true))
+    {
+      rtx tmp = gen_reg_rtx (Pmode);
+      rtx addr = XEXP (op0, 0);
+      rtx t0 = XEXP (addr, 0);
+      rtx t1 = XEXP (addr, 1);
+
+      if (GET_CODE (t0) == MULT)
+	{
+	  rtx ta = XEXP (t0, 0);
+	  rtx tb = XEXP (t0, 1);
+	  t0 = gen_rtx_ASHIFT (Pmode, ta,
+			       GEN_INT (ARC64LOG2 (INTVAL (tb))));
+	}
+
+      emit_insn (gen_rtx_SET (tmp, gen_rtx_PLUS (Pmode, t0, t1)));
+      op0 = replace_equiv_address (op0, tmp);
+    }
+  emit_insn (gen_rtx_SET (op0, op1));
+  return true;
+}
+
+/* Split a mov with long immediate instruction into smaller, size
+   friendly instructions.  */
+#if 0
+bool
+arc64_split_mov_const (rtx *operands)
+{
+  unsigned HOST_WIDE_INT ival;
+  HOST_WIDE_INT shimm;
+  machine_mode mode = GET_MODE (operands[0]);
+
+  /* Manage a constant.  */
+  gcc_assert (CONST_INT_P (operands[1]));
+  ival = INTVAL (operands[1]) & 0xffffffff;
+
+  if (SIGNED_INT12 (ival))
+    return false;
+
+  /* 1. Check if we can just rotate limm by 8 but using ROR8.  */
+  if (TARGET_BARREL_SHIFTER && ((ival & ~0x3f000000) == 0))
+    {
+      shimm = (ival >> 24) & 0x3f;
+      emit_insn (gen_rtx_SET (operands[0],
+			      gen_rtx_ROTATERT (mode, GEN_INT (shimm),
+						GEN_INT (8))));
+      return true;
+    }
+  /* 2. Check if we can just shift by 8 to fit into the u6 of LSL8.  */
+  if (TARGET_BARREL_SHIFTER && ((ival & ~0x3f00) == 0))
+    {
+      shimm = (ival >> 8) & 0x3f;
+      emit_insn (gen_rtx_SET (operands[0],
+			      gen_rtx_ASHIFT (mode, GEN_INT (shimm),
+					      GEN_INT (8))));
+      return true;
+    }
+
+  /* 3. Check if we can just shift by 16 to fit into the u6 of LSL16.  */
+  if (TARGET_BARREL_SHIFTER && ((ival & ~0x3f0000) == 0))
+    {
+      shimm = (ival >> 16) & 0x3f;
+      emit_insn (gen_rtx_SET (operands[0],
+			      gen_rtx_ASHIFT (mode, GEN_INT (shimm),
+					      GEN_INT (16))));
+      return true;
+    }
+
+  /* 4. Check if we can do something like mov_s h,u8 / asl_s ra,h,#nb.  */
+  if (((ival >> (__builtin_ffs (ival) - 1)) & 0xffffff00) == 0
+      && TARGET_BARREL_SHIFTER)
+    {
+      HOST_WIDE_INT shift = __builtin_ffs (ival);
+      shimm = (ival >> (shift - 1)) & 0xff;
+      emit_insn (gen_rtx_SET (operands[0], GEN_INT (shimm)));
+      emit_insn (gen_rtx_SET (operands[0],
+			      gen_rtx_ASHIFT (mode, operands[0],
+					      GEN_INT (shift - 1))));
+      return true;
+    }
+
+  /* 5. Check if we can just rotate the limm, useful when no barrel
+     shifter is present.  */
+  if ((ival & ~0x8000001f) == 0)
+    {
+      shimm = (ival * 2 + 1) & 0x3f;
+      emit_insn (gen_rtx_SET (operands[0],
+			      gen_rtx_ROTATERT (mode, GEN_INT (shimm),
+						const1_rtx)));
+      return true;
+    }
+
+  /* 6. Check if we can do something with bmask.  */
+  if (IS_POWEROF2_P (ival + 1))
+    {
+      emit_insn (gen_rtx_SET (operands[0], constm1_rtx));
+      emit_insn (gen_rtx_SET (operands[0],
+			      gen_rtx_AND (mode, operands[0],
+					   GEN_INT (ival))));
+      return true;
+    }
+
+  return false;
+}
+
+/* Helper to check Cax constraint.  */
+
+bool
+arc64_check_mov_const (HOST_WIDE_INT ival)
+{
+  ival = ival & 0xffffffff;
+
+  if ((ival & ~0x8000001f) == 0)
+    return true;
+
+  if (IS_POWEROF2_P (ival + 1))
+    return true;
+
+  /* The next rules requires a barrel shifter.  */
+  if (!TARGET_BARREL_SHIFTER)
+    return false;
+
+  if (((ival >> (__builtin_ffs (ival) - 1)) & 0xffffff00) == 0)
+    return true;
+
+  if ((ival & ~0x3f00) == 0)
+    return true;
+
+  if ((ival & ~0x3f0000) == 0)
+    return true;
+
+  if ((ival & ~0x3f000000) == 0)
+    return true;
+
+  return false;
+}
+#endif
+
+/* This function is used by the call expanders of the machine description.
+   RESULT is the register in which the result is returned.  It's NULL for
+   "call" and "sibcall".
+   MEM is the location of the function call.
+   SIBCALL indicates whether this function call is normal call or sibling call.
+   It will generate different pattern accordingly.  */
+
+void
+arc64_expand_call (rtx result, rtx mem, bool sibcall)
+{
+  rtx call, callee, tmp;
+  rtvec vec;
+  machine_mode mode;
+
+  gcc_assert (MEM_P (mem));
+  callee = XEXP (mem, 0);
+  mode = GET_MODE (callee);
+  gcc_assert (mode == Pmode || CONST_INT_P (callee));
+
+  /* Decide if we should generate indirect calls by loading the
+     address of the callee into a register before performing the
+     branch-and-link.  */
+  if (arc64_is_long_call_p (callee) && !REG_P (callee))
+    XEXP (mem, 0) = force_reg (mode, callee);
+
+  call = gen_rtx_CALL (VOIDmode, mem, const0_rtx);
+
+  if (result != NULL_RTX)
+    call = gen_rtx_SET (result, call);
+
+  if (sibcall)
+    tmp = ret_rtx;
+  else
+    tmp = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, BLINK_REGNUM));
+
+  vec = gen_rtvec (2, call, tmp);
+  call = gen_rtx_PARALLEL (VOIDmode, vec);
+
+  emit_call_insn (call);
+}
+
+/* Return nonzero if this function is known to have a null epilogue.
+   This allows the optimizer to omit jumps to jumps if no stack
+   was created.  */
+
+bool
+arc64_can_use_return_insn_p (void)
+{
+  return (reload_completed && cfun->machine->frame.frame_size == 0);
+}
+
+
+/* Return 1 if the register is used by the epilogue.  We need to say the
+   return register is used, but only after epilogue generation is complete.
+   Note that in the case of sibcalls, the values "used by the epilogue" are
+   considered live at the start of the called function.  */
+
+int
+arc64_epilogue_uses (int regno)
+{
+#ifdef HAVE_AS_TLS
+  if (regno == R30_REGNUM)
+    return 1;
+#endif
+
+  if (epilogue_completed)
+    if (regno == BLINK_REGNUM)
+      return 1;
+
+  return 0;
+}
+
+/* Return 1 if we use TP because it is alivel on entry to an exception
+   edge.  */
+
+int
+arc64_eh_uses (int regno ATTRIBUTE_UNUSED)
+{
+#ifdef HAVE_AS_TLS
+  if (regno == R30_REGNUM)
+    return 1;
+#endif
+  return 0;
+}
+
+
+/* Implement INITIAL_ELIMINATION_OFFSET.  FROM is either the frame pointer
+   or argument pointer.  TO is either the stack pointer or hard frame
+   pointer.  */
+
+HOST_WIDE_INT
+arc64_initial_elimination_offset (unsigned from, unsigned to)
+{
+  struct arc64_frame *frame = &cfun->machine->frame;
+
+  if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)
+    return frame->saved_regs_size;
+
+  if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)
+    return (frame->saved_regs_size + frame->saved_locals_size
+	    + frame->saved_outargs_size);
+
+  if ((from == FRAME_POINTER_REGNUM) && (to == STACK_POINTER_REGNUM))
+    return (frame->saved_locals_size + frame->saved_outargs_size);
+
+  if ((from == FRAME_POINTER_REGNUM) && (to == HARD_FRAME_POINTER_REGNUM))
+    return 0;
+
+  gcc_unreachable ();
+}
+
+/* Helper for INIT_EXPANDERS macro called to initialize any target
+   specific information.  */
+
+void arc64_init_expanders (void)
+{
+  init_machine_status = arc64_init_machine_status;
+}
+
+/* Given a comparison code (EQ, NE, etc.) and the first operand of a
+   COMPARE, return the mode to be used for the comparison.  */
+
+machine_mode
+arc64_select_cc_mode (enum rtx_code op,
+		      rtx x ATTRIBUTE_UNUSED,
+		      rtx y)
+{
+  machine_mode mode = GET_MODE (x);
+
+  /* Matches all instructions which can do .f and clobbers Z and N
+     flags.  Because we compare with zero, for LT we can use "mi" and
+     for GT we can use "pl".  We cannot use GT with "pnz" because it
+     cannot be reversed.  */
+  if (GET_MODE_CLASS (mode) == MODE_INT
+      && y == const0_rtx
+      && (op == EQ || op == NE || op == LT || op == GE))
+    return CC_ZNmode;
+
+  /* All floating point compares return CC_FPU if it is an equality
+     comparison, and CC_FPUE otherwise.  N.B. LTGT and UNEQ cannot be
+     directly mapped to fcmp instructions.  */
+  if (GET_MODE_CLASS (mode) == MODE_FLOAT)
+    {
+      switch (op)
+	{
+	case EQ:
+	case NE:
+	case UNORDERED:
+	case ORDERED:
+	case UNLT:
+	case UNLE:
+	case UNGT:
+	case UNGE:
+	case UNEQ:
+	  return CC_FPUmode;
+
+	case LT:
+	case LE:
+	case GT:
+	case GE:
+	case LTGT:
+	  return CC_FPUEmode;
+
+	default:
+	  gcc_unreachable ();
+	}
+    }
+  return CCmode;
+}
+
+/* Implement RETURN_ADDR_RTX.  We do not support moving back to a
+   previous frame.  */
+
+rtx
+arc64_return_addr (int count , rtx frame ATTRIBUTE_UNUSED)
+{
+  if (count != 0)
+    return const0_rtx;
+  return get_hard_reg_initial_val (Pmode, BLINK_REGNUM);
+}
+
+/* Expand the "prologue" pattern.  */
+
+void
+arc64_expand_prologue (void)
+{
+  HOST_WIDE_INT frame_allocated;
+  struct arc64_frame *frame = &cfun->machine->frame;
+
+  if (flag_stack_usage_info)
+    current_function_static_stack_size = frame->frame_size;
+
+  frame_allocated = frame->frame_size;
+
+  frame_allocated -= arc64_save_callee_saves ();
+
+  /* If something left, allocate.  */
+  if (frame_allocated > 0)
+    frame_stack_add ((HOST_WIDE_INT) 0 - frame_allocated);
+
+  /* Emit a blockage.  */
+  emit_insn (gen_blockage ());
+}
+
+/* Expand "epilogue" pattern.  */
+
+void
+arc64_expand_epilogue (bool sibcall_p)
+{
+  HOST_WIDE_INT frame_deallocated;
+  struct arc64_frame *frame = &cfun->machine->frame;
+
+  frame_deallocated = frame->frame_size;
+  frame_deallocated -= arc64_restore_callee_saves (sibcall_p);
+
+  if (frame_deallocated != 0)
+    frame_stack_add (frame_deallocated);
+
+  if (!sibcall_p)
+    emit_jump_insn (gen_simple_return ());
+}
+
+/* Helper used to determine if an address requires a long immediate.
+   To be used in computing the length of an load/store
+   instruction.  */
+
+bool
+arc64_limm_addr_p (rtx op)
+{
+  if (!MEM_P (op))
+    return false;
+
+  switch (GET_CODE (XEXP (op, 0)))
+    {
+    case SYMBOL_REF:
+    case LABEL_REF:
+    case CONST_INT:
+    case CONST:
+    case UNSPEC:
+      return true;
+    case PLUS:
+      /* legitimate address doesn't recognize [b,limm] variant of ld.
+	 Hence, use it to determine if we have limm or not in
+	 address.  */
+      return !arc64_legitimate_address_p (GET_MODE (op), op, true);
+    default:
+      break;
+    }
+  return false;
+}
+
+/* Used by move_dest_operand predicate.  */
+
+bool
+arc64_legitimate_store_address_p (machine_mode mode, rtx addr)
+{
+  return arc64_legitimate_address_1_p (mode, addr, true, false, true);
+}
+
+/* Return true if an address fits a short load/store instruction.  */
+
+bool
+arc64_short_access_p (rtx op, machine_mode mode, bool load_p)
+{
+  rtx addr, plus0, plus1;
+  bool f0, f1;
+
+  /* Eliminate non-memory operations.  */
+  if (GET_CODE (op) != MEM)
+    return 0;
+
+  /* FIXME! remove it when "uncached" attribute is added.  */
+  if (MEM_VOLATILE_P (op) && TARGET_VOLATILE_DI)
+    return false;
+
+  if (mode == VOIDmode)
+    mode = GET_MODE (op);
+
+  /* Decode the address now.  */
+  addr = XEXP (op, 0);
+  switch (GET_CODE (addr))
+    {
+    case REG:
+      return check_short_insn_register_p (addr, false);
+
+    case PLUS:
+      plus0 = XEXP (addr, 0);
+      plus1 = XEXP (addr, 1);
+
+      f0 = check_short_insn_register_p (plus0, false);
+      f1 = check_short_insn_constant_p (plus1, mode);
+
+      /* Check for [Rb + shimm].  */
+      if (f0 && f1)
+	return true;
+
+      if (!load_p)
+	return false;
+
+      /* Check for [Rb + Ri].  */
+      f1 = check_short_insn_register_p (plus1, false);
+
+      if (f0 && f1)
+	return true;
+
+    default:
+      break;
+    }
+  return false;
+}
+
+/* Return true if an address fits a floating point load/store
+   instruction.  The next formats are allowed [b, s9], [b], [s32limm],
+   and scaled [b, s9].  */
+
+bool
+arc64_fp_access_p (rtx op, machine_mode mode)
+{
+  rtx addr;
+
+  /* Eliminate non-memory operations.  */
+  if (GET_CODE (op) != MEM)
+    return 0;
+
+  /* FIXME! remove it when "uncached" attribute is added.  */
+  if (MEM_VOLATILE_P (op) && TARGET_VOLATILE_DI)
+    return false;
+
+  if (mode == VOIDmode)
+    mode = GET_MODE (op);
+
+  /* Decode the address now.  */
+  addr = XEXP (op, 0);
+
+  return arc64_legitimate_address_1_p (mode, addr, true, false, false);
+}
+
+/* Implement EH_RETURN_HANDLER_RTX.  EH returns need to either return
+   normally or return to a previous frame after unwinding.
+
+   An EH return uses a single shared return sequence.  The epilogue is
+   exactly like a normal epilogue except that it has an extra input
+   register (EH_RETURN_STACKADJ_RTX) which contains the stack
+   adjustment that must be applied after the frame has been destroyed.
+   An extra label is inserted before the epilogue which initializes
+   this register to zero, and this is the entry point for a normal
+   return.
+
+   An actual EH return updates the return address, initializes the
+   stack adjustment and jumps directly into the epilogue (bypassing
+   the zeroing of the adjustment).  Since the return address is
+   typically saved on the stack when a function makes a call, the
+   saved BLINK must be updated outside the epilogue.
+
+   This poses problems as the store is generated well before the
+   epilogue, so the offset of BLINK is not known yet.  Also
+   optimizations will remove the store as it appears dead, even after
+   the epilogue is generated (as the base or offset for loading BLINK
+   is different in many cases).
+
+   To avoid these problems this implementation forces the frame
+   pointer in eh_return functions so that the location of BLINK is
+   fixed and known early.  It also marks the store volatile, so no
+   optimization is permitted to remove the store.  */
+
+rtx
+arc64_eh_return_handler_rtx (void)
+{
+  rtx tmp = gen_frame_mem (Pmode,
+    plus_constant (Pmode, hard_frame_pointer_rtx, UNITS_PER_WORD));
+
+  /* Mark the store volatile, so no optimization is permitted to remove it.  */
+  MEM_VOLATILE_P (tmp) = true;
+  return tmp;
+}
+
+/* Select a format to encode pointers in exception handling data.  */
+
+int
+arc64_asm_preferred_eh_data_format (int code ATTRIBUTE_UNUSED, int global)
+{
+   int type;
+
+   if (!flag_pic)
+     return DW_EH_PE_absptr;
+
+   switch (arc64_cmodel_var)
+     {
+    case ARC64_CMODEL_SMALL:
+    case ARC64_CMODEL_MEDIUM:
+       /* text+got+data < 4Gb.  4-byte signed relocs are sufficient
+	  for everything.  */
+       type = DW_EH_PE_sdata4;
+       break;
+     default:
+       /* No assumptions here.  8-byte relocs required.  */
+       type = DW_EH_PE_sdata8;
+       break;
+     }
+   return (global ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | type;
+}
+
+/* Emit a (pre) memory barrier around an atomic sequence according to
+   MODEL.  */
+
+void
+arc64_pre_atomic_barrier (enum memmodel model)
+{
+  if (need_atomic_barrier_p (model, true))
+    emit_insn (gen_memory_barrier ());
+}
+
+/* Emit a (post) memory barrier around an atomic sequence according to
+   MODEL.  */
+
+void
+arc64_post_atomic_barrier (enum memmodel model)
+{
+  if (need_atomic_barrier_p (model, false))
+    emit_insn (gen_memory_barrier ());
+}
+
+/* Expand an atomic fetch-and-operate pattern.  CODE is the binary operation
+   to perform.  MEM is the memory on which to operate.  VAL is the second
+   operand of the binary operator.  BEFORE and AFTER are optional locations to
+   return the value of MEM either before of after the operation.  MODEL_RTX
+   is a CONST_INT containing the memory model to use.  */
+
+void
+arc64_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,
+			 rtx orig_before, rtx orig_after, rtx model_rtx)
+{
+  enum memmodel model = (enum memmodel) INTVAL (model_rtx);
+  machine_mode mode = GET_MODE (mem);
+  rtx label, x, cond;
+  rtx before = orig_before, after = orig_after;
+
+  /* ARC atomic ops work only with 32-bit aligned memories.  */
+  gcc_assert (mode == SImode || mode == DImode);
+
+  arc64_pre_atomic_barrier (model);
+
+  label = gen_label_rtx ();
+  emit_label (label);
+  label = gen_rtx_LABEL_REF (VOIDmode, label);
+
+  if (before == NULL_RTX)
+    before = gen_reg_rtx (mode);
+
+  if (after == NULL_RTX)
+    after = gen_reg_rtx (mode);
+
+  /* Load exclusive.  */
+  if(mode == SImode)
+    emit_insn (gen_arc_load_exclusivesi (before, mem));
+  else /* DImode */
+    emit_insn (gen_arc_load_exclusivedi (before, mem));
+
+  switch (code)
+    {
+    case NOT:
+      x = gen_rtx_AND (mode, before, val);
+      emit_insn (gen_rtx_SET (after, x));
+      x = gen_rtx_NOT (mode, after);
+      emit_insn (gen_rtx_SET (after, x));
+      break;
+
+    case MINUS:
+      if (CONST_INT_P (val))
+	{
+	  val = GEN_INT (-INTVAL (val));
+	  code = PLUS;
+	}
+
+      /* FALLTHRU.  */
+    default:
+      x = gen_rtx_fmt_ee (code, mode, before, val);
+      emit_insn (gen_rtx_SET (after, x));
+      break;
+   }
+
+  /* Exclusively store new item.  Store clobbers CC reg.  */
+  if(mode == SImode)
+    emit_insn (gen_arc_store_exclusivesi (mem, after));
+  else /* DImode */
+    emit_insn (gen_arc_store_exclusivedi (mem, after));
+
+  /* Check the result of the store.  */
+  cond = gen_rtx_REG (CC_Zmode, CC_REGNUM);
+  x = gen_rtx_NE (VOIDmode, cond, const0_rtx);
+  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,
+			    label, pc_rtx);
+  emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));
+
+  arc64_post_atomic_barrier (model);
+}
+
+/* Helper function used by "atomic_compare_and_swap" expand
+   pattern.  */
+
+void
+arc64_expand_compare_and_swap (rtx operands[])
+{
+  rtx bval, rval, mem, oldval, newval, is_weak, mod_s, mod_f, x;
+  machine_mode mode;
+
+  bval = operands[0];
+  rval = operands[1];
+  mem = operands[2];
+  oldval = operands[3];
+  newval = operands[4];
+  is_weak = operands[5];
+  mod_s = operands[6];
+  mod_f = operands[7];
+  mode = GET_MODE (mem);
+
+  if (reg_overlap_mentioned_p (rval, oldval))
+    oldval = copy_to_reg (oldval);
+
+  if (mode == SImode || mode == DImode)
+    {
+      if (mode == SImode)
+	emit_insn (gen_atomic_compare_and_swapsi_1 (rval, mem, oldval, newval,
+						    is_weak, mod_s, mod_f));
+      else /* DImode */
+	emit_insn (gen_atomic_compare_and_swapdi_1 (rval, mem, oldval, newval,
+						    is_weak, mod_s, mod_f));
+
+      x = gen_rtx_REG (CC_Zmode, CC_REGNUM);
+      x = gen_rtx_EQ (SImode, x, const0_rtx);
+      emit_insn (gen_rtx_SET (bval, x));
+    }
+  else
+    {
+      arc_expand_compare_and_swap_qh (bval, rval, mem, oldval, newval,
+				      is_weak, mod_s, mod_f);
+    }
+}
+
+/* Helper function used by the "atomic_compare_and_swapsdi_1"
+   pattern.  */
+
+void
+arc64_split_compare_and_swap (rtx operands[])
+{
+  rtx rval, mem, oldval, newval;
+  machine_mode mode, mode_cc;
+  enum memmodel mod_s, mod_f;
+  bool is_weak;
+  rtx label1, label2, x, cond;
+
+  rval = operands[0];
+  mem = operands[1];
+  oldval = operands[2];
+  newval = operands[3];
+  is_weak = (operands[4] != const0_rtx);
+  mod_s = (enum memmodel) INTVAL (operands[5]);
+  mod_f = (enum memmodel) INTVAL (operands[6]);
+  mode = GET_MODE (mem);
+
+  /* ARC atomic ops work only with 32-bit or 64-bit aligned memories.  */
+  gcc_assert (mode == SImode || mode == DImode);
+
+  arc64_pre_atomic_barrier (mod_s);
+
+  label1 = NULL_RTX;
+  if (!is_weak)
+    {
+      label1 = gen_label_rtx ();
+      emit_label (label1);
+    }
+  label2 = gen_label_rtx ();
+
+  /* Load exclusive.  */
+  if(mode == SImode)
+    emit_insn (gen_arc_load_exclusivesi (rval, mem));
+  else /* DImode */
+    emit_insn (gen_arc_load_exclusivedi (rval, mem));
+
+  /* Check if it is oldval.  */
+  mode_cc = SELECT_CC_MODE (NE, rval, oldval);
+  cond = gen_rtx_REG (mode_cc, CC_REGNUM);
+  emit_insn (gen_rtx_SET (cond, gen_rtx_COMPARE (mode_cc, rval, oldval)));
+
+  x = gen_rtx_NE (VOIDmode, cond, const0_rtx);
+  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,
+			    gen_rtx_LABEL_REF (Pmode, label2), pc_rtx);
+  emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));
+
+  /* Exclusively store new item.  Store clobbers CC reg.  */
+  if(mode == SImode)
+    emit_insn (gen_arc_store_exclusivesi (mem, newval));
+  else /* DImode */
+    emit_insn (gen_arc_store_exclusivedi (mem, newval));
+
+  if (!is_weak)
+    {
+      /* Check the result of the store.  */
+      cond = gen_rtx_REG (CC_Zmode, CC_REGNUM);
+      x = gen_rtx_NE (VOIDmode, cond, const0_rtx);
+      x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,
+				gen_rtx_LABEL_REF (Pmode, label1), pc_rtx);
+      emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));
+    }
+
+  if (mod_f != MEMMODEL_RELAXED)
+    emit_label (label2);
+
+  arc64_post_atomic_barrier (mod_s);
+
+  if (mod_f == MEMMODEL_RELAXED)
+    emit_label (label2);
+}
+
+/* Expander for casesi.  The vector table is always PC-relative, and
+   it is made up of branch instructions.  When we have CODE_DENSITY
+   option enabled, we use BI instruction, otherwise, depending on the
+   memory model, an emulation of it.  We use the same emulation
+   contruction, for PIC or LARGE memory model.  For a non-pic
+   SMALL/MEDIUM memory model, we make use of a single add2 instruction
+   which has one input the address of the start dispatch table, and
+   the other input indicates where we jump in the table.  */
+
+void arc64_expand_casesi (rtx operands[])
+{
+  rtx reg;
+
+  if (operands[1] != const0_rtx)
+    {
+      reg = gen_reg_rtx (SImode);
+      operands[1] = GEN_INT (trunc_int_for_mode (-INTVAL (operands[1]),
+						 SImode));
+      emit_insn (gen_addsi3 (reg, operands[0], operands[1]));
+      operands[0] = reg;
+    }
+  emit_unlikely_jump (gen_cbranchsi4 (gen_rtx_GTU (SImode, operands[0],
+						   operands[2]),
+				      operands[0], operands[2], operands[4]));
+
+  if (!TARGET_CODE_DENSITY)
+    {
+      switch (arc64_cmodel_var)
+	{
+	case ARC64_CMODEL_SMALL:
+	  if (!flag_pic)
+	    {
+	      reg = gen_reg_rtx (SImode);
+	      emit_insn (gen_casesi_addaddr (reg, operands[0], operands[3]));
+	      operands[0] = reg;
+	      break;
+	    }
+	  /* Fall through */
+	case ARC64_CMODEL_MEDIUM:
+	case ARC64_CMODEL_LARGE:
+	  {
+	    /* Same code is used for PIC and large memory model.  */
+	    rtx lbl = gen_rtx_LABEL_REF (VOIDmode, operands[3]);
+	    rtx tmp = gen_reg_rtx (DImode);
+	    reg = gen_reg_rtx (DImode);
+	    emit_insn (gen_rtx_SET (reg,
+				    gen_rtx_UNSPEC (DImode,
+						    gen_rtvec (1, lbl),
+						    ARC64_UNSPEC_PCREL)));
+	    emit_insn (gen_casesi_addaddrdi (tmp, operands[0], reg));
+	    emit_jump_insn (gen_casesi_dispatchdi (tmp, operands[3]));
+	    return;
+	  }
+	default:
+	  gcc_unreachable ();
+	}
+    }
+
+  emit_jump_insn (gen_casesi_dispatch (operands[0], operands[3]));
+}
+
+bool
+arc64_allow_direct_access_p (rtx op)
+{
+  return (arc64_get_symbol_type (op) == ARC64_LO32);
+}
+
+/* Decide if mov simd instruction needs to be split.  Return TRUE if
+   so.  This procedure is required when the vector length is larger
+   than 64 bit.  */
+bool
+arc64_simd64x_split_move_p (rtx *operands, machine_mode mode)
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+
+  if (register_operand (op0, mode) && register_operand (op1, mode))
+    {
+      /* Check for r-reg to f-reg moves.  */
+      if (GP_REGNUM_P (REGNO (op0)) || GP_REGNUM_P (REGNO (op1)))
+	return true;
+
+      /* Sanity check for vfmov instruction.  */
+      gcc_assert (arc64_fsimd_register (op0, mode)
+		  && arc64_fsimd_register (op1, mode));
+      return false;
+    }
+
+  /* Check if we have 128bit moves.  */
+  if (TARGET_WIDE_LDST
+      && (GET_MODE_SIZE (mode) <= (UNITS_PER_WORD * 2))
+      && ((memory_operand (op0, mode) && REG_P (op1))
+	  || (memory_operand (op1, mode) && REG_P (op0))))
+    {
+      /* Sanity check for wide st/ld instructions.  */
+      if (REG_P (op0) && ((REGNO (op0) & 0x01) != 0))
+	return true;
+      if (REG_P (op1) && ((REGNO (op1) & 0x01) != 0))
+	return true;
+      return false;
+    }
+
+  /* Evereything else is going for a split.  */
+  return true;
+}
+
+/* This is the actual routine which splits a move simd to smaller
+   bits.  */
+void
+arc64_simd128_split_move (rtx *operands, machine_mode mode)
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx lo, hi, mem_lo, mem_hi, src, dst;
+  unsigned int rdst, rsrc, i;
+  unsigned iregs = CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);
+  bool swap_p = false;
+
+  /* Maximum size handled is 256b.  */
+  gcc_assert (iregs <= 2);
+
+  /* This procedure works as long as the width of the fp regs is the
+     same as the width of r regs.  */
+  if (FLOAT_MODE_P (mode))
+      gcc_assert (UNITS_PER_WORD == UNITS_PER_FP_REG);
+
+  /* Split reg-reg move.  */
+  if (REG_P (op0) && REG_P (op1))
+    {
+      rdst = REGNO (op0);
+      rsrc = REGNO (op1);
+
+      if (!reg_overlap_mentioned_p (op0, op1)
+	  || rdst < rsrc)
+	/* The fp regs will never overlap r-regs.  However, this
+	   procedure can be used also for r-reg to r-regs splits.  */
+	for (i = 0; i < iregs; i++)
+	  emit_move_insn (gen_rtx_REG (DFmode, rdst + i),
+			  gen_rtx_REG (DFmode, rsrc + i));
+      else
+	for (i = 0; i < iregs; i++)
+	  emit_move_insn (gen_rtx_REG (DFmode, rdst + iregs - i - 1),
+			  gen_rtx_REG (DFmode, rsrc + iregs - i - 1));
+      return;
+    }
+
+  /* Split mem-reg moves.  */
+  gcc_assert (REG_P (op0) || REG_P (op1));
+
+  if (REG_P (op1))
+    {
+      src = op1;
+      dst = op0;
+    }
+  else
+    {
+      src = op0;
+      dst = op1;
+    }
+
+  lo = gen_lowpart (DFmode, src);
+  hi = gen_highpart_mode (DFmode, mode, src);
+
+  if (auto_inc_p (XEXP (dst, 0)))
+    {
+      rtx offset, reg, next, addr = XEXP (dst, 0);
+      enum rtx_code code = GET_CODE (addr);
+
+      switch (code)
+	{
+	case PRE_INC:
+	  offset = GEN_INT (GET_MODE_SIZE (mode));
+	  code = PRE_MODIFY;
+	  break;
+	case PRE_DEC:
+	  offset = GEN_INT (-GET_MODE_SIZE (mode));
+	  code = PRE_MODIFY;
+	  break;
+	case POST_MODIFY:
+	case PRE_MODIFY:
+	  offset =  XEXP (XEXP (addr, 1), 1);
+	  break;
+	case POST_INC:
+	  offset = GEN_INT (GET_MODE_SIZE (mode));
+	  code = POST_MODIFY;
+	  break;
+	case POST_DEC:
+	  offset = GEN_INT (-GET_MODE_SIZE (mode));
+	  code = POST_MODIFY;
+	  break;
+	default:
+	  gcc_unreachable ();
+	}
+
+      reg = XEXP (addr, 0);
+      next = gen_rtx_fmt_ee (code, Pmode, reg,
+			     gen_rtx_PLUS (Pmode, reg, offset));
+
+      switch (code)
+	{
+	case POST_MODIFY:
+	  /* We need to swap lo/hi order such that we emit first the
+	     hi-load with an offset, and last the post modify
+	     instruction.  Thus the code can handle any type of auto
+	     increment address.  */
+	  mem_lo = adjust_automodify_address (dst, DFmode, next, 0);
+	  next = plus_constant (Pmode, reg, GET_MODE_SIZE (DFmode));
+	  mem_hi = adjust_automodify_address (dst, DFmode, next,
+					      GET_MODE_SIZE (DFmode));
+	  swap_p = true;
+	  break;
+	case PRE_MODIFY:
+	  mem_lo = adjust_automodify_address (dst, DFmode, next, 0);
+	  next = plus_constant (Pmode, reg, GET_MODE_SIZE (DFmode));
+	  mem_hi = adjust_automodify_address (dst, DFmode, next,
+					      GET_MODE_SIZE (DFmode));
+	  break;
+	default:
+	  gcc_unreachable ();
+	}
+    }
+  else
+    {
+      mem_lo = adjust_address (dst, DFmode, 0);
+      mem_hi = arc64_move_pointer (mem_lo, GET_MODE_SIZE (DFmode));
+    }
+
+  if (REG_P (op1))
+    {
+      if (!swap_p)
+	emit_move_insn (mem_lo, lo);
+      emit_move_insn (mem_hi, hi);
+      if (swap_p)
+	emit_move_insn (mem_lo, lo);
+    }
+  else
+    {
+      if (!swap_p)
+	emit_move_insn (lo, mem_lo);
+      emit_move_insn (hi, mem_hi);
+      if (swap_p)
+	emit_move_insn (lo, mem_lo);
+    }
+}
+
+/* Provide a mapping from gcc register numbers to dwarf register numbers.  */
+unsigned
+arc64_dbx_register_number (unsigned regno)
+{
+  if (GP_REGNUM_P (regno))
+    return regno;
+  else if (FP_REGNUM_P (regno))
+    return 128 + regno - F0_REGNUM;
+
+  /* Return values >= DWARF_FRAME_REGISTERS indicate that there is no
+     equivalent DWARF register.  */
+   return DWARF_FRAME_REGISTERS;
+}
+
+#if 0
+/* Expand fp vector shift right pattern.  Can handle maximum 128bit
+   SIMD vectors.
+
+   +----+----+----+----+----+----+----+----+
+   | h7 | h6 | h5 | h4 | h3 | h2 | h1 | h0 |
+   |    s3   |    s2   |    s1   |    s0   |
+   |         d1        |         d0        |
+   +----+----+----+----+----+----+----+----+
+
+ */
+
+bool
+arc64_expand_fvect_shr (rtx *operands)
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx op2 = operands[2];
+  rtx t0;
+  machine_mode mode = GET_MODE (op0);
+  scalar_int_mode imode = int_mode_for_mode (mode).require ();
+  unsigned int ival = INTVAL (op2);
+
+  if (ARC64_VFP_128 && (ival == 64))
+    {
+      emit_move_insn (gen_lowpart (DFmode, op0), gen_highpart (DFmode, op1));
+      return true;
+    }
+  else if (ARC64_VFP_64 && (ival == 32))
+    {
+      t0 = gen_reg_rtx (SFmode);
+
+      emit_insn (gen_vec_extractv2sfsf (t0,
+				      gen_lowpart (V2SFmode, op1),
+				      GEN_INT (1)));
+      emit_insn (gen_vec_setv2sf (gen_lowpart (V2SFmode, op0),
+				  t0, GEN_INT (0)));
+      return true;
+    }
+  else if (ARC64_VFP_32 && (ival == 16))
+    {
+      t0 = gen_reg_rtx (HFmode);
+
+      emit_insn (gen_vec_extractv2hfhf (t0, op1, GEN_INT (1)));
+      emit_insn (gen_vec_setv2hf (op0, t0, GEN_INT (0)));
+      return true;
+    }
+
+  t0 = gen_reg_rtx (imode);
+  rtx shift = expand_binop (imode, lshr_optab,
+			    gen_lowpart (imode, op1), op2,
+			    NULL_RTX, true, OPTAB_DIRECT);
+  emit_move_insn (t0, shift);
+  emit_move_insn (op0, gen_lowpart (mode, t0));
+  return true;
+}
+#endif
+
+/* Target hooks.  */
+
+#undef TARGET_ASM_ALIGNED_DI_OP
+#define TARGET_ASM_ALIGNED_DI_OP "\t.xword\t"
+
+#undef TARGET_ASM_ALIGNED_HI_OP
+#define TARGET_ASM_ALIGNED_HI_OP "\t.hword\t"
+
+#undef TARGET_ASM_ALIGNED_SI_OP
+#define TARGET_ASM_ALIGNED_SI_OP "\t.word\t"
+
+#undef  TARGET_ASM_CAN_OUTPUT_MI_THUNK
+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK \
+  hook_bool_const_tree_hwi_hwi_const_tree_true
+
+#undef TARGET_ASM_OUTPUT_MI_THUNK
+#define TARGET_ASM_OUTPUT_MI_THUNK arc64_output_mi_thunk
+
+#undef TARGET_CAN_ELIMINATE
+#define TARGET_CAN_ELIMINATE arc64_can_eliminate
+
+#undef TARGET_LEGITIMATE_ADDRESS_P
+#define TARGET_LEGITIMATE_ADDRESS_P arc64_legitimate_address_p
+
+#undef TARGET_LEGITIMATE_CONSTANT_P
+#define TARGET_LEGITIMATE_CONSTANT_P arc64_legitimate_constant_p
+
+#undef TARGET_RETURN_IN_MEMORY
+#define TARGET_RETURN_IN_MEMORY arc64_return_in_memory
+
+/* Passing arguments.  */
+#undef TARGET_PASS_BY_REFERENCE
+#define TARGET_PASS_BY_REFERENCE arc64_pass_by_reference
+
+#undef TARGET_SETUP_INCOMING_VARARGS
+#define TARGET_SETUP_INCOMING_VARARGS arc64_setup_incoming_varargs
+
+#undef TARGET_MUST_PASS_IN_STACK
+#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size
+
+#undef TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE arc64_function_value
+
+#undef TARGET_FUNCTION_VALUE_REGNO_P
+#define TARGET_FUNCTION_VALUE_REGNO_P arc64_function_value_regno_p
+
+#undef TARGET_FUNCTION_ARG
+#define TARGET_FUNCTION_ARG arc64_function_arg
+
+#undef TARGET_FUNCTION_ARG_ADVANCE
+#define TARGET_FUNCTION_ARG_ADVANCE arc64_function_arg_advance
+
+#undef TARGET_ARG_PARTIAL_BYTES
+#define TARGET_ARG_PARTIAL_BYTES arc64_arg_partial_bytes
+
+#undef TARGET_STRICT_ARGUMENT_NAMING
+#define TARGET_STRICT_ARGUMENT_NAMING hook_bool_CUMULATIVE_ARGS_true
+
+#undef TARGET_COMPUTE_FRAME_LAYOUT
+#define TARGET_COMPUTE_FRAME_LAYOUT arc64_compute_frame_info
+
+#undef TARGET_HARD_REGNO_NREGS
+#define TARGET_HARD_REGNO_NREGS arc64_hard_regno_nregs
+
+#undef TARGET_HARD_REGNO_MODE_OK
+#define TARGET_HARD_REGNO_MODE_OK arc64_hard_regno_mode_ok
+
+#undef TARGET_MODES_TIEABLE_P
+#define TARGET_MODES_TIEABLE_P arc64_modes_tieable_p
+
+#undef  TARGET_PRINT_OPERAND
+#define TARGET_PRINT_OPERAND arc64_print_operand
+
+#undef  TARGET_PRINT_OPERAND_ADDRESS
+#define TARGET_PRINT_OPERAND_ADDRESS arc64_print_operand_address
+
+#undef TARGET_PRINT_OPERAND_PUNCT_VALID_P
+#define TARGET_PRINT_OPERAND_PUNCT_VALID_P arc64_print_operand_punct_valid_p
+
+#undef TARGET_TRAMPOLINE_INIT
+#define TARGET_TRAMPOLINE_INIT arc64_initialize_trampoline
+
+#undef TARGET_ASM_TRAMPOLINE_TEMPLATE
+#define TARGET_ASM_TRAMPOLINE_TEMPLATE arc64_asm_trampoline_template
+
+#undef TARGET_HAVE_SPECULATION_SAFE_VALUE
+#define TARGET_HAVE_SPECULATION_SAFE_VALUE speculation_safe_value_not_needed
+
+#undef  TARGET_FUNCTION_OK_FOR_SIBCALL
+#define TARGET_FUNCTION_OK_FOR_SIBCALL arc64_function_ok_for_sibcall
+
+#undef TARGET_INIT_LIBFUNCS
+#define TARGET_INIT_LIBFUNCS arc64_init_libfuncs
+
+#undef TARGET_ASM_FILE_END
+#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
+
+#undef  TARGET_ASM_FUNCTION_PROLOGUE
+#define TARGET_ASM_FUNCTION_PROLOGUE arc64_output_function_prologue
+
+#undef TARGET_CONSTANT_ALIGNMENT
+#define TARGET_CONSTANT_ALIGNMENT constant_alignment_word_strings
+
+#undef TARGET_PROMOTE_FUNCTION_MODE
+#define TARGET_PROMOTE_FUNCTION_MODE \
+  default_promote_function_mode_always_promote
+
+/* To be checked if it is better without it.  */
+#undef TARGET_PROMOTE_PROTOTYPES
+#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true
+
+#undef TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA
+#define TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA arc64_output_addr_const_extra
+
+#undef  TARGET_INIT_BUILTINS
+#define TARGET_INIT_BUILTINS  arc64_init_builtins
+
+#undef  TARGET_EXPAND_BUILTIN
+#define TARGET_EXPAND_BUILTIN arc64_expand_builtin
+
+#undef  TARGET_BUILTIN_DECL
+#define TARGET_BUILTIN_DECL arc64_builtin_decl
+
+/* Having TLS support, we turn R30 fixed as well.  */
+#ifdef HAVE_AS_TLS
+#undef TARGET_HAVE_TLS
+#define TARGET_HAVE_TLS HAVE_AS_TLS
+#endif
+
+#undef TARGET_LRA_P
+#define TARGET_LRA_P hook_bool_void_true
+
+#undef  TARGET_INSN_COST
+#define TARGET_INSN_COST arc64_insn_cost
+
+#undef  TARGET_MACHINE_DEPENDENT_REORG
+#define TARGET_MACHINE_DEPENDENT_REORG arc64_reorg
+
+#undef TARGET_MIN_ARITHMETIC_PRECISION
+#define TARGET_MIN_ARITHMETIC_PRECISION arc64_min_arithmeric_precision
+
+#undef TARGET_CONDITIONAL_REGISTER_USAGE
+#define TARGET_CONDITIONAL_REGISTER_USAGE arc64_conditional_register_usage
+
+#undef TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P
+#define TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P \
+arc64_libgcc_floating_mode_supported_p
+
+#undef TARGET_SCALAR_MODE_SUPPORTED_P
+#define TARGET_SCALAR_MODE_SUPPORTED_P arc64_scalar_mode_supported_p
+
+#undef TARGET_SPLIT_COMPLEX_ARG
+#define TARGET_SPLIT_COMPLEX_ARG arc64_split_complex_arg
+
+/* Vectors.  */
+#undef TARGET_VECTOR_MODE_SUPPORTED_P
+#define TARGET_VECTOR_MODE_SUPPORTED_P arc64_vector_mode_supported_p
+
+#undef TARGET_VECTORIZE_PREFERRED_SIMD_MODE
+#define TARGET_VECTORIZE_PREFERRED_SIMD_MODE arc64_preferred_simd_mode
+
+#undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES
+#define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES	\
+  arc64_autovectorize_vector_modes
+
+#undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST
+#define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST	\
+  arc64_builtin_vectorization_cost
+
+#undef TARGET_REGISTER_MOVE_COST
+#define TARGET_REGISTER_MOVE_COST arc64_register_move_cost
+
+#undef TARGET_VECTORIZE_VEC_PERM_CONST
+#define TARGET_VECTORIZE_VEC_PERM_CONST arc64_vectorize_vec_perm_const
+
+#undef TARGET_RTX_COSTS
+#define TARGET_RTX_COSTS arc64_rtx_costs_wrapper
+
+#undef TARGET_ADDRESS_COST
+#define TARGET_ADDRESS_COST arc64_address_cost
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+#include "gt-arc64.h"
diff --git a/gcc/config/arc64/arc64.h b/gcc/config/arc64/arc64.h
new file mode 100644
index 00000000000..cffe964d88a
--- /dev/null
+++ b/gcc/config/arc64/arc64.h
@@ -0,0 +1,658 @@
+/* Machine description for ARC64 architecture.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_ARC64_H
+#define GCC_ARC64_H
+
+/* Bits are always numbered from the LSBit.  */
+#define BITS_BIG_ENDIAN 0
+
+/* Define this if most significant byte of a word is the lowest numbered.  */
+#define BYTES_BIG_ENDIAN 0
+
+/* Define this if most significant word of a multiword number is the lowest
+   numbered.  */
+#define WORDS_BIG_ENDIAN 0
+
+/* Width of a word, in units (bytes).  */
+#define UNITS_PER_WORD  8
+
+/* Width of a fp register, in bytes.  */
+#define UNITS_PER_FP_REG ((ARC64_VFP_64 || ARC64_VFP_128) ? 8 : 4)
+
+/* Maximum number of registers that can appear in a valid memory
+   address.  N.B. The ld insn allows 2, but the st insn only allows
+   1.  */
+#define MAX_REGS_PER_ADDRESS 2
+
+/* Addressing modes.  */
+#define HAVE_PRE_INCREMENT 1
+#define HAVE_PRE_DECREMENT 1
+#define HAVE_POST_INCREMENT 1
+#define HAVE_POST_DECREMENT 1
+#define HAVE_PRE_MODIFY_DISP 1
+#define HAVE_POST_MODIFY_DISP 1
+#define HAVE_PRE_MODIFY_REG 1
+#define HAVE_POST_MODIFY_REG 1
+
+/* The number of registers used for parameter passing.  Local to this
+   file.  */
+#define MAX_ARC64_PARM_REGS 8
+
+/* 1 if N is a possible register number for function argument
+   passing.  */
+/* Hard floats: r0-r7, and f0-f7.  */
+#define FUNCTION_ARG_REGNO_P(N)						\
+  (IN_RANGE ((N), R0_REGNUM, R7_REGNUM)					\
+   || (ARC64_HAS_FP_BASE && IN_RANGE ((N), F0_REGNUM, F7_REGNUM)))
+
+/* Boundaries.  */
+#define PARM_BOUNDARY		64
+#define STACK_BOUNDARY		64
+#define FUNCTION_BOUNDARY	32
+#define EMPTY_FIELD_BOUNDARY	32
+#define STRUCTURE_SIZE_BOUNDARY 8
+
+/* Look at the fundamental type that is used for a bit-field and use
+   that to impose alignment on the enclosing structure.  struct s {int
+   a:8}; should have same alignment as "int", not "char".  */
+#define	PCC_BITFIELD_TYPE_MATTERS	1
+
+/* Alignments.  */
+#define FASTEST_ALIGNMENT       BITS_PER_WORD
+#define BIGGEST_ALIGNMENT	64
+#define ARC64_EXPAND_ALIGNMENT(COND, EXP, ALIGN)			\
+  (((COND) && ((ALIGN) < FASTEST_ALIGNMENT)				\
+    && (TREE_CODE (EXP) == ARRAY_TYPE)) ? FASTEST_ALIGNMENT : (ALIGN))
+
+/* Align global data.  */
+#define DATA_ALIGNMENT(EXP, ALIGN)			\
+  ARC64_EXPAND_ALIGNMENT (!optimize_size, EXP, ALIGN)
+
+/* Similarly, make sure that objects on the stack are sensibly
+   aligned.  */
+#define LOCAL_ALIGNMENT(EXP, ALIGN)				\
+  ARC64_EXPAND_ALIGNMENT (!flag_conserve_stack, EXP, ALIGN)
+
+/* Set this nonzero if move instructions will actually fail to work
+   when given unaligned data.  */
+#define STRICT_ALIGNMENT        (!unaligned_access)
+
+/* Default unaligned accesses.  */
+#ifndef UNALIGNED_ACCESS_DEFAULT
+#define UNALIGNED_ACCESS_DEFAULT 0
+#endif
+
+/* Layout of Source Language Data Types.  */
+#define SHORT_TYPE_SIZE         16
+#define INT_TYPE_SIZE           32
+#define LONG_TYPE_SIZE          64
+#define LONG_LONG_TYPE_SIZE     64
+#define POINTER_SIZE            64
+
+#define FLOAT_TYPE_SIZE		32
+#define DOUBLE_TYPE_SIZE	64
+#define LONG_DOUBLE_TYPE_SIZE	64
+
+/* Defined by ABI.  */
+#define WCHAR_TYPE "unsigned int"
+#define WCHAR_TYPE_SIZE 32
+
+#define DEFAULT_SIGNED_CHAR 0
+
+#define SIZE_TYPE       "long unsigned int"
+#define PTRDIFF_TYPE	"long int"
+
+/* Specify the machine mode that the hardware addresses have.
+   After generation of rtl, the compiler makes no further distinction
+   between pointers and any other objects of this machine mode.  */
+#define Pmode         DImode
+
+/* Mode of a function address in a call instruction (for indexing purposes).  */
+#define FUNCTION_MODE	Pmode
+
+#ifdef HAVE_AS_TLS
+#define ARC64_TLS_REGNO 1
+#else
+#define ARC64_TLS_REGNO 0
+#endif
+
+/* Register usage:
+   R0-R3    Parameter/result registers
+   R4-R7    Parameter registers
+   R8-R13   Temporary registers
+   R14-R26  Callee-saved registers
+   R27      FP (frame pointer)
+   R28      SP (stack pointer)
+   R29      ILINK (Interrupt link register)
+   R30      GP/TP Global pointer, also it is used as thread pointer;
+            otherwise can be used  as a temporary register.
+   R31      BLINK (return register)
+   R32-R57  Extension registers
+   R58      ACC (accumulator)
+   R59      Reserved
+   --- Special registers ---
+   R60      sign-extended 32-bit indicator
+   R61      Reserved
+   R62      zero extended 32-bit immediate indicator
+   R63      PCL (program counter)
+   --- Floating point registers ---
+   F0       Parameter/result register
+   F1-F7    Parameter registers
+   F8-F13   Temporary registers
+   F14-F31  Callee-saved registers
+   -- Fake registers --
+   AP       Argument pointer
+   SFP      Soft frame pointer
+   CC       Status register.
+ */
+
+/* 1 for registers that are not available for the register
+   allocator.  */
+#define FIXED_REGISTERS							\
+  {									\
+    0, 0, 0, 0,   0, 0, 0, 0,  /* R0 - R7 */				\
+    0, 0, 0, 0,   0, 0, 0, 0,  /* R8 - R15 */				\
+    0, 0, 0, 0,   0, 0, 0, 0,  /* R16 - R23 */				\
+    0, 0, 0, 0,   1, 1, ARC64_TLS_REGNO, 1,  /* R24 - R26, FP, SP, ILINK, R30, BLINK */ \
+    									\
+    1, 1, 1, 1,   1, 1, 1, 1,  /* R32 - R39 */				\
+    1, 1, 1, 1,   1, 1, 1, 1,  /* R40 - R47 */				\
+    1, 1, 1, 1,   1, 1, 1, 1,  /* R48 - R55 */				\
+    1, 1, 1, 1,   1, 1, 1, 1,  /* R56, R57, ACCL, R59, Specials */	\
+    									\
+    1, 1, 1, 1,   1, 1, 1, 1,  /* F0 - F7 */				\
+    1, 1, 1, 1,   1, 1, 1, 1,  /* F8 - F15 */				\
+    1, 1, 1, 1,   1, 1, 1, 1,  /* F16 - F23 */				\
+    1, 1, 1, 1,   1, 1, 1, 1,  /* F24 - F31 */				\
+    									\
+    1, 1, 1,                   /* AP, SFP, CC */			\
+  }
+
+/* 1 for registers not available across function calls.  */
+#define CALL_USED_REGISTERS						\
+  {									\
+   1, 1, 1, 1,   1, 1, 1, 1,  /* R0 - R7 */				\
+   1, 1, 1, 1,   1, 1, 0, 0,  /* R8 - R15 */				\
+   0, 0, 0, 0,   0, 0, 0, 0,  /* R16 - R23 */				\
+   0, 0, 0, 0,   1, 1, 1, 1,  /* R24 - R26, FP, SP, ILINK, R30, BLINK */ \
+									\
+   1, 1, 1, 1,   1, 1, 1, 1,  /* R32 - R39 */				\
+   1, 1, 1, 1,   1, 1, 1, 1,  /* R40 - R47 */				\
+   1, 1, 1, 1,   1, 1, 1, 1,  /* R48 - R55 */				\
+   1, 1, 1, 1,   1, 1, 1, 1,  /* R56, R57, ACCL, R59, Specials */	\
+									\
+   1, 1, 1, 1,   1, 1, 1, 1,  /* F0 - F7 */				\
+   1, 1, 1, 1,   1, 1, 1, 1,  /* F8 - F15 */				\
+   1, 1, 1, 1,   1, 1, 1, 1,  /* F16 - F23 */				\
+   1, 1, 1, 1,   1, 1, 1, 1,  /* F24 - F31 */				\
+    									\
+   1, 1, 1,                   /* AP, SFP, CC */				\
+  }
+
+#define REGISTER_NAMES							\
+  {									\
+   "r0",  "r1",  "r2",  "r3",     "r4",   "r5",    "r6",  "r7",		\
+   "r8",  "r9",  "r10", "r11",    "r12",  "r13",   "r14", "r15",	\
+   "r16", "r17", "r18", "r19",    "r20",  "r21",   "r22", "r23",	\
+   "r24", "r25", "r26", "r27",    "sp",   "ilink", "r30", "blink",	\
+   "r32", "r33", "r34", "r35",    "r36",  "r37",   "r38", "r39",	\
+   "r40", "r41", "r42", "r43",    "r44",  "r45",   "r46", "r47",	\
+   "r48", "r49", "r50", "r51",    "r52",  "r53",   "r54", "r55",	\
+   "r56", "r57", "r58", "r59",    "ximm", "rez",   "limm", "pcl",	\
+									\
+   "f0",  "f1",  "f2",  "f3",     "f4",   "f5",    "f6",  "f7",		\
+   "f8",  "f9",  "f10", "f11",    "f12",  "f13",   "f14", "f15",	\
+   "f16", "f17", "f18", "f19",    "f20",  "f21",   "f22", "f23",	\
+   "f24", "f25", "f26", "f27",    "f28",  "f29",   "f30", "f31",	\
+   "ap", "sfp", "cc",							\
+  }
+
+#define ADDITIONAL_REGISTER_NAMES		\
+  {						\
+   { "fp", 27 },				\
+   { "gp", 30 },				\
+   { "acc", 58 },				\
+  }
+
+#define EPILOGUE_USES(REGNO) (arc64_epilogue_uses (REGNO))
+
+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
+   the stack pointer does not matter.  This is only true if the function
+   uses alloca.  */
+#define EXIT_IGNORE_STACK (cfun->calls_alloca)
+
+#define STATIC_CHAIN_REGNUM		R11_REGNUM
+#define HARD_FRAME_POINTER_REGNUM	R27_REGNUM
+#define FRAME_POINTER_REGNUM		SFP_REGNUM
+#define STACK_POINTER_REGNUM		SP_REGNUM
+#define ARG_POINTER_REGNUM		AP_REGNUM
+#define FIRST_PSEUDO_REGISTER		(CC_REGNUM + 1)
+
+enum reg_class
+{
+   NO_REGS,
+   AC16_REGS,
+   SIBCALL_REGS,
+   GENERAL_REGS,
+   FP_REGS,
+   ALL_REGS,
+   LIM_REG_CLASSES
+};
+
+#define N_REG_CLASSES	((int) LIM_REG_CLASSES)
+
+#define REG_CLASS_NAMES				\
+{						\
+    "NO_REGS",					\
+    "AC16_REGS",				\
+    "SIBCALL_REGS",				\
+    "GENERAL_REGS",				\
+    "FP_REGS",					\
+    "ALL_REGS"					\
+}
+
+#define REG_CLASS_CONTENTS					\
+{								\
+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000 }, /* NO_REGS */	\
+  { 0x0000f00f, 0x00000000, 0x00000000, 0x00000000 }, /* AC16_REGS */	\
+  { 0x00001fff, 0x00000000, 0x00000000, 0x00000000 }, /* SIBCALL_REGS */ \
+  { 0xdfffffff, 0x0fffffff, 0x00000000, 0x00000003 }, /* GENERAL_REGS */ \
+  { 0x00000000, 0x00000000, 0xffffffff, 0x00000000 }, /* FP_REGS */	\
+  { 0xffffffff, 0xffffffff, 0xffffffff, 0x00000007 }, /* ALL_REGS */	\
+}
+
+/* A C expression whose value is a register class containing hard
+   register REGNO.  In general there is more that one such class;
+   choose a class which is "minimal", meaning that no smaller class
+   also contains the register.  */
+
+#define REGNO_REG_CLASS(REGNO) arc64_regno_to_regclass[ (REGNO) ]
+
+/* The class value for valid base registers. A base register is one used in
+   an address which is the register value plus a displacement.  */
+
+#define BASE_REG_CLASS GENERAL_REGS
+#define INDEX_REG_CLASS GENERAL_REGS
+
+/* Definitions for register eliminations.
+
+   This is an array of structures.  Each structure initializes one pair
+   of eliminable registers.  The "from" register number is given first,
+   followed by "to".  Eliminations of the same "from" register are listed
+   in order of preference.
+
+   We have two registers that can be eliminated on the ARC.  First, the
+   argument pointer register can always be eliminated in favor of the stack
+   pointer register or frame pointer register.  Secondly, the frame pointer
+   register can often be eliminated in favor of the stack pointer register.
+*/
+
+#define ELIMINABLE_REGS						\
+  {								\
+    { ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM },		\
+    { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM }, 	\
+    { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },      	\
+    { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM }  	\
+  }
+
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)		\
+  (OFFSET) = arc64_initial_elimination_offset (FROM, TO)
+
+/* RTL generation support.  */
+#define INIT_EXPANDERS arc64_init_expanders ()
+
+/* Stack layout; function entry, exit and calling.  */
+#define STACK_GROWS_DOWNWARD	1
+
+/* Addresses of local variables slots are at negative offsets from the
+   frame pointer.  */
+#define FRAME_GROWS_DOWNWARD	1
+
+/* If defined, the maximum amount of space required for outgoing
+   arguments will be computed and placed into the variable
+   `crtl->outgoing_args_size'.  No space will be pushed onto the stack
+   for each call; instead, the function prologue should increase the
+   stack frame size by this amount.  */
+#define ACCUMULATE_OUTGOING_ARGS	1
+
+/* Offset of first parameter from the argument pointer register
+   value.  */
+#define FIRST_PARM_OFFSET(FNDECL) 0
+
+/* Define how to find the value returned by a library function
+   assuming the value has mode MODE.  */
+#define LIBCALL_VALUE(MODE)						\
+  gen_rtx_REG (MODE, arc64_use_fp_regs (MODE) ? F0_REGNUM : R0_REGNUM)
+
+/* Tell GCC to use RETURN_IN_MEMORY.  */
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* WORD_REGISTER_OPERATIONS does not hold for arc64.  The assigned
+   word_mode is DImode but operations narrower than SImode behave as
+   32-bit operations.  */
+#define WORD_REGISTER_OPERATIONS 0
+
+/* Define if loading from memory in MODE, an integral mode narrower than
+   BITS_PER_WORD will either zero-extend or sign-extend.  The value of this
+   macro should be the code that says which one of the two operations is
+   implicitly done, or UNKNOWN if none.  */
+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND
+
+#define SLOW_BYTE_ACCESS 0
+
+#define NO_FUNCTION_CSE	1
+
+/* Conditional info.  */
+#define SELECT_CC_MODE(OP, X, Y) arc64_select_cc_mode (OP, X, Y)
+
+/* Restrictions apply to floating-point comparisons.  */
+#define REVERSIBLE_CC_MODE(MODE) ((MODE) != CC_FPUmode && (MODE) != CC_FPUEmode)
+
+/* Returning.  */
+#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, BLINK_REGNUM)
+
+#define RETURN_ADDR_RTX arc64_return_addr
+
+/* Define this to be nonzero if shift instructions ignore all but the
+   low-order few bits.  */
+#define SHIFT_COUNT_TRUNCATED 1
+
+/* Defines if the CLZ result is undefined or has a useful value.  */
+#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)			\
+  ((VALUE) = GET_MODE_SIZE((MODE)) * BITS_PER_UNIT - 1, 2)
+
+/* Defines if the CTZ result is undefined or has a useful value.  */
+#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)			\
+  ((VALUE) = GET_MODE_SIZE((MODE)) * BITS_PER_UNIT - 1, 2)
+
+/* Function argument passing.  */
+
+/* Define a data type for recording info about an argument list during
+   the scan of that argument list.  This data type should hold all
+   necessary information about the function itself and about the args
+   processed so far, enough to enable macros such as FUNCTION_ARG to
+   determine where the next arg should go.  */
+#define CUMULATIVE_ARGS struct arc64_args
+struct arc64_args
+{
+  /* Number of integer registers used so far.  */
+  int iregs;
+
+  /* Number of floating-point registers used so far.  */
+  int fregs;
+};
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS
+   for a call to a function whose data type is FNTYPE.
+   For a library call, FNTYPE is 0.  */
+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT,N_NAMED_ARGS) \
+  ((CUM).iregs = 0, (CUM).fregs = 0)
+
+/* Maximum bytes moved by a single instruction (load/store pair).  */
+#define MOVE_MAX (UNITS_PER_WORD)
+/* The threshold of number of scalar memory-to-memory move insns which
+   a sequence of insns should be generated instead of a string move
+   insn or a library call.  */
+#define MOVE_RATIO(SPEED) ((SPEED) ? 15 : 3)
+
+#ifndef USED_FOR_TARGET
+extern const enum reg_class arc64_regno_to_regclass[];
+#endif
+
+#define SIGNED(X,V)							\
+  ((unsigned long long) ((X) + (1ULL << (V - 1))) < (1ULL << V))
+#define UNSIGNED(X,V) ((unsigned long long) (X) < (1ULL << V))
+#define VERIFY_SHIFT(X,S) ((X & ((1 << S) - 1)) == 0)
+
+#define UNSIGNED_INT3(X) (UNSIGNED(X,3))
+#define UNSIGNED_INT5(X) (UNSIGNED(X,5))
+#define UNSIGNED_INT6(X) (UNSIGNED(X,6))
+#define UNSIGNED_INT7(X) (UNSIGNED(X,7))
+#define UNSIGNED_INT8(X) (UNSIGNED(X,8))
+#define UNSIGNED_INT9(X) (UNSIGNED(X,9))
+#define UNSIGNED_INT10(X) (UNSIGNED(X,10))
+#define UNSIGNED_INT12(X) (UNSIGNED(X,12))
+#define UNSIGNED_INT16(X) (UNSIGNED(X,16))
+// TODO: Fix for 32 bit compiler host architecture.
+#define UNSIGNED_INT32(X) (UNSIGNED(X,32))
+
+#define SIGNED_INT3(X) (SIGNED(X,3))
+#define SIGNED_INT6(X) (SIGNED(X,6))
+#define SIGNED_INT7(X) (SIGNED(X,7))
+#define SIGNED_INT8(X) (SIGNED(X,8))
+#define SIGNED_INT9(X) (SIGNED(X,9))
+#define SIGNED_INT10(X) (SIGNED(X,10))
+#define SIGNED_INT11(X) (SIGNED(X,11))
+#define SIGNED_INT12(X) (SIGNED(X,12))
+#define SIGNED_INT13(X) (SIGNED(X,13))
+#define SIGNED_INT16(X) (SIGNED(X,16))
+#define SIGNED_INT21(X) (SIGNED(X,21))
+#define SIGNED_INT25(X) (SIGNED(X,25))
+
+// TODO: Fix for 32 bit compiler host architecture.
+#define SIGNED_INT32(X) (SIGNED(X,32))
+
+#define UNSIGNED_INT7_SHIFTED(X,S) (VERIFY_SHIFT(X,S) && UNSIGNED_INT6(X >> S))
+#define UNSIGNED_INT8_SHIFTED(X,S) (VERIFY_SHIFT(X,S) && UNSIGNED_INT6(X >> S))
+#define UNSIGNED_INT9_SHIFTED(X,S) (VERIFY_SHIFT(X,S) && UNSIGNED_INT6(X >> S))
+
+#define SIGNED_INT13_SHIFTED(X,S) (VERIFY_SHIFT(X,S) && SIGNED_INT12(X >> S))
+#define SIGNED_INT14_SHIFTED(X,S) (VERIFY_SHIFT(X,S) && SIGNED_INT12(X >> S))
+#define SIGNED_INT15_SHIFTED(X,S) (VERIFY_SHIFT(X,S) && SIGNED_INT12(X >> S))
+
+
+/* These assume that REGNO is a hard or pseudo reg number.
+   They give nonzero only if REGNO is a hard reg of the suitable class
+   or a pseudo reg currently allocated to a suitable hard reg.
+   Since they use reg_renumber, they are safe only once reg_renumber
+   has been allocated, which happens in local-alloc.c.  */
+#define REGNO_OK_FOR_BASE_P(REGNO)					\
+  ((REGNO) < SP_REGNUM							\
+   || ((REGNO) == AP_REGNUM)						\
+   || ((REGNO) == SFP_REGNUM))
+
+#define REGNO_OK_FOR_INDEX_P(REGNO) REGNO_OK_FOR_BASE_P(REGNO)
+
+/* Return true if regno is FP register.  */
+#define FP_REGNUM_P(REGNO)						\
+  (((unsigned) (REGNO - F0_REGNUM)) <= (F31_REGNUM - F0_REGNUM))
+
+#define GP_REGNUM_P(REGNO)						\
+  (((unsigned) (REGNO - R0_REGNUM)) <= (BLINK_REGNUM - R0_REGNUM))
+
+/* Length in units of the trampoline for entering a nested function: 3
+   insns + 2 pointer-sized entries.  */
+#define TRAMPOLINE_SIZE (16+16)
+
+/* Alignment required for a trampoline in bits .  */
+#define TRAMPOLINE_ALIGNMENT 64
+
+/* Names to predefine in the preprocessor for this target machine.  */
+#define TARGET_CPU_CPP_BUILTINS() arc64_cpu_cpp_builtins (pfile)
+
+/* Dispatch tables.  */
+#define JUMP_TABLES_IN_TEXT_SECTION 1
+#define CASE_VECTOR_MODE SImode
+#define CASE_VECTOR_PC_RELATIVE 1
+#define ADDR_VEC_ALIGN(VEC_INSN) 0
+
+/* Define this macro if it is advisable to hold scalars in registers
+   in a wider mode than that declared by the program.  In such cases,
+   the value is constrained to be within the bounds of the declared
+   type, but kept valid in the wider mode.  The signedness of the
+   extension may differ from that of the type.  */
+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)	\
+  if (GET_MODE_CLASS (MODE) == MODE_INT		\
+      && GET_MODE_SIZE (MODE) < 4)		\
+    {						\
+      (MODE) = SImode;				\
+    }
+
+
+/* A C string constant describing how to begin a comment in the target
+   assembler language.  The compiler assumes that the comment will
+   end at the end of the line.  */
+#define ASM_COMMENT_START "#"
+
+#define ASM_OUTPUT_ALIGN(FILE,LOG) \
+  fprintf(FILE, "\t.align\t%d\n", 1 << (int)LOG)
+
+/* Output to assembler file text saying following lines
+   may contain character constants, extra white space, comments, etc.  */
+#undef ASM_APP_ON
+#define ASM_APP_ON ""
+
+/* Output to assembler file text saying following lines
+   no longer contain unusual constructs.  */
+#undef ASM_APP_OFF
+#define ASM_APP_OFF ""
+
+/* This is how to output a reference to a symbol_ref / label_ref as
+   (part of) an operand.  To disambiguate from register names like a1
+   / a2 / status etc, symbols are preceded by '@'.  */
+#define ASM_OUTPUT_SYMBOL_REF(FILE,SYM) \
+  ASM_OUTPUT_LABEL_REF ((FILE), XSTR ((SYM), 0))
+#define ASM_OUTPUT_LABEL_REF(FILE,STR)			\
+  do							\
+    {							\
+      fputs ("@", (FILE));				\
+      assemble_name ((FILE), (STR));			\
+    }							\
+  while (0)
+
+#define LOCAL_LABEL_PREFIX     "."
+
+/* This is how to output an element of a PIC case-vector. */
+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)	       \
+  fprintf (STREAM, "\tb\t@%sL%d\n",				       \
+          LOCAL_LABEL_PREFIX, VALUE)
+
+/* Defined to also emit an .align in elfos.h.  We don't want that.  */
+#undef ASM_OUTPUT_CASE_LABEL
+
+/* Section selection.  */
+
+/* Globalizing directive for a label.  */
+#define GLOBAL_ASM_OP "\t.global\t"
+
+#define TEXT_SECTION_ASM_OP	"\t.section\t.text"
+#define DATA_SECTION_ASM_OP	"\t.section\t.data"
+
+#define BSS_SECTION_ASM_OP	"\t.section\t.bss"
+#define SDATA_SECTION_ASM_OP	"\t.section\t.sdata"
+#define SBSS_SECTION_ASM_OP	"\t.section\t.sbss"
+
+/* Expression whose value is a string, including spacing, containing
+   the assembler operation to identify the following data as
+   initialization/termination code.  If not defined, GCC will assume
+   such a section does not exist. */
+#define INIT_SECTION_ASM_OP "\t.section\t.init"
+#define FINI_SECTION_ASM_OP "\t.section\t.fini"
+
+/* All the work done in PROFILE_HOOK, but still required.  */
+#undef FUNCTION_PROFILER
+#define FUNCTION_PROFILER(STREAM, LABELNO) do { } while (0)
+
+#define NO_PROFILE_COUNTERS  1
+
+/* Tell crtstuff.c we're using ELF.  */
+#define OBJECT_FORMAT_ELF
+
+/* Called by crtstuff.c to make calls to function FUNCTION that are defined in
+   SECTION_OP, and then to switch back to text section.  */
+#undef CRT_CALL_STATIC_FUNCTION
+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)		\
+  asm (SECTION_OP "\n\t"					\
+       "addl\tr12,pcl,@" USER_LABEL_PREFIX #FUNC "@pcl\n\t"	\
+       "jl\t[r12]\n"						\
+       TEXT_SECTION_ASM_OP);
+
+/* ATOMIC options.  */
+/* FIXME: is 0 okay or should it be -1 like DEFAULT_arc_mpy_option?  */
+/* Default atomic option value.  */
+#undef DEFAULT_ARC64_ATOMIC_OPTION
+#define DEFAULT_ARC64_ATOMIC_OPTION 1
+
+#define ARC64_HAS_ATOMIC_1 (arc64_atomic_option > 0)
+#define ARC64_HAS_ATOMIC_2 (arc64_atomic_option > 1)
+#define ARC64_HAS_ATOMIC_3 (arc64_atomic_option > 2)
+
+/* DIVREM options.  */
+#undef TARGET_ARC64_DIVREM_DEFAULT
+#define TARGET_ARC64_DIVREM_DEFAULT 1
+
+/* FP options.  */
+#define ARC64_HAS_FP_BASE (arc64_fp_model > 0)
+#define ARC64_HAS_FPUH    (arc64_fp_model > 0)
+#define ARC64_HAS_FPUS    (arc64_fp_model > 0)
+#define ARC64_HAS_FPUD    (arc64_fp_model > 1)
+
+/* Vector SIMD length.  */
+#define ARC64_VFP_32    (arc64_fp_model == 1)
+#define ARC64_VFP_64    ((arc64_fp_model == 2) && !TARGET_WIDE_SIMD)
+#define ARC64_VFP_128   ((arc64_fp_model == 2) && TARGET_WIDE_SIMD)
+
+/* IFCVT macros.  */
+#define STORE_FLAG_VALUE 1
+#define MAX_CONDITIONAL_EXECUTE 12
+#define BRANCH_COST(speed_p, predictable_p) 10
+
+/* DWARF macros.  */
+#define DWARF2_DEBUGGING_INFO 1
+/* The mapping from gcc register number to DWARF2 CFA column number.  */
+#define DWARF_FRAME_REGNUM(REGNO) DBX_REGISTER_NUMBER(REGNO)
+/* DWARF2 CFA column which tracks the return address.  */
+#define DWARF_FRAME_RETURN_COLUMN BLINK_REGNUM
+#define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, BLINK_REGNUM)
+/* DWARF registers encodings.  */
+#define DBX_REGISTER_NUMBER(REGNO) arc64_dbx_register_number (REGNO)
+
+
+/* Exception Handling support.  */
+/* Use R0 through R3 to pass exception handling information.  */
+#define EH_RETURN_DATA_REGNO(N) \
+  ((N) < 4 ? ((unsigned int) R0_REGNUM + (N)) : INVALID_REGNUM)
+#define EH_RETURN_STACKADJ_RTX	gen_rtx_REG (Pmode, R4_REGNUM)
+#define EH_RETURN_HANDLER_RTX  arc64_eh_return_handler_rtx ()
+#define EH_USES(REGNO) (arc64_eh_uses((REGNO)))
+
+/* Select a format to encode pointers in exception handling data.  */
+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \
+  arc64_asm_preferred_eh_data_format ((CODE), (GLOBAL))
+
+/* Specs.  */
+#define OPTION_DEFAULT_SPECS			\
+  { "fpu", "%{!mfpu=*:-mfpu=%(VALUE)}"}
+
+#define CPP_SPEC "%(subtarget_cpp_spec)"
+
+#define EXTRA_SPECS				      \
+  { "subtarget_cpp_spec",	SUBTARGET_CPP_SPEC }, \
+  SUBTARGET_EXTRA_SPECS
+
+#ifndef SUBTARGET_EXTRA_SPECS
+#define SUBTARGET_EXTRA_SPECS
+#endif
+
+#ifndef SUBTARGET_CPP_SPEC
+#define SUBTARGET_CPP_SPEC ""
+#endif
+
+#endif /* GCC_ARC64_H */
diff --git a/gcc/config/arc64/arc64.md b/gcc/config/arc64/arc64.md
new file mode 100644
index 00000000000..797569341b0
--- /dev/null
+++ b/gcc/config/arc64/arc64.md
@@ -0,0 +1,2429 @@
+;; Register numbers
+(define_constants
+  [
+    (R0_REGNUM		0)
+    (R1_REGNUM		1)
+    (R2_REGNUM		2)
+    (R3_REGNUM		3)
+    (R4_REGNUM		4)
+    (R5_REGNUM		5)
+    (R6_REGNUM		6)
+    (R7_REGNUM		7)
+    (R8_REGNUM		8)
+    (R9_REGNUM		9)
+    (R10_REGNUM		10)
+    (R11_REGNUM		11)
+    (R12_REGNUM		12)
+    (R13_REGNUM		13)
+    (R14_REGNUM		14)
+    (R15_REGNUM		15)
+    (R16_REGNUM		16)
+    (R17_REGNUM		17)
+    (R18_REGNUM		18)
+    (R19_REGNUM		19)
+    (R20_REGNUM		20)
+    (R21_REGNUM		21)
+    (R22_REGNUM		22)
+    (R23_REGNUM		23)
+    (R24_REGNUM		24)
+    (R25_REGNUM		25)
+    (R26_REGNUM		26)
+    (R27_REGNUM		27)
+    (SP_REGNUM		28)
+    (ILINK_REGNUM	29)
+    (R30_REGNUM		30)
+    (BLINK_REGNUM	31)
+    (R32_REGNUM		32)
+    (R33_REGNUM		33)
+    (R34_REGNUM		34)
+    (R35_REGNUM		35)
+    (R36_REGNUM		36)
+    (R37_REGNUM		37)
+    (R38_REGNUM		38)
+    (R39_REGNUM		39)
+    (R40_REGNUM		40)
+    (R41_REGNUM		41)
+    (R42_REGNUM		42)
+    (R43_REGNUM		43)
+    (R44_REGNUM		44)
+    (R45_REGNUM		45)
+    (R46_REGNUM		46)
+    (R47_REGNUM		47)
+    (R48_REGNUM		48)
+    (R49_REGNUM		49)
+    (R50_REGNUM		50)
+    (R51_REGNUM		51)
+    (R52_REGNUM		52)
+    (R53_REGNUM		53)
+    (R54_REGNUM		54)
+    (R55_REGNUM		55)
+    (R56_REGNUM		56)
+    (R57_REGNUM		57)
+    (R58_REGNUM		58)
+    (R59_REGNUM		59)
+
+    (F0_REGNUM		64)
+    (F1_REGNUM		65)
+    (F2_REGNUM		66)
+    (F3_REGNUM		67)
+    (F4_REGNUM		68)
+    (F5_REGNUM		69)
+    (F6_REGNUM		70)
+    (F7_REGNUM		71)
+    (F8_REGNUM		72)
+    (F9_REGNUM		73)
+    (F10_REGNUM		74)
+    (F11_REGNUM		75)
+    (F12_REGNUM		76)
+    (F13_REGNUM		77)
+    (F14_REGNUM		78)
+    (F15_REGNUM		79)
+    (F16_REGNUM		80)
+    (F17_REGNUM		81)
+    (F18_REGNUM		82)
+    (F19_REGNUM		83)
+    (F20_REGNUM		84)
+    (F21_REGNUM		85)
+    (F22_REGNUM		86)
+    (F23_REGNUM		87)
+    (F24_REGNUM		88)
+    (F25_REGNUM		89)
+    (F26_REGNUM		90)
+    (F27_REGNUM		91)
+    (F28_REGNUM		92)
+    (F29_REGNUM 	93)
+    (F30_REGNUM		94)
+    (F31_REGNUM 	95)
+
+    (AP_REGNUM		96)
+    (SFP_REGNUM		97)
+    (CC_REGNUM		98)
+  ]
+  )
+
+(define_c_enum "unspec"
+  [
+   ARC64_UNSPEC_PCREL
+   ARC64_UNSPEC_GOT
+   ARC64_UNSPEC_GOT32
+   ARC64_UNSPEC_TLS_GD
+   ARC64_UNSPEC_TLS_IE
+   ARC64_UNSPEC_TLS_OFF
+   ARC64_VUNSPEC_BLOCKAGE
+
+   ARC64_VUNSPEC_LR
+   ARC64_VUNSPEC_SR
+   ARC64_VUNSPEC_LRL
+   ARC64_VUNSPEC_SRL
+   ARC64_VUNSPEC_FLAG
+   ARC64_VUNSPEC_BRK
+   ARC64_VUNSPEC_NOP
+   ARC64_VUNSPEC_TRAP_S
+
+   ARC64_VUNSPEC_EX
+   ARC64_VUNSPEC_CAS
+   ARC64_VUNSPEC_SC
+   ARC64_VUNSPEC_LL
+   ARC64_VUNSPEC_SYNC
+   ARC64_VUNSPEC_ATOOPS
+
+   ARC64_UNSPEC_MEMBAR
+   ARC64_UNSPEC_FLS
+   ARC64_UNSPEC_COPYSIGN
+   ARC64_UNSPEC_XORSIGN
+   ARC64_UNSPEC_ROUND
+   ARC64_UNSPEC_BTRUNC
+   ARC64_UNSPEC_CASESI
+   ARC64_UNSPEC_VECINIT
+   ARC64_UNSPEC_QMPYH
+   ARC64_UNSPEC_QMACH
+   ARC64_UNSPEC_DMPYWH
+   ARC64_UNSPEC_VPACK4HL
+   ARC64_UNSPEC_VPACK4HM
+   ARC64_UNSPEC_VPACK2WL
+   ARC64_UNSPEC_SWAPL
+   ARC64_UNSPEC_SWAP
+   ARC64_UNSPEC_VEC_SHR
+   ARC64_UNSPEC_VEC_SHL
+   ])
+
+(include "constraints.md")
+(include "predicates.md")
+
+;; -------------------------------------------------------------------
+;; Mode Iterators
+;; -------------------------------------------------------------------
+
+;; Iterator for General Purpose Integer registers (32- and 64-bit modes)
+(define_mode_iterator GPI [SI DI])
+
+;; Iterator for QI and HI modes
+(define_mode_iterator SHORT [QI HI])
+
+;; Iterator for QI HI and SI modes
+(define_mode_iterator EXT [QI HI SI])
+
+;; Iterator for all integer modes (up to 64-bit)
+(define_mode_iterator ALLI [QI HI SI DI])
+
+;; Iterator for HI SI and DI modes
+(define_mode_iterator EPI [HI SI DI])
+
+;; This mode iterator allows :P to be used for patterns that operate on
+;; pointer-sized quantities.  Exactly one of the two alternatives will match.
+(define_mode_iterator P [(SI "Pmode == SImode") (DI "Pmode == DImode")])
+
+;; Iterator for General Purpose Floating-point registers (16 -, 32-
+;; and 64-bit modes)
+(define_mode_iterator GPF_HF [(HF "ARC64_HAS_FPUH")
+			      (SF "ARC64_HAS_FPUS") (DF "ARC64_HAS_FPUD")])
+
+;; Iterator for General Purpose Floating-point registers (32- and 64-bit modes)
+(define_mode_iterator GPF [(SF "ARC64_HAS_FPUS") (DF "ARC64_HAS_FPUD")])
+
+;; All int vectors
+(define_mode_iterator VALL [V2HI V4HI V2SI])
+
+;; All 64b int vectors
+(define_mode_iterator V64I [V2HI V4HI V2SI])
+
+;; All fp vectors
+(define_mode_iterator VALLF [(V2HF "ARC64_VFP_32")
+			     (V4HF "ARC64_VFP_64") (V2SF "ARC64_VFP_64")
+			     (V8HF "ARC64_VFP_128") (V4SF "ARC64_VFP_128")
+			     (V2DF "ARC64_VFP_128")])
+
+;; ALl fp vectors up to 64bit
+(define_mode_iterator VALLF_64 [(V2HF "ARC64_VFP_32")
+				(V4HF "ARC64_VFP_64") (V2SF "ARC64_VFP_64")])
+
+;; All 128b fp vectos
+(define_mode_iterator VALLF_128 [(V8HF "ARC64_VFP_128") (V4SF "ARC64_VFP_128")
+				 (V2DF "ARC64_VFP_128")])
+
+;; All 2xfp Vectors
+(define_mode_iterator V2xF [(V2HF "ARC64_VFP_32") (V2SF "ARC64_VFP_64")
+			    (V2DF "ARC64_VFP_128")])
+
+;; All 4xfp Vectors
+(define_mode_iterator V4xF [(V4HF "ARC64_VFP_64") (V4SF "ARC64_VFP_128")])
+
+;; All 2xreg wide vectors
+;; All 2xfp Vectors
+(define_mode_iterator W2xF [(V2DF "ARC64_VFP_128")])
+
+;; -------------------------------------------------------------------
+;; Code Iterators
+;; -------------------------------------------------------------------
+
+;; Code iterator for sign/zero extension
+(define_code_iterator ANY_EXTEND [sign_extend zero_extend])
+
+;; This code iterator allows the shifts supported in arithmetic instructions
+(define_code_iterator ASHIFT [ashift ashiftrt lshiftrt])
+
+;; Iterates over the SETcc instructions
+(define_code_iterator SETCC [eq ne gt lt ge le ltu geu])
+(define_code_iterator ALLCC [eq ne gt lt ge le ltu geu gtu leu])
+
+;; Three operand arithmetic operations
+(define_code_iterator ARITH [plus minus mult])
+
+;; Three operand logic operations
+(define_code_iterator LOGIC [and ior xor smin smax])
+
+;; Two operand logic operations
+(define_code_iterator LOGIC2 [not abs])
+
+;; Two operand logic operations extended, used for zero_extend
+;; patterns
+(define_code_iterator LOP2EX [not abs neg])
+
+;; Min/Max iterator
+(define_code_iterator MINMAX [smin smax])
+
+;; Three operand floating point arithmetic instructions
+(define_code_iterator DOPF [plus minus mult div smin smax])
+
+;; Vector operations
+(define_code_iterator VOPS [plus minus mult div])
+
+;; Comutative VF operations
+(define_code_iterator VCOP [plus mult])
+
+;; Emulated 2 operand vector operations
+(define_code_iterator EV2OP [smin smax])
+
+;; Emulated 1 operand vector operations
+(define_code_iterator EV1OP [abs neg])
+
+;; -------------------------------------------------------------------
+;; Mode Attributes
+;; -------------------------------------------------------------------
+
+;; Map rtl mode to ARC mnemonic suffixes used in sign extend
+;; instructions.
+(define_mode_attr exttab [(QI "b") (HI "h") (SI "w")])
+
+;; Map rtl mode to ARC mnemonic suffixes
+(define_mode_attr sfxtab [(QI "b") (HI "h") (SI "") (DI "l")
+			  (HF "h") (SF "s") (DF "d")
+			  (V2HI "2h") (V4HI "4h") (V2SI "2")
+			  (V2HF "h") (V4HF "h") (V2SF "s")
+			  (V8HF "h") (V4SF "s") (V2DF "d")])
+
+;; Used by FPABS patterns.
+(define_mode_attr fptab [(SF "") (DF "l")])
+
+;; Same as above but to be used by mov conditional
+(define_mode_attr mcctab [(QI "") (HI "") (SI "") (DI "l")
+			  (HF "") (SF "") (DF "l")
+			  (V2HI "") (V4HI "l") (V2SI "l")
+			  (V2HF "") (V4HF "l") (V2SF "l")])
+
+(define_mode_attr slfp [(HF "h") (SF "") (DF "l")
+			(V2HF "") (V4HF "l") (V2SF "l")])
+
+(define_mode_attr fmvftab [(HF "s") (SF "s") (DF "d")
+			   (V2HF "s") (V4HF "d") (V2SF "d")])
+(define_mode_attr fmvitab [(HF "i") (SF "i") (DF "l")
+			   (V2HF "i") (V4HF "l") (V2SF "l")])
+
+;; Give the number of bits-1 in the mode
+(define_mode_attr sizen [(QI "7") (HI "15") (SI "31") (DI "63")
+			 (HF "15") (SF "31") (DF "63")])
+
+;; Same like above but without -1 used for fp loads/stores
+(define_mode_attr sizef [(HF "16") (SF "32") (DF "64")
+			 (V2HF "32") (V4HF "64") (V2SF "64")
+			 (V8HF "128") (V4SF "128") (V2DF "128")])
+
+;; Used by float conv patterns.
+(define_mode_attr f2tab [(SI "int") (DI "l")])
+
+;; Define element mode for each vector mode.
+(define_mode_attr VEL [(V2HI "HI") (V4HI "HI") (V2SI "SI")
+		       (V2HF "HF") (V4HF "HF") (V2SF "SF")
+		       (V8HF "HF") (V4SF "SF") (V2DF "DF")])
+(define_mode_attr vel [(V2HI "hi") (V4HI "hi") (V2SI "si")
+		       (V2HF "hf") (V4HF "hf") (V2SF "sf")
+		       (V8HF "hf") (V4SF "sf") (V2DF "df")])
+
+;; Used by vector extract pattern
+(define_mode_attr vextrsz [(V2HI "16") (V4HI "16") (V2SI "32")])
+(define_mode_attr vextrmsk [(V2HI "0x1f") (V4HI "0x3f") (V2SI "0x3f")])
+(define_mode_attr vextrsh [(V2HI "5") (V4HI "6") (V2SI "6")])
+
+;; -------------------------------------------------------------------
+;; Code Attributes
+;; -------------------------------------------------------------------
+;; Map rtl objects to optab names
+(define_code_attr optab [(ashift "ashl")
+			 (ashiftrt "ashr")
+			 (lshiftrt "lshr")
+			 (rotatert "rotr")
+			 (sign_extend "extend")
+			 (zero_extend "zero_extend")
+			 (sign_extract "extv")
+			 (zero_extract "extzv")
+			 (fix "fix")
+			 (unsigned_fix "fixuns")
+			 (float "float")
+			 (unsigned_float "floatuns")
+			 (popcount "popcount")
+			 (and "and")
+			 (ior "ior")
+			 (xor "xor")
+			 (not "one_cmpl")
+			 (neg "neg")
+			 (plus "add")
+			 (minus "sub")
+			 (mult "mul")
+			 (div "div")
+			 (udiv "udiv")
+			 (mod "mod")
+			 (umod "umod")
+			 (ss_plus "qadd")
+			 (us_plus "qadd")
+			 (ss_minus "qsub")
+			 (us_minus "qsub")
+			 (ss_neg "qneg")
+			 (ss_abs "qabs")
+			 (smin "smin")
+			 (smax "smax")
+			 (umin "umin")
+			 (umax "umax")
+			 (eq "eq")
+			 (ne "ne")
+			 (lt "lt")
+			 (ge "ge")
+			 (le "le")
+			 (gt "gt")
+			 (ltu "ltu")
+			 (leu "leu")
+			 (geu "geu")
+			 (gtu "gtu")
+			 (abs "abs")
+			 (sqrt "sqrt")])
+
+;; map rtl to ARC's cc-mnemonic names, slightly different than above.
+(define_code_attr cctab [(eq "eq")
+			 (ne "ne")
+			 (lt "lt")
+			 (ge "ge")
+			 (le "le")
+			 (gt "gt")
+			 (ltu "lo")
+			 (leu "NA")
+			 (geu "hs")
+			 (gtu "NA")])
+
+;; Sign- or zero-extend data-op
+(define_code_attr su [(sign_extend "s") (zero_extend "u")])
+
+;; Optab prefix for sign/zero-extending operations
+(define_code_attr su_optab [(sign_extend "") (zero_extend "u")])
+
+;; Map rtl objects to arc instuction names
+(define_code_attr mntab [(abs "abs")
+			 (not "not")
+			 (neg "neg")
+			 (ashift   "asl")
+			 (ashiftrt "asr")
+			 (sign_extend "sex")
+			 (zero_extend "ext")
+			 (div      "div")
+			 (udiv     "divu")
+			 (mult     "mul")
+			 (mod      "rem")
+			 (umod     "remu")
+			 (lshiftrt "lsr")
+			 (and      "and")
+			 (ior      "or")
+			 (xor      "xor")
+			 (plus     "add")
+			 (minus    "sub")
+			 (smax      "max")
+			 (smin      "min")])
+
+;; -------------------------------------------------------------------
+;; Int Iterators.
+;; -------------------------------------------------------------------
+
+;; -------------------------------------------------------------------
+;; Instruction types and attributes
+;; -------------------------------------------------------------------
+
+;; What is the insn_cost for this insn?  The target hook can still override
+;; this.  For optimizing for size the "length" attribute is used instead.
+(define_attr "cost" "" (const_int 0))
+
+(define_attr "type" "abs, adcl, add, addhl, addl, and, andl, asl,
+asll, asr, asrl, atldop, atldlop, bclr, bic, bl, block, bmsk, branch,
+branchcc, brk, bset, bsetl, btst, bxor, bxorl, compare, dbnz, dmb,
+dmpywh, ex, div, divl, ext, fadd, fcmp, fsub, fmul, fdiv, fh2s, fmin,
+fmax, fsgnj, fsgnjx, fsgnjn, fmadd, fmov, fmsub, fnmadd, fnmsub,
+fsqrt, frnd, fs2d, fs2h, fd2s, int2fp, uint2fp, fp2int, fp2uint, ffs,
+fls, flag, jl, jump, ld, llock, lsr, lsrl, lr, max, maxl, min, minl,
+move, movecc, mod, modl, neg, nop, norm, normh, norml, mpy, mpyl, not,
+notl, or, orl, return, ror,rol, sbcl, scond, setcc, sex, sr, st, sub,
+subl, swap, swapl, swape, swapel, sync, trap, qmach, qmpyh, udiv,
+udivl, umod, umodl, unknown, vadd, vsub, vmac2h, vmpy2h, vfadd, vfext,
+vfins, vfsub, vfmul, vfdiv, vfrep, vpack, xbfu, xor, xorl"
+  (const_string "unknown"))
+
+(define_attr "iscompact" "yes,no,maybe" (const_string "no"))
+
+(define_attr "predicable" "yes,no" (const_string "no"))
+
+(define_attr "length" ""
+  (cond
+   [(eq_attr "iscompact" "yes")
+    (const_int 2)
+
+    (eq_attr "type" "ld")
+    (if_then_else
+     (match_operand 1 "limm_ldst_operand" "")
+     (const_int 8) (const_int 4))
+
+    (eq_attr "type" "st")
+    (if_then_else
+     (ior (match_operand 0 "limm_ldst_operand" "")
+	  (and (not (match_operand 1 "S06S0_immediate_operand" ""))
+	       (match_operand 1 "immediate_operand" "")))
+     (const_int 8) (const_int 4))
+
+    (eq_attr "iscompact" "maybe")
+    (cond
+     [(match_test "GET_CODE (PATTERN (insn)) == COND_EXEC")
+      (const_int 4)
+
+      (eq_attr "type" "and")
+      (const_int 2)
+
+      (eq_attr "type" "or")
+      (const_int 2)
+
+      (match_operand:DI 0 "" "")
+      (const_int 4)
+      ]
+     (const_int 2))
+    ]
+   (const_int 8)))
+
+;; Select various CPU features.
+(define_attr "cpu_facility" "std,cd,ncd"
+  (const_string "std"))
+
+(define_attr "enabled" "no,yes"
+  (cond [(and (eq_attr "cpu_facility" "cd")
+	      (not (match_test ("TARGET_CODE_DENSITY"))))
+	 (const_string "no")
+	 (and (eq_attr "cpu_facility" "ncd")
+	      (match_test ("TARGET_CODE_DENSITY")))
+	 (const_string "no")
+        ]
+       (const_string "yes")))
+
+;; -------------------------------------------------------------------
+;; Pipeline descriptions and scheduling
+;; -------------------------------------------------------------------
+
+;; -------------------------------------------------------------------
+;; Moves
+;; -------------------------------------------------------------------
+
+(define_expand "mov<mode>"
+  [(set (match_operand:ALLI 0 "nonimmediate_operand")
+	(match_operand:ALLI 1 "general_operand"))]
+  ""
+  "
+  if (arc64_prepare_move_operands (operands[0], operands[1], <MODE>mode))
+    DONE;
+  "
+  )
+
+(define_expand "movti"
+  [(set (match_operand:TI 0 "nonimmediate_operand")
+	(match_operand:TI 1 "general_operand"))]
+  "TARGET_WIDE_LDST"
+  "
+  if (arc64_prepare_move_operands (operands[0], operands[1], TImode))
+    DONE;
+  "
+  )
+
+;; We use movsf for soft and hard floats.
+(define_expand "movsf"
+  [(set (match_operand:SF 0 "nonimmediate_operand" "")
+	(match_operand:SF 1 "general_operand"))]
+  ""
+  {
+   if (arc64_prepare_move_operands (operands[0], operands[1], SFmode))
+      DONE;
+   })
+
+(define_expand "movhf"
+  [(set (match_operand:HF 0 "nonimmediate_operand" "")
+	(match_operand:HF 1 "general_operand"))]
+  "ARC64_HAS_FPUH"
+  {
+   if (arc64_prepare_move_operands (operands[0], operands[1], HFmode))
+      DONE;
+   })
+
+(define_expand "movdf"
+  [(set (match_operand:DF 0 "nonimmediate_operand" "")
+	(match_operand:DF 1 "general_operand"))]
+  "ARC64_HAS_FPUD"
+  {
+   if (arc64_prepare_move_operands (operands[0], operands[1], DFmode))
+      DONE;
+   })
+
+;; mov<.f>        b, c
+;; mov<.f>        b, s12
+;; mov_s          b, u8
+;; mov_s          g, h
+;; mov_s          h, s3
+;;
+;; ld             a, [b, s9]
+;; ld             a, [b,  c]
+;; ld             a, [limm ]
+;;
+;; ldb_s          a, [b,  c]
+;; ldb_s          c, [b,  u5]
+;;
+;; st<zz>         c   , [b , s9]
+;; st<zz>         limm, [b , s9]
+;; stb_s          b   , [sp, u7]
+;; stb_s          c   , [b , u5]
+(define_insn "*arc64_movqi"
+  [(set
+    (match_operand:QI 0 "arc64_dest_operand"   "=qh,    q, r,    q,Ustms,    m, Ucnst, r, m")
+    (match_operand:QI 1 "general_operand" " qhS03MV,U08S0,ri,Uldms,    q,S06S0,     i, m, r"))
+   ]
+   ; in general, at least one of the operands must be a register
+   "register_operand (operands[0], QImode)
+   || register_operand (operands[1], QImode)
+   /* this is to match 'stb w6, [limm]' (S06S0 is the w6).  */
+   || (satisfies_constraint_S06S0 (operands[1])
+       && memory_operand (operands[0], QImode))
+   /* writing a byte into memory using limm variant.  */
+   || (immediate_operand (operands[1], QImode)
+       && memory_operand (operands[0], QImode))"
+   "@
+    mov_s\\t%0,%1
+    mov_s\\t%0,%1
+    mov\\t%0,%1
+    ldb_s\\t%0,%1
+    stb_s\\t%1,%0
+    stb%U0\\t%1,%0
+    stb%U0\\t%1,%0
+    ldb%U1\\t%0,%1
+    stb%U0\\t%1,%0"
+   [(set_attr "type" "move,move,move,ld,st,st,st,ld,st")
+    (set_attr "length" "2,2,4,2,2,*,8,*,*")]
+)
+
+(define_insn "*arc64_movhi"
+  [(set
+    (match_operand:HI 0 "arc64_dest_operand"  "=qh,r,    q,    r,h,r,   q,Ustms,    m,Ucnst, r, m")
+    (match_operand:HI 1 "general_operand" "qhS03MV,r,U08S0,S12S0,i,i,Uldms,   q,S06S0,    i, m, r"))
+   ]
+  "register_operand (operands[0], HImode)
+   || register_operand (operands[1], HImode)
+   || (satisfies_constraint_S06S0 (operands[1])
+       && memory_operand (operands[0], HImode))"
+   "@
+    mov_s\\t%0,%1
+    mov\\t%0,%1
+    mov_s\\t%0,%1
+    mov\\t%0,%1
+    mov_s\\t%0,%1
+    mov\\t%0,%1
+    ldh_s\\t%0,%1
+    sth_s\\t%1,%0
+    sth%U0\\t%1,%0
+    sth%U0\\t%1,%0
+    ldh%U1\\t%0,%1
+    sth%U0\\t%1,%0"
+   [(set_attr "type" "move,move,move,move,move,move,ld,st,st,st,ld,st")
+    (set_attr "length" "2,4,2,4,6,8,2,2,*,8,*,*")]
+)
+
+(define_insn "*arc64_movsi"
+  [(set
+    (match_operand:SI 0 "arc64_dest_operand"  "=qh,r,    q,    r,h,r,    q,Ustms,    m,Ucnst, r, m")
+    (match_operand:SI 1 "general_operand" "qhS03MV,r,U08S0,S12S0,i,i,Uldms,    q,S06S0,    i, m, r"))
+   ]
+  "register_operand (operands[0], SImode)
+   || register_operand (operands[1], SImode)
+   || (satisfies_constraint_S06S0 (operands[1])
+       && memory_operand (operands[0], SImode))"
+   "@
+    mov_s\\t%0,%1
+    mov\\t%0,%1
+    mov_s\\t%0,%1
+    mov\\t%0,%1
+    mov_s\\t%0,%1
+    mov\\t%0,%1
+    ld_s\\t%0,%1
+    st_s\\t%1,%0
+    st%U0\\t%1,%0
+    st%U0\\t%1,%0
+    ld%U1\\t%0,%1
+    st%U0\\t%1,%0"
+   [(set_attr "type" "move,move,move,move,move,move,ld,st,st,st,ld,st")
+    (set_attr "length" "2,4,2,4,6,8,2,2,*,8,*,*")]
+)
+
+(define_insn "*mov<mode>_cmp0"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN (match_operand:ALLI 1 "register_operand" "r")
+		       (const_int 0)))
+   (set (match_operand:ALLI 0 "register_operand" "=r") (match_dup 1))]
+  ""
+  "mov<mcctab>.f\\t%0,%1"
+  [(set_attr "type" "move")
+   (set_attr "length" "4")])
+
+;; Softcore float move.
+(define_insn "*movsf_softfp"
+   [(set (match_operand:SF 0 "arc64_dest_operand" "=qh,r,qh,r,    q,Ustms,r,m")
+	 (match_operand:SF 1 "general_operand"    "qhZ,r, E,E,Uldms,    q,m,r"))
+   ]
+   "!ARC64_HAS_FP_BASE
+   && (register_operand (operands[0], SFmode)
+       || register_operand (operands[1], SFmode))"
+   "@
+    mov_s\\t%0,%1
+    mov\\t%0,%1
+    mov_s\\t%0,%1
+    mov\\t%0,%1
+    ld_s\\t%0,%1
+    st_s\\t%1,%0
+    ld%U1\\t%0,%1
+    st%U0\\t%1,%0"
+   [(set_attr "type" "move,move,move,move,ld,st,ld,st")
+    (set_attr "length" "2,4,6,8,2,2,*,*")])
+
+;; For a fp move I use FSMOV.<cc> instruction. However, we can also
+;; use FSSGNJ.
+;; FIXME! add short instruction selection
+(define_insn "*mov<mode>_hardfp"
+  [(set (match_operand:GPF_HF 0 "arc64_dest_operand" "=w,    w,Ufpms,*r,*w,*r,*r,*r,*m")
+	(match_operand:GPF_HF 1 "arc64_movf_operand"     "w,Ufpms,    w,*w,*r,*r,*G,*m,*r"))]
+  "ARC64_HAS_FP_BASE
+   && (register_operand (operands[0], <MODE>mode)
+       || register_operand (operands[1], <MODE>mode))"
+  "@
+   f<sfxtab>mov\\t%0,%1
+   fld<sizef>%U1\\t%0,%1
+   fst<sizef>%U0\\t%1,%0
+   fmv<fmvftab>2<fmvitab>\\t%0,%1
+   fmv<fmvitab>2<fmvftab>\\t%0,%1
+   mov<mcctab>\\t%0,%1
+   mov<mcctab>\\t%0,%1
+   ld<slfp>%U1\\t%0,%1
+   st<slfp>%U0\\t%1,%0"
+  [(set_attr "type" "fmov,ld,st,move,move,move,move,ld,st")
+   (set_attr "length" "4,*,*,4,4,4,8,*,*")])
+
+(define_insn "*arc64_push"
+  [(set (mem:DI (pre_dec (reg:DI SP_REGNUM)))
+	(                 match_operand:DI 0 "register_operand" "qr"))]
+   ""
+   "pushl_s\\t%0"
+   [(set_attr "type" "st")
+    (set_attr "length" "2")])
+
+(define_insn "*arc64_pop"
+  [(set (                  match_operand:DI 0 "register_operand" "=qr")
+	(mem:DI (post_inc (reg:DI SP_REGNUM))))]
+  ""
+  "popl_s\\t%0"
+  [(set_attr "type" "ld")
+   (set_attr "length" "2")])
+
+;; move 128bit
+(define_insn_and_split "*arc64_movti"
+  [(set (match_operand:TI 0 "arc64_dest_operand"  "=r,r,m")
+	(match_operand:TI 1 "nonimmediate_operand" "r,m,r"))]
+  "TARGET_WIDE_LDST
+   && (register_operand (operands[0], TImode)
+       || register_operand (operands[1], TImode))"
+  "@
+   #
+   lddl%U1\\t%0,%1
+   stdl%U0\\t%1,%0"
+   "&& reload_completed
+    && arc64_simd64x_split_move_p (operands, TImode)"
+   [(const_int 0)]
+   {
+    arc64_simd128_split_move (operands, TImode);
+    DONE;
+   }
+  [(set_attr "type" "move,ld,st")
+   (set_attr "length" "8,*,*")])
+;;
+;; Short insns: movl_s g,h; movl_s b,u8
+;; Long insns: movl, stl, ldl
+;;
+(define_insn "*arc64_movdi"
+   [(set (match_operand:DI 0 "arc64_dest_operand" "=qh,    q,r,    r,         r,    r,r, m")
+	 (match_operand:DI 1 "arc64_movl_operand"  "qh,U08S0,r,S12S0,S32S0SymMV,SyPic,m, r"))]
+   "register_operand (operands[0], DImode)
+    || register_operand (operands[1], DImode)"
+   "@
+    movl_s\\t%0,%1
+    movl_s\\t%0,%1
+    movl\\t%0,%1
+    movl\\t%0,%1
+    movl\\t%0,%1
+    addl\\t%0,pcl,%1
+    ldl%U1\\t%0,%1
+    stl%U0\\t%1,%0"
+   [(set_attr "type" "move,move,move,move,move,addl,ld,st")
+    (set_attr "length" "2,2,4,4,8,8,*,*")]
+)
+
+;; Hi/Low moves for constant and symbol loading.
+
+(define_insn "*movdi_high"
+  [(set (match_operand:DI 0 "register_operand"   "=   r,   qh,    r,r")
+	(high:DI
+	 (match_operand:DI 1 "arc64_immediate_or_pic" "S12S0,SymIm,SymIm,SyPic")))]
+  ""
+  "@
+   movhl\\t%0,%h1
+   movhl_s\\t%0,%h1
+   movhl\\t%0,%h1
+   addhl\\t%0,pcl,%h1"
+  [(set_attr "type" "move")
+   (set_attr "length" "4,6,8,8")])
+
+;; The immediates are already trimmed to fit the 32 bit limm field.
+(define_insn "*movdi_high"
+  [(set (match_operand:DI 0 "register_operand"            "=     r,   qh,    r")
+	(ashift:DI (match_operand:DI 1 "nonmemory_operand" "rS12S0,S32S0,S32S0")
+		   (const_int 32)))]
+  ""
+  "@
+   movhl\\t%0,%1
+   movhl_s\\t%0,%1
+   movhl\\t%0,%1"
+  [(set_attr "type" "move")
+   (set_attr "length" "4,6,8")])
+
+;; N.B. All immediates needs to be unsiged to endup at most in u32.
+(define_insn "*movdi_lo_sum_iori"
+  [(set (match_operand:DI 0 "register_operand"            "=q,    r,    h,    r")
+	(lo_sum:DI (match_operand:DI 1 "register_operand"  "0,    0,    0,    r")
+		   (match_operand:DI 2 "immediate_operand" "q,U10S0,SymIm,SymIm")))]
+  ""
+  "@
+   orl%?\\t%0,%1,%2
+   orl%?\\t%0,%1,%L2
+   orl%?\\t%0,%1,%L2
+   orl%?\\t%0,%1,%L2"
+  [(set_attr "type" "or")
+   (set_attr "iscompact" "yes,no,yes,no")
+   (set_attr "length" "2,4,6,8")])
+
+(define_insn "*adddi_high"
+  [(set (match_operand:DI 0 "register_operand"          "=    qh,    r,    r,r,     r")
+	(plus:DI (match_operand:DI 1 "register_operand"   "    0,    0,    r,r,     r")
+		 (high:DI
+		  (match_operand:DI 2 "nonmemory_operand" "S32S0,S12S0,U06S0,r,S32S0"))))]
+  ""
+  "@
+   addhl_s\\t%0,%1,%2
+   addhl\\t%0,%1,%2
+   addhl\\t%0,%1,%2
+   addhl\\t%0,%1,%2
+   addhl\\t%0,%1,%2"
+  [(set_attr "type" "addhl")
+   (set_attr "iscompact" "yes,no,no,no,no")
+   (set_attr "length" "6,4,4,4,8")])
+
+; conditional execution patterns
+(define_insn "*mov<mode>_ce"
+  [(cond_exec
+    (match_operator 3 "arc64_comparison_operator"
+		    [(match_operand 2 "cc_register" "") (const_int 0)])
+   (set (match_operand:ALLI 0 "register_operand"  "=    r,r")
+	(match_operand:ALLI 1 "nonmemory_operand" "rU06S0,S32S0")))]
+  ""
+  "mov<mcctab>.%m3\\t%0,%1"
+  [(set_attr "type" "move")
+   (set_attr "length" "4,8")])
+
+(define_insn "*mov<mode>_ce"
+  [(cond_exec
+    (match_operator 3 "arc64_comparison_operator"
+		    [(match_operand 2 "cc_register" "") (const_int 0)])
+   (set (match_operand:GPF_HF 0 "register_operand"  "=w,*r,*r")
+	(match_operand:GPF_HF 1 "nonmemory_operand"  "w,*r,*E")))]
+  ""
+  "@
+  f<sfxtab>mov.%m3\\t%0,%1
+  mov<mcctab>.%m3\\t%0,%1
+  mov<mcctab>.%m3\\t%0,%1"
+  [(set_attr "type" "fmov,move,move")
+   (set_attr "length" "4,4,8")])
+
+;; -------------------------------------------------------------------
+;; Subroutine calls and sibcalls
+;; -------------------------------------------------------------------
+
+(define_expand "call"
+  [(parallel [(call (match_operand 0 "memory_operand")
+		    (match_operand 1 "general_operand"))
+	      (use (match_operand 2 "" ""))
+	     (clobber (reg:DI BLINK_REGNUM))])]
+  ""
+  {
+   arc64_expand_call (NULL_RTX, operands[0], false);
+   DONE;
+  }
+)
+
+(define_insn "*call_insn"
+  [(call (mem:DI (match_operand:DI 0 "arc64_call_insn_operand" "q,r,BLsym,S12S0,S32S0"))
+	 (match_operand 1 "" ""))
+   (clobber (reg:DI BLINK_REGNUM))]
+  ""
+  "@
+   jl_s\\t[%0]
+   jl\\t[%0]
+   bl\\t%C0
+   jl\\t%0
+   jl\\t%0"
+  [(set_attr "type" "jl,jl,bl,jl,jl")
+   (set_attr "length" "2,4,4,4,8")])
+
+(define_expand "call_value"
+  [(parallel [(set (match_operand 0 "" "")
+		   (call (match_operand 1 "memory_operand")
+			 (match_operand 2 "general_operand")))
+	      (use (match_operand 3 "" ""))
+	      (clobber (reg:DI BLINK_REGNUM))])]
+  ""
+  "
+  {
+    arc64_expand_call (operands[0], operands[1], false);
+    DONE;
+  }"
+)
+
+(define_insn "*call_value_insn"
+  [(set (match_operand 0 "" "")
+	(call (mem:DI (match_operand:DI 1 "arc64_call_insn_operand"
+					"q,r,BLsym,S12S0,S32S0"))
+	      (match_operand 2 "" "")))
+   (clobber (reg:DI BLINK_REGNUM))]
+  ""
+  "@
+   jl_s\\t[%1]
+   jl\\t[%1]
+   bl\\t%C1
+   jl\\t%1
+   jl\\t%1"
+  [(set_attr "type" "jl,jl,bl,jl,jl")
+   (set_attr "length" "2,4,4,4,8")])
+
+(define_expand "sibcall"
+  [(parallel [(call (match_operand 0 "memory_operand")
+		    (match_operand 1 "general_operand"))
+	      (return)
+	      (use (match_operand 2 "" ""))])]
+  ""
+  {
+    arc64_expand_call (NULL_RTX, operands[0], true);
+    DONE;
+  }
+  )
+
+(define_expand "sibcall_value"
+  [(parallel [(set (match_operand 0 "" "")
+		   (call (match_operand 1 "memory_operand")
+			 (match_operand 2 "general_operand")))
+	      (return)
+	      (use (match_operand 3 "" ""))])]
+  ""
+  {
+    arc64_expand_call (operands[0], operands[1], true);
+    DONE;
+  }
+)
+
+;FIXME! add short variant for jump
+(define_insn "*sibcall_insn"
+  [(call
+    (mem:DI
+     (match_operand:DI 0 "arc64_call_insn_operand" "Sbreg,BLsym,S12S0,S32S0"))
+    (match_operand 1 "" ""))
+  (return)]
+  "SIBLING_CALL_P (insn)"
+  "@
+   j\\t[%0]
+   b\\t%C0
+   j\\t%0
+   j\\t%0"
+  [(set_attr "type" "jump,branch,jump,jump")
+   (set_attr "length" "4,4,4,8")]
+)
+
+;FIXME! add short variant for jump
+(define_insn "*sibcall_value_insn"
+ [(set (match_operand 0 "" "")
+       (call
+	(mem:DI
+	 (match_operand:DI 1 "arc64_call_insn_operand" "Sbreg,BLsym,S12S0,S32S0"))
+	(match_operand 2 "" "")))
+  (return)]
+  "SIBLING_CALL_P (insn)"
+  "@
+   j\\t[%1]
+   b\\t%C1
+   j\\t%1
+   j\\t%1"
+  [(set_attr "type" "jump,branch,jump,jump")
+   (set_attr "length" "4,4,4,8")]
+)
+
+; conditional execution patterns
+(define_insn "*call_ce"
+  [(cond_exec
+    (match_operator 3 "arc64_comparison_operator"
+		    [(match_operand 2 "cc_register" "") (const_int 0)])
+    (parallel
+     [(call (mem:DI
+	     (match_operand:DI 0 "arc64_call_insn_operand" "r,BLsym,U06S0"))
+	    (match_operand 1 "" ""))
+      (clobber (reg:DI BLINK_REGNUM))]))]
+  "(arc64_cmodel_var == ARC64_CMODEL_SMALL)
+    || register_operand (operands[0], Pmode)"
+  "@
+   jl%m3\\t[%0]
+   bl%m3\\t%C0
+   jl%m3\\t%0"
+  [(set_attr "type" "jl,bl,jl")
+   (set_attr "length" "4")])
+
+(define_insn "*callv_ce"
+  [(cond_exec
+    (match_operator 3 "arc64_comparison_operator"
+		    [(match_operand 4 "cc_register" "") (const_int 0)])
+    (parallel
+     [(set (match_operand 0 "" "")
+	   (call (mem:DI (match_operand:DI 1 "arc64_call_insn_operand"
+					   "r,BLsym,U06S0"))
+		 (match_operand 2 "" "")))
+      (clobber (reg:DI BLINK_REGNUM))]))]
+  "(arc64_cmodel_var == ARC64_CMODEL_SMALL)
+    || register_operand (operands[1], Pmode)"
+  "@
+   jl%m3\\t[%1]
+   bl%m3\\t%C1
+   jl%m3\\t%1"
+  [(set_attr "type" "jl,bl,jl")
+   (set_attr "length" "4")])
+
+(define_insn "*sibcall_insn_ce"
+  [(cond_exec
+    (match_operator 3 "arc64_comparison_operator"
+		    [(match_operand 2 "cc_register" "") (const_int 0)])
+    (parallel
+     [(call (mem:DI
+	     (match_operand:DI 0 "arc64_call_insn_operand" "Sbreg,BLsym,U06S0"))
+	    (match_operand 1 "" ""))
+      (return)]))]
+  "SIBLING_CALL_P (insn)
+   && ((arc64_cmodel_var == ARC64_CMODEL_SMALL)
+       || register_operand (operands[0], Pmode))"
+  "@
+   j%m3\\t[%0]
+   b%m3\\t%C0
+   j%m3\\t%0"
+  [(set_attr "type" "jump,branch,jump")
+   (set_attr "length" "4")])
+
+(define_insn "*sibcall_value_insn_ce"
+  [(cond_exec
+    (match_operator 3 "arc64_comparison_operator"
+		    [(match_operand 4 "cc_register" "") (const_int 0)])
+    (parallel
+     [(set (match_operand 0 "" "")
+	   (call
+	    (mem:DI
+	     (match_operand:DI 1 "arc64_call_insn_operand" "Sbreg,BLsym,U06S0"))
+	    (match_operand 2 "" "")))
+      (return)]))]
+  "SIBLING_CALL_P (insn)
+   && ((arc64_cmodel_var == ARC64_CMODEL_SMALL)
+       || register_operand (operands[1], Pmode))"
+  "@
+   j%m3\\t[%1]
+   b%m3\\t%C1
+   j%m3\\t%1"
+  [(set_attr "type" "jump,branch,jump")
+   (set_attr "length" "4")])
+
+(define_expand "untyped_call"
+  [(parallel [(call (match_operand 0 "")
+		    (const_int 0))
+	      (match_operand 1 "")
+	      (match_operand 2 "")])]
+  ""
+{
+  int i;
+
+  emit_call_insn (gen_call (operands[0], const0_rtx, const0_rtx));
+
+  for (i = 0; i < XVECLEN (operands[2], 0); i++)
+    {
+      rtx set = XVECEXP (operands[2], 0, i);
+      emit_move_insn (SET_DEST (set), SET_SRC (set));
+    }
+
+  emit_insn (gen_blockage ());
+  DONE;
+})
+
+;; -------------------------------------------------------------------
+;; Jumps and other miscellaneous insns
+;; -------------------------------------------------------------------
+
+(define_expand "indirect_jump"
+  [(set (pc) (match_operand 0 "register_operand"))]
+  ""
+{
+  operands[0] = force_reg (Pmode, operands[0]);
+  if (Pmode == SImode)
+    emit_jump_insn (gen_indirect_jumpsi (operands[0]));
+  else
+    emit_jump_insn (gen_indirect_jumpdi (operands[0]));
+  DONE;
+})
+
+(define_insn "indirect_jump<mode>"
+  [(set (pc) (match_operand:P 0 "register_operand" "q,r"))]
+  ""
+  "j%?\\t[%0]"
+  [(set_attr "type" "jump")
+   (set_attr "length" "2,4")]
+)
+
+(define_insn "jump"
+  [(set (pc) (label_ref (match_operand 0 "" "")))]
+  ""
+  "b%?\\t%l0"
+  [(set_attr "type" "branch")
+   (set (attr "length")
+	(if_then_else
+	 (and (ge (minus (match_dup 0) (pc)) (const_int -512))
+	      (le (minus (match_dup 0) (pc)) (const_int 506)))
+	 (const_int 2)
+	 (const_int 4)))]
+)
+
+(define_expand "cbranch<mode>4"
+  [(set (pc) (if_then_else
+	      (match_operator 0 "arc64_comparison_operator"
+			      [(match_operand:GPI 1 "nonmemory_operand")
+			       (match_operand:GPI 2 "nonmemory_operand")])
+	      (label_ref (match_operand 3 "" ""))
+	      (pc)))]
+  ""
+  "
+  operands[1] = arc64_gen_compare_reg (GET_CODE (operands[0]), operands[1],
+					 operands[2]);
+  operands[2] = const0_rtx;
+  "
+  )
+
+(define_expand "cbranch<mode>4"
+  [(set (pc) (if_then_else (match_operator 0 "arc64_comparison_operator"
+			    [(match_operand:GPF_HF 1 "register_operand")
+			     (match_operand:GPF_HF 2 "register_operand")])
+			   (label_ref (match_operand 3 "" ""))
+			   (pc)))]
+  "ARC64_HAS_FP_BASE"
+  "
+  operands[1] = arc64_gen_compare_reg (GET_CODE (operands[0]), operands[1],
+					 operands[2]);
+  operands[2] = const0_rtx;
+  "
+)
+
+
+(define_insn "condjump"
+  [(set (pc) (if_then_else
+	      (match_operator 0 "arc64_comparison_operator"
+			      [(match_operand 1 "cc_register" "")
+			       (const_int 0)])
+	      (label_ref (match_operand 2 "" ""))
+	      (pc)))]
+  ""
+  "b%m0%?\\t%l2"
+  [(set_attr "type" "branchcc")
+   (set (attr "length")
+	(cond
+	  [(and (match_operand 0 "equality_comparison_operator" "")
+		(and (ge (minus (match_dup 2) (pc)) (const_int -512))
+		     (le (minus (match_dup 2) (pc)) (const_int 506))))
+	   (const_int 2)
+
+	   (and (match_operand 0 "ccmode_comparison_operator" "")
+		(and (ge (minus (match_dup 2) (pc)) (const_int -60))
+		     (le (minus (match_dup 2) (pc)) (const_int 58))))
+	   (const_int 2)]
+	  (const_int 4)))])
+
+(define_expand "prologue"
+  [(clobber (const_int 0))]
+  ""
+  "
+  arc64_expand_prologue ();
+  DONE;
+  "
+)
+
+(define_expand "epilogue"
+  [(clobber (const_int 0))]
+  ""
+  "
+  arc64_expand_epilogue (false);
+  DONE;
+  "
+)
+
+(define_expand "sibcall_epilogue"
+  [(clobber (const_int 0))]
+  ""
+  "
+  arc64_expand_epilogue (true);
+  DONE;
+  "
+)
+
+(define_expand "return"
+  [(simple_return)]
+  "arc64_can_use_return_insn_p ()"
+  "")
+
+(define_insn "simple_return"
+  [(simple_return)]
+  ""
+  "j_s\\t[blink]"
+  [(set_attr "type" "return")
+   (set_attr "length" "2")])
+
+(define_insn "trap_s"
+  [(unspec_volatile [(match_operand:SI 0 "immediate_operand" "U06S0")]
+		   ARC64_VUNSPEC_TRAP_S)]
+  ""
+  "trap_s\\t%0"
+  [(set_attr "length" "2")
+  (set_attr "type" "trap")])
+
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "nop_s"
+  [(set_attr "type" "nop")
+   (set_attr "length" "2")])
+
+(define_insn "blockage"
+  [(unspec_volatile [(const_int 0)] ARC64_VUNSPEC_BLOCKAGE)]
+  ""
+  ""
+  [(set_attr "length" "0")
+   (set_attr "type" "block")]
+  )
+
+;; Don't need initialization instructions.
+(define_expand "doloop_begin"
+ [(use (match_operand 0 "" ""))        ; loop pseudo
+  (use (match_operand 1 "" ""))]       ; doloop_end pattern
+  ""
+  {
+    FAIL;
+  }
+)
+
+; operand 0 is the loop count pseudo register
+; operand 1 is the label to jump to at the top of the loop
+(define_expand "doloop_end"
+  [(parallel [(set (pc)
+		   (if_then_else
+		    (ne (match_operand:DI 0 "" "")
+			(const_int 1))
+		    (label_ref (match_operand 1 "" ""))
+		    (pc)))
+	      (set (match_dup 0) (plus:DI (match_dup 0) (const_int -1)))
+	      (clobber (match_dup 2))])]
+  ""
+  {
+   machine_mode mode = GET_MODE (operands[0]);
+   if (mode != DImode)
+     FAIL;
+   operands[2] = gen_rtx_SCRATCH (mode);
+  })
+
+(define_insn_and_split "dbnz"
+  [(set (pc)
+	(if_then_else
+	 (ne (match_operand:DI 0 "nonimmediate_operand" "+r,!m")
+	     (const_int 1))
+	 (label_ref (match_operand 1 "" ""))
+	 (pc)))
+   (set (match_dup 0)
+	(plus:DI (match_dup 0)
+		 (const_int -1)))
+   (clobber (match_scratch:DI 2 "=X,r"))]
+  ""
+  "@
+   dbnz\\t%0,%l1
+   #"
+  "reload_completed && memory_operand (operands[0], DImode)"
+  [(set (match_dup 2) (match_dup 0))
+   (parallel
+    [(set (reg:CC_ZN CC_REGNUM)
+	  (compare:CC_ZN (plus:DI (match_dup 2) (const_int -1))
+			 (const_int 0)))
+     (set (match_dup 2) (plus:DI (match_dup 2) (const_int -1)))])
+   (set (match_dup 0) (match_dup 2))
+   (set (pc) (if_then_else (ne (reg:CC_ZN CC_REGNUM)
+			       (const_int 0))
+			   (label_ref (match_dup 1))
+			   (pc)))]
+  ""
+  [(set_attr "iscompact" "no")
+   (set_attr "type" "dbnz")
+   (set_attr "length" "4,20")])
+
+; conditional execution
+(define_insn "*returnt_ce"
+  [(set (pc)
+	(if_then_else (match_operator 0 "arc64_comparison_operator"
+				      [(reg CC_REGNUM) (const_int 0)])
+		      (simple_return) (pc)))]
+  ""
+  "j%m0\\t[blink]"
+  [(set_attr "type" "return")
+   (set_attr "length" "4")])
+
+; Jump tables
+(define_expand "casesi"
+  [(match_operand:SI 0 "register_operand" "")  ; Index
+   (match_operand:SI 1 "const_int_operand" "")    ; Lower bound
+   (match_operand:SI 2 "const_int_operand" "")    ; Total range
+   (match_operand 3 "" "")             ; Table label
+   (match_operand 4 "" "")]            ; Out of range label
+  ""
+ {
+   arc64_expand_casesi (operands);
+   DONE;
+   })
+
+(define_insn "casesi_dispatch"
+  [(set (pc)
+       (unspec:DI [(match_operand:SI 0 "register_operand" "r,q,r")
+                   (label_ref (match_operand 1 "" ""))
+                   (const_int 0)]
+                  ARC64_UNSPEC_CASESI))]
+  ""
+  "@
+  bi\\t[%0]
+  j_s\\t[%0]
+  j\\t[%0]"
+  [(set_attr "type" "jump")
+   (set_attr "length" "4,2,4")
+   (set_attr "cpu_facility" "cd,ncd,ncd")])
+
+(define_insn "casesi_addaddr"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+       (unspec:SI [(match_operand:SI 1 "register_operand" "r")
+                   (label_ref (match_operand 2 "" ""))
+                   (const_int 1)]
+                  ARC64_UNSPEC_CASESI))]
+  ""
+  "add2\\t%0,%l2,%1"
+  [(set_attr "type" "add")
+   (set_attr "length" "8")])
+
+(define_insn "casesi_addaddrdi"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+       (unspec:DI [(match_operand:SI 1 "register_operand" "r")
+                   (match_operand:DI 2 "register_operand" "r")
+                   (const_int 2)]
+                  ARC64_UNSPEC_CASESI))]
+  ""
+  "add2l\\t%0,%2,%1"
+  [(set_attr "type" "addl")
+   (set_attr "length" "4")])
+
+(define_insn "casesi_dispatchdi"
+  [(set (pc) (match_operand:DI 0 "register_operand" "q,r"))
+   (use (label_ref (match_operand 1 "" "")))]
+  ""
+  "j%?\\t[%0]"
+  [(set_attr "type" "jump")
+   (set_attr "length" "2,4")])
+
+;; -------------------------------------------------------------------
+;; Sign/Zero extension
+;; -------------------------------------------------------------------
+
+(define_expand "<optab>sidi2"
+  [(set (match_operand:DI 0 "register_operand")
+	(ANY_EXTEND:DI (match_operand:SI 1 "nonimmediate_operand")))]
+  ""
+)
+
+(define_expand "<ANY_EXTEND:optab><SHORT:mode><GPI:mode>2"
+  [(set (match_operand:GPI 0 "register_operand")
+	(ANY_EXTEND:GPI (match_operand:SHORT 1 "nonimmediate_operand")))]
+  ""
+)
+
+;; TODO: Commented out this to fix issues in dejagnu.
+;;       NEEDS TO BE VERIFIED LATER ON.
+;; (define_expand "<optab>qihi2"
+;;   [(set (match_operand:HI 0 "register_operand")
+;; 	(ANY_EXTEND:HI (match_operand:QI 1 "nonimmediate_operand")))]
+;;   ""
+;; )
+
+(define_insn "*zero_extend<mode>si2"
+  [(set (match_operand:SI 0 "register_operand"        "=q,r,    q,r")
+	(zero_extend:SI
+	 (match_operand:SHORT 1 "nonimmediate_operand" "q,r,Uldms,m")))]
+   ""
+   "@
+   ext<exttab>_s\\t%0,%1
+   ext<exttab>\\t%0,%1
+   ld<sfxtab>_s\\t%0,%1
+   ld<sfxtab>%U1\\t%0,%1"
+  [(set_attr "type" "sex,sex,ld,ld")
+   (set_attr "length" "2,4,2,*")])
+
+(define_insn "*zero_extend<mode>di2"
+  [(set (match_operand:DI 0 "register_operand"      "=r,    q,r")
+	(zero_extend:DI
+	 (match_operand:EXT 1 "nonimmediate_operand" "r,Uldms,m")))]
+   ""
+   "@
+   bmskl\\t%0,%1,<sizen>
+   ld<sfxtab>_s\\t%0,%1
+   ld<sfxtab>%U1\\t%0,%1"
+  [(set_attr "type" "and,ld,ld")
+   (set_attr "length" "4,2,*")]
+)
+
+;; conditional execution for the above two patterns
+(define_insn "*zero_extend<SHORT:mode><GPI:mode>2_ce"
+  [(cond_exec
+    (match_operator 2 "arc64_comparison_operator"
+		    [(match_operand 3 "cc_register" "") (const_int 0)])
+    (set (match_operand:GPI 0"register_operand" "=r")
+	 (zero_extend:GPI (match_operand:SHORT 1 "register_operand" "0"))))]
+  ""
+  "bmsk<GPI:mcctab>.%m2\\t%0,%1,<SHORT:sizen>"
+  [(set_attr "type" "and")
+   (set_attr "length" "4")])
+
+(define_insn "*sign_extend<mode>di2"
+  [(set (match_operand:DI 0 "register_operand"       "=r,r")
+	(sign_extend:DI
+	 (match_operand:EXT 1 "nonimmediate_operand"  "r,m")))]
+   ""
+   "@
+   sex<exttab>l\\t%0,%1
+   ld<sfxtab>.x%U1\\t%0,%1"
+   [(set_attr "type" "sex,ld")
+    (set_attr "length" "4,*")])
+
+(define_insn "*sign_extend<mode>si2"
+  [(set (match_operand:SI 0 "register_operand" "=q,r,r")
+	(sign_extend:SI
+	 (match_operand:SHORT 1 "nonimmediate_operand" "q,r,m")))]
+  ""
+  "@
+  sex<exttab>_s\\t%0,%1
+  sex<exttab>\\t%0,%1
+  ld<sfxtab>.x%U1\\t%0,%1"
+  [(set_attr "type" "sex,sex,ld")
+   (set_attr "length" "2,4,8")])
+
+;; -------------------------------------------------------------------
+;; Simple arithmetic
+;; -------------------------------------------------------------------
+
+(define_expand "<optab>di3"
+  [(set (match_operand:DI 0 "register_operand")
+	(ARITH:DI (match_operand:DI 1 "register_operand")
+		  (match_operand:DI 2 "nonmemory_operand")))]
+  ""
+  {
+   if (!register_operand (operands[2], DImode))
+      operands[2] = force_reg (DImode, operands[2]);
+  })
+
+(define_expand "<optab>si3"
+  [(set (match_operand:SI 0 "register_operand")
+	(ARITH:SI (match_operand:SI 1 "register_operand")
+		   (match_operand:SI 2 "nonmemory_operand")))]
+  ""
+  "")
+
+;;(define_expand "addv<mode>4"
+;;  [(match_operand:GPI 0 "register_operand")
+;;   (match_operand:GPI 1 "register_operand")
+;;   (match_operand:GPI 2 "nonmemory_operand")
+;;   (label_ref (match_operand 3 "" ""))]
+;;  ""
+;;  )
+;;
+;;(define_expand "uaddv<mode>4"
+;;  [(match_operand:GPI 0 "register_operand")
+;;   (match_operand:GPI 1 "register_operand")
+;;   (match_operand:GPI 2 "register_operand")
+;;   (label_ref (match_operand 3 "" ""))]
+;;  ""
+;;)
+;;
+;;(define_expand "subv<GPI:mode>4"
+;;  [(match_operand:GPI 0 "register_operand")
+;;   (match_operand:GPI 1 "register_operand")
+;;   (match_operand:GPI 2 "nonmemory_operand")
+;;   (label_ref (match_operand 3 "" ""))]
+;;  ""
+;;  )
+;;
+;;(define_expand "negv<GPI:mode>3"
+;;  [(match_operand:GPI 0 "register_operand")
+;;   (match_operand:GPI 1 "register_operand")
+;;   (label_ref (match_operand 2 "" ""))]
+;;  ""
+;;  )
+;;
+;;(define_expand "usubv<mode>4"
+;;  [(match_operand:GPI 0 "register_operand")
+;;   (match_operand:GPI 1 "nonmemory_operand")
+;;   (match_operand:GPI 2 "nonmemory_operand")
+;;   (label_ref (match_operand 3 "" ""))]
+;;  ""
+;;  )
+
+;; -------------------------------------------------------------------
+;; Comparison insns
+;; -------------------------------------------------------------------
+
+(define_expand "cmp<mode>"
+  [(set (reg:CC CC_REGNUM)
+	(compare:CC (match_operand:GPI 0 "register_operand" "")
+		    (match_operand:GPI 1 "nonmemory_operand" "")))]
+  ""
+  {
+   if (!register_operand (operands[1], DImode))
+      operands[1] = force_reg (DImode, operands[1]);
+  })
+
+(define_insn "*cmp<mode>"
+  [(set (reg:CC CC_REGNUM)
+	(compare:CC
+	 (match_operand:GPI 0 "nonmemory_operand" " q,   qh,r,    r,    r,U06S0,S12S0,S32S0,r")
+	 (match_operand:GPI 1 "nonmemory_operand" "qh,S03MV,r,U06S0,S12S0,    r,    r,    r,S32S0")))]
+  "register_operand (operands[0], <MODE>mode)
+   || register_operand (operands[1], <MODE>mode)"
+  "@
+   cmp<sfxtab>%?\\t%0,%1
+   cmp<sfxtab>%?\\t%0,%1
+   cmp<sfxtab>%?\\t%0,%1
+   cmp<sfxtab>%?\\t%0,%1
+   cmp<sfxtab>%?\\t%0,%1
+   rcmp<sfxtab>%?\\t%1,%0
+   rcmp<sfxtab>%?\\t%1,%0
+   rcmp<sfxtab>%?\\t%1,%0
+   cmp<sfxtab>%?\\t%0,%1"
+  [(set_attr "type" "compare")
+   (set_attr "iscompact" "maybe,maybe,no,no,no,no,no,no,no")
+   (set_attr "predicable" "no,no,yes,yes,no,yes,no,no,no")
+   (set_attr "length" "*,*,4,4,4,4,4,8,8")])
+
+(define_insn "*cmpsi_zn"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN (match_operand:SI 0 "register_operand" "q,r")
+		       (const_int 0)))]
+  ""
+  "tst%?\\t%0,%0"
+  [(set_attr "type" "compare")
+   (set_attr "iscompact" "yes,no")
+   (set_attr "length" "2,4")])
+
+(define_insn "*cmpdi_zn"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN (match_operand:DI 0 "register_operand" "r")
+		       (const_int 0)))]
+  ""
+  "tstl\\t%0,%0"
+  [(set_attr "type" "compare")
+   (set_attr "iscompact" "no")
+   (set_attr "length" "4")])
+
+(define_insn "fcmp<mode>"
+  [(set (reg:CC_FPU CC_REGNUM)
+	(compare:CC_FPU (match_operand:GPF_HF 0 "register_operand" "w")
+			(match_operand:GPF_HF 1 "register_operand" "w")))]
+  "ARC64_HAS_FP_BASE"
+  "f<sfxtab>cmp\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "fcmp")])
+
+(define_insn "fcmpf<mode>"
+  [(set (reg:CC_FPUE CC_REGNUM)
+	(compare:CC_FPUE (match_operand:GPF_HF 0 "register_operand" "w")
+			 (match_operand:GPF_HF 1 "register_operand" "w")))]
+  "ARC64_HAS_FP_BASE"
+  "f<sfxtab>cmpf\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "fcmp")])
+
+;; -------------------------------------------------------------------
+;; Store-flag and conditional select insns
+;; -------------------------------------------------------------------
+
+(define_expand "cstore<mode>4"
+  [(set (match_operand:SI 0 "register_operand")
+	(match_operator:SI 1 "arc64_comparison_operator"
+	 [(match_operand:GPI 2 "nonmemory_operand")
+	  (match_operand:GPI 3 "nonmemory_operand")]))]
+  ""
+  {
+   if (!register_operand (operands[2], <MODE>mode))
+     operands[2] = force_reg (<MODE>mode, operands[2]);
+   if (!arc64_nonmem_operand (operands[3], <MODE>mode))
+     operands[3] = force_reg (<MODE>mode, operands[3]);
+  })
+
+(define_expand "cstore<mode>4"
+  [(set (match_operand:SI 0 "register_operand")
+	(match_operator:SI 1 "arc64_comparison_operator"
+	 [(match_operand:GPF_HF 2 "register_operand")
+	  (match_operand:GPF_HF 3 "register_operand")]))]
+  "ARC64_HAS_FP_BASE"
+  "
+  operands[2] = arc64_gen_compare_reg (GET_CODE (operands[1]), operands[2],
+				      operands[3]);
+  operands[3] = const0_rtx;
+  "
+)
+
+(define_insn_and_split "*scc_insn"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(match_operator:SI 1 "arc64_comparison_operator"
+			   [(reg CC_REGNUM) (const_int 0)]))]
+  ""
+  "#"
+  "reload_completed"
+  [(set (match_dup 0) (const_int 0))
+   (cond_exec
+     (match_dup 1)
+     (set (match_dup 0) (const_int 1)))]
+{
+  operands[1]
+    = gen_rtx_fmt_ee (GET_CODE (operands[1]),
+		      VOIDmode,
+		      XEXP (operands[1], 0), XEXP (operands[1], 1));
+}
+  [(set_attr "type" "movecc")])
+
+;; SETcc instructions
+(define_expand "set<optab><mode>"
+  [(set (match_operand:SI 0 "register_operand")
+	(ALLCC:SI
+	 (match_operand:GPI 1 "register_operand")
+	 (match_operand:GPI 2 "nonmemory_operand")))]
+  ""
+  {
+   if (!arc64_nonmem_operand (operands[2], <MODE>mode))
+      operands[2] = force_reg (<MODE>mode, operands[2]);
+   })
+
+(define_insn "*set<cctab><mode>"
+  [(set (match_operand:SI 0 "register_operand"      "=r,    r,    r,r")
+	(SETCC:SI
+	 (match_operand:GPI 1 "register_operand"     "r,    r,    0,r")
+	 (match_operand:GPI 2 "arc64_nonmem_operand" "r,U06S0,S12S0,n")))]
+  ""
+  "set<cctab><sfxtab>%?\\t%0,%1,%2"
+  [(set_attr "length" "4,4,4,8")
+   (set_attr "type" "setcc")])
+
+;; Special cases of SETCC
+(define_insn_and_split "*sethi<mode>"
+  [(set (match_operand:SI 0 "register_operand"      "=r,    r,r")
+	(gtu:SI
+	 (match_operand:GPI 1 "register_operand"     "r,    r,r")
+	 (match_operand:GPI 2 "arc64_nonmem_operand" "r,U06M1,n")))]
+  ""
+  "setlo<sfxtab>%?\\t%0,%2,%1"
+  "reload_completed
+   && CONST_INT_P (operands[2])
+   && satisfies_constraint_U06M1 (operands[2])"
+  [(const_int 0)]
+  "{
+    /* sethi a,b,u6 => seths a,b,u6 + 1.  */
+    operands[2] = GEN_INT (INTVAL (operands[2]) + 1);
+    emit_insn (gen_setgeu<mode> (operands[0], operands[1], operands[2]));
+    DONE;
+   }"
+ [(set_attr "length" "4,4,8")
+   (set_attr "type" "setcc")])
+
+(define_insn_and_split "*setls<mode>"
+  [(set (match_operand:SI 0 "register_operand"      "=r,    r,r")
+	(leu:SI
+	 (match_operand:GPI 1 "register_operand"     "r,    r,r")
+	 (match_operand:GPI 2 "arc64_nonmem_operand" "r,U06M1,n")))]
+  ""
+  "seths<sfxtab>%?\\t%0,%2,%1"
+  "reload_completed
+   && satisfies_constraint_U06M1 (operands[2])"
+  [(const_int 0)]
+  "{
+    /* setls a,b,u6 => setlo a,b,u6 + 1.  */
+    operands[2] = GEN_INT (INTVAL (operands[2]) + 1);
+    emit_insn (gen_setltu<mode> (operands[0], operands[1], operands[2]));
+    DONE;
+   }"
+  [(set_attr "length" "4,4,8")
+   (set_attr "type" "setcc")])
+
+;; MOVCC patterns seems to generate worse code. Disable them for time being
+;;(define_expand "mov<mode>cc"
+;;  [(set (match_operand:ALLI 0 "register_operand")
+;;	(if_then_else:ALLI (match_operand 1 "arc64_comparison_operator")
+;;			   (match_operand:ALLI 2 "register_operand")
+;;			   (match_operand:ALLI 3 "register_operand")))]
+;;  ""
+;;  {
+;;   rtx tmp;
+;;   enum rtx_code code = GET_CODE (operands[1]);
+;;
+;;   if (code == UNEQ || code == LTGT)
+;;     FAIL;
+;;
+;;   tmp = arc64_gen_compare_reg (code, XEXP (operands[1], 0),
+;;				XEXP (operands[1], 1));
+;;   operands[1] = gen_rtx_fmt_ee (code, VOIDmode, tmp, const0_rtx);
+;;  })
+
+;;(define_expand "mov<mode>cc"
+;;  [(set (match_operand:GPF 0 "register_operand")
+;;	(if_then_else:GPF (match_operand 1 "arc64_comparison_operator")
+;;			  (match_operand:GPF 2 "register_operand")
+;;			  (match_operand:GPF 3 "register_operand")))]
+;;  ""
+;;  {
+;;   rtx tmp;
+;;   enum rtx_code code = GET_CODE (operands[1]);
+;;
+;;   if (code == UNEQ || code == LTGT)
+;;     FAIL;
+;;
+;;   tmp = arc64_gen_compare_reg (code, XEXP (operands[1], 0),
+;;				XEXP (operands[1], 1));
+;;   operands[1] = gen_rtx_fmt_ee (code, VOIDmode, tmp, const0_rtx);
+;;  })
+
+;;(define_insn "*cmov<mode>"
+;;  [(set (match_operand:ALLI 0 "register_operand" "=r,r")
+;;	(if_then_else:ALLI
+;;	 (match_operator 3 "arc64_comparison_operator"
+;;			 [(match_operand 4 "cc_register" "") (const_int 0)])
+;;	 (match_operand:ALLI 1 "nonmemory_operand" "rU06S0,S32S0")
+;;	 (match_operand:ALLI 2 "register_operand"  "0,0")))]
+;;  ""
+;;  "mov<mcctab>.%m3\\t%0,%1"
+;;  [(set_attr "length" "4,8")
+;;   (set_attr "type" "move")])
+
+;;(define_insn "*cmov<mode>"
+;;  [(set (match_operand:GPF 0 "register_operand" "=w,*r,*r")
+;;	(if_then_else:GPF
+;;	 (match_operator 3 "arc64_comparison_operator"
+;;			 [(match_operand 4 "cc_register" "") (const_int 0)])
+;;	 (match_operand:GPF 1 "nonmemory_operand" "w,*r,*E")
+;;	 (match_operand:GPF 2 "register_operand"  "0, 0, 0")))]
+;;  ""
+;;  "@
+;;   f<sfxtab>mov.%m3\\t%0,%1
+;;   mov<mcctab>.%m3\\t%0,%1
+;;   mov<mcctab>.%m3\\t%0,%1"
+;;  [(set_attr "length" "4,4,8")
+;;   (set_attr "type" "fmov,move,move")])
+
+;; conditional patterns
+;; Todo: add conditional execution for leu and geu
+(define_insn "*set<cctab><mode>_ce"
+  [(cond_exec
+    (match_operator 3 "arc64_comparison_operator"
+		    [(match_operand 4 "cc_register" "") (const_int 0)])
+    (set (match_operand:SI 0 "register_operand"            "=r,r")
+	 (SETCC:SI (match_operand:GPI 1 "register_operand"  "0,0")
+		   (match_operand:GPI 2 "arc64_nonmem_operand" "r,n"))))]
+  ""
+  "set<cctab><sfxtab>.%m3\\t%0,%1,%2"
+  [(set_attr "type" "setcc")
+   (set_attr "length" "4,8")])
+
+;; -------------------------------------------------------------------
+;; Logical operations
+;; -------------------------------------------------------------------
+
+(define_expand "<optab><mode>3"
+  [(set (match_operand:GPI 0 "register_operand")
+	(LOGIC:GPI (match_operand:GPI 1 "register_operand")
+		   (match_operand:GPI 2 "nonmemory_operand")))]
+  ""
+  {
+   if (!arc64_nonmem_operand (operands[2], <MODE>mode))
+      operands[2] = force_reg (<MODE>mode, operands[2]);
+  })
+
+(define_expand "<optab><mode>2"
+  [(set (match_operand:GPI 0 "register_operand")
+	(LOGIC2:GPI (match_operand:GPI 1 "register_operand")))]
+  ""
+  )
+
+(define_insn "negsi2"
+  [(set (match_operand:SI 0 "register_operand"        "=q,q,r,r")
+	(neg:SI (match_operand:SI 1 "register_operand" "0,q,0,r")))]
+  ""
+  "neg%?\\t%0,%1"
+  [(set_attr "type" "neg")
+   (set_attr "iscompact" "maybe,yes,no,no")
+   (set_attr "predicable" "yes,no,yes,no")
+   (set_attr "length" "*,2,4,4")])
+
+(define_insn "*<optab><mode>2"
+  [(set (match_operand:GPI 0 "register_operand" "=q,r")
+	(LOGIC2:GPI (match_operand:GPI 1 "register_operand" "q,r")))]
+  ""
+  "<mntab><sfxtab>%?\\t%0,%1"
+  [(set_attr "type" "<mntab>")
+   (set_attr "iscompact" "maybe,no")
+   (set_attr "length" "*,4")])
+
+(define_insn "*<optab><mode>3"
+   [(set (match_operand:GPI 0 "register_operand"                  "=r,    r,     r,r")
+	 (MINMAX:GPI (match_operand:GPI 1 "register_operand"      "%0,    0,     r,r")
+		     (match_operand:GPI 2 "nonmemory_operand" "rU06S0,S12S0,rU06S0,S32S0")))]
+  ""
+  "<mntab><sfxtab>%?\\t%0,%1,%2"
+  [(set_attr "type" "<mntab>")
+   (set_attr "length" "4,4,4,8")
+   (set_attr "predicable" "yes,no,no,no")]
+)
+
+;; Conditional execution
+(define_insn "*<optab><mode>_ce"
+  [(cond_exec
+    (match_operator 3 "arc64_comparison_operator"
+		    [(match_operand 4 "cc_register" "") (const_int 0)])
+    (set (match_operand:GPI 0 "register_operand"                  "=r,r")
+	 (MINMAX:GPI (match_operand:GPI 1 "register_operand"      "%0,0")
+		     (match_operand:GPI 2 "nonmemory_operand" "rU06S0,S32S0"))))]
+  ""
+  "<mntab><sfxtab>.%m3\\t%0,%1,%2"
+  [(set_attr "type" "<mntab>")
+   (set_attr "length" "4,8")])
+
+;; Zero-extend pattern
+(define_insn "*<optab>si_zextend"
+  [(set (match_operand:DI 0 "register_operand" "=q,r")
+	(zero_extend:DI
+	 (LOP2EX:SI (match_operand:SI 1 "register_operand" "q,r"))))]
+  ""
+  "<mntab>%?\\t%0,%1"
+  [(set_attr "type" "<mntab>")
+   (set_attr "iscompact" "yes,no")
+   (set_attr "length" "*,4")])
+
+(define_insn "*<optab>3_zextend"
+  [(set (match_operand:DI 0 "register_operand"        "=r,    r,     r,r")
+	(zero_extend:DI
+	 (MINMAX:SI
+	  (match_operand:SI 1 "register_operand"      "%0,    0,     r,r")
+	  (match_operand:SI 2 "nonmemory_operand" "rU06S0,S12S0,rU06S0,S32S0"))))]
+  ""
+  "<mntab>%?\\t%0,%1,%2"
+  [(set_attr "type" "max")
+   (set_attr "length" "4,4,4,8")
+   (set_attr "predicable" "yes,no,no,no")])
+
+;; -------------------------------------------------------------------
+;; Shifts
+;; -------------------------------------------------------------------
+
+;; FIXME! check if we get better code if we use QI for op 2.
+(define_expand "<optab><mode>3"
+  [(set (match_operand:GPI 0 "register_operand")
+	(ASHIFT:GPI (match_operand:GPI 1 "register_operand")
+		    (match_operand:GPI 2 "nonmemory_operand")))]
+  "")
+
+(define_expand "rotrsi3"
+  [(set (match_operand:SI 0 "register_operand")
+	(rotatert:SI (match_operand:SI 1 "nonmemory_operand")
+		     (match_operand:SI 2 "nonmemory_operand")))]
+  "")
+
+(define_insn "*rotrsi3"
+  [(set (match_operand:SI 0 "register_operand"                   "=r,     r,r")
+	(rotatert:SI (match_operand:SI 1 "nonmemory_operand"      "0,     r,i")
+		     (match_operand:SI 2 "nonmemory_operand" "rU06S0,rU06S0,r")))]
+  ;; FIXME! this needs BARREL_SHIFTER option
+  "register_operand (operands[0], SImode)
+   || register_operand (operands[1], SImode)"
+  "ror%?\\t%0,%1,%2"
+  [(set_attr "type" "ror")
+   (set_attr "predicable" "yes,no,no")
+   (set_attr "length" "4,4,8")])
+
+(define_insn "rotr1"
+  [(set (match_operand:SI 0 "register_operand"              "=     r,r")
+	(rotatert:SI (match_operand:SI 1 "nonmemory_operand" "rU06S0,i")
+		     (const_int 1)))]
+  ""
+  "ror%?\\t%0,%1"
+  [(set_attr "type" "ror")
+   (set_attr "predicable" "no")
+   (set_attr "length" "4,8")])
+
+(define_insn "rotr8"
+  [(set (match_operand:SI 0 "register_operand"              "=     r,r")
+	(rotatert:SI (match_operand:SI 1 "nonmemory_operand" "rU06S0,i")
+		     (const_int 8)))]
+  ""
+  "ror8%?\\t%0,%1"
+  [(set_attr "type" "ror")
+   (set_attr "predicable" "no")
+   (set_attr "length" "4,8")])
+
+(define_expand "rotlsi3"
+  [(set (match_operand:SI 0 "register_operand")
+	(rotatert:SI (match_operand:SI 1 "nonmemory_operand")
+		     (match_operand:SI 2 "nonmemory_operand")))]
+  ""
+  "
+  if (CONST_INT_P (operands[2])
+      && (INTVAL (operands[2]) == 1))
+    {
+     gen_rotl1 (operands[0], operands[1]);
+     DONE;
+    }
+
+  if (CONST_INT_P (operands[2])
+      && (INTVAL (operands[2]) == 8))
+    {
+     gen_rotl8 (operands[0], operands[1]);
+     DONE;
+    }
+
+  if (CONST_INT_P (operands[2]))
+    operands[2] = GEN_INT ((32 - INTVAL (operands[2])) % 32);
+  else
+    {
+      rtx reg = gen_reg_rtx (SImode);
+      emit_insn (gen_subsi3 (reg, GEN_INT (32), operands[2]));
+      operands[2] = reg;
+    }
+  ")
+
+(define_insn "rotl1"
+  [(set (match_operand:SI 0 "register_operand"             "=     r,r")
+	(rotate:SI (match_operand:SI 1 "nonmemory_operand"  "rU06S0,i")
+		   (const_int 1)))]
+  ""
+  "rol%?\\t%0,%1"
+  [(set_attr "type" "rol")
+   (set_attr "predicable" "no")
+   (set_attr "length" "4,8")])
+
+(define_insn "rotl8"
+  [(set (match_operand:SI 0 "register_operand"             "=     r,r")
+	(rotate:SI (match_operand:SI 1 "nonmemory_operand"  "rU06S0,i")
+		   (const_int 8)))]
+  ""
+  "rol8%?\\t%0,%1"
+  [(set_attr "type" "rol")
+   (set_attr "predicable" "no")
+   (set_attr "length" "4,8")])
+
+;; Conditional execution
+(define_insn "*rotrsi_ce"
+  [(cond_exec
+    (match_operator 3 "arc64_comparison_operator"
+		    [(match_operand 4 "cc_register" "") (const_int 0)])
+    (set (match_operand:SI 0 "register_operand"                   "=r,r")
+	 (rotatert:SI (match_operand:SI 1 "register_operand"      "%0,0")
+		      (match_operand:SI 2 "nonmemory_operand" "rU06S0,S32S0"))))
+   ]
+  ""
+  "ror.%m3\\t%0,%1,%2"
+  [(set_attr "type" "ror")
+   (set_attr "length" "4,8")])
+
+;; -------------------------------------------------------------------
+;; Bitfields
+;; -------------------------------------------------------------------
+
+(define_expand "extzv<mode>"
+  [(set (match_operand:GPI 0 "register_operand" "")
+	(zero_extract:GPI (match_operand:GPI 1 "register_operand" "")
+			  (match_operand 2 "const_int_operand" "")
+			  (match_operand 3 "const_int_operand" "")))]
+  "")
+
+(define_insn "*extzvsi"
+  [(set (match_operand:SI 0 "register_operand"                  "=r,r")
+	(zero_extract:SI (match_operand:SI 1 "register_operand"  "0,r")
+			 (match_operand 2    "const_int_operand" "n,n")
+			 (match_operand 3    "const_int_operand" "n,n")))]
+  ""
+  {
+   int assemble_op2 = (((INTVAL (operands[2]) - 1) & 0x1f) << 5)
+                       | (INTVAL (operands[3]) & 0x1f);
+   operands[2] = GEN_INT (assemble_op2);
+   return "xbfu%?\\t%0,%1,%2";
+  }
+  [(set_attr "type"       "xbfu")
+   (set_attr "iscompact"  "no")
+   (set_attr "length"     "4,8")
+   (set_attr "predicable" "no")])
+
+;;FIXME! compute length based on the input args.
+(define_insn "*extzvdi"
+  [(set (match_operand:DI 0 "register_operand"                  "=r,r")
+	(zero_extract:DI (match_operand:DI 1 "register_operand"  "0,r")
+			 (match_operand 2    "const_int_operand" "n,n")
+			 (match_operand 3    "const_int_operand" "n,n")))]
+  ""
+  {
+   int assemble_op2 = (((INTVAL (operands[2]) - 1) & 0x3f) << 6)
+                       | (INTVAL (operands[3]) & 0x3f);
+   operands[2] = GEN_INT (assemble_op2);
+   return "xbful%?\\t%0,%1,%2";
+  }
+  [(set_attr "type"       "xbfu")
+   (set_attr "iscompact"  "no")
+   (set_attr "length"     "8,8")
+   (set_attr "predicable" "no")])
+
+;; -------------------------------------------------------------------
+;; Bitscan
+;; -------------------------------------------------------------------
+
+(define_insn "clrsb<mode>2"
+  [(set (match_operand:EPI 0 "register_operand"           "=r")
+	(clrsb:EPI (match_operand:EPI 1 "register_operand" "r")))]
+  "TARGET_BITSCAN"
+  "norm<sfxtab>\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "norm<sfxtab>")])
+
+(define_expand "clz<mode>2"
+  [(match_operand:GPI 0 "register_operand")
+   (match_operand:GPI 1 "register_operand")]
+  "TARGET_BITSCAN"
+  {
+   rtx tmp = gen_reg_rtx (<MODE>mode);
+   unsigned int size = GET_MODE_SIZE (<MODE>mode) * BITS_PER_UNIT - 1;
+   emit_insn (gen_arc64_fls<sfxtab>2 (tmp, operands[1]));
+   emit_insn (gen_sub<mode>3 (operands[0], GEN_INT (size), tmp));
+   DONE;
+   })
+
+(define_insn "ctz<mode>2"
+  [(set (match_operand:GPI 0 "register_operand"         "=r")
+	(ctz:GPI (match_operand:GPI 1 "register_operand" "r")))]
+  "TARGET_BITSCAN"
+  "ffs<sfxtab>\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "ffs")])
+
+(define_insn "arc64_fls<sfxtab>2"
+  [(set (match_operand:GPI  0 "register_operand"            "=r")
+	(unspec:GPI [(match_operand:GPI 1 "register_operand" "r")]
+		    ARC64_UNSPEC_FLS))]
+  "TARGET_BITSCAN"
+  "fls<sfxtab>\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "fls")])
+
+;; -------------------------------------------------------------------
+;; Floating-point intrinsics
+;; -------------------------------------------------------------------
+
+(define_insn "round<mode>2"
+  [(set (match_operand:GPF 0 "register_operand" "=w")
+	(unspec:GPF [(match_operand:GPF 1 "register_operand" "w")]
+		    ARC64_UNSPEC_ROUND))]
+  "ARC64_HAS_FP_BASE"
+  "f<sfxtab>rnd\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "frnd")])
+
+(define_insn "btrunc<mode>2"
+  [(set (match_operand:GPF 0 "register_operand" "=w")
+	(unspec:GPF [(match_operand:GPF 1 "register_operand" "w")]
+		    ARC64_UNSPEC_BTRUNC))]
+  "ARC64_HAS_FP_BASE"
+  "f<sfxtab>rnd_rz\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "frnd")])
+
+;; -------------------------------------------------------------------
+;; Floating-point conversions
+;; -------------------------------------------------------------------
+
+(define_insn "extendsfdf2"
+  [(set (match_operand:DF 0 "register_operand" "=w")
+        (float_extend:DF (match_operand:SF 1 "register_operand" "w")))]
+  "ARC64_HAS_FPUD"
+  "fs2d\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "fs2d")])
+
+(define_insn "extendhfsf2"
+  [(set (match_operand:SF 0 "register_operand" "=w")
+        (float_extend:SF (match_operand:HF 1 "register_operand" "w")))]
+  "ARC64_HAS_FPUH"
+  "fh2s\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "fh2s")])
+
+;;(define_expand "extendhfdf2"
+;;  [(match_operand:DF 0 "register_operand")
+;;   (match_operand:HF 1 "register_operand")]
+;;  "ARC64_HAS_FPUH"
+;;  {
+;;    rtx tmp = gen_reg_rtx (SFmode);
+;;    emit_insn (gen_extendhfsf2 (tmp, operands[1]));
+;;    emit_insn (gen_extendsfdf2 (operands[0], tmp));
+;;    DONE;
+;;  })
+
+(define_insn "truncdfsf2"
+  [(set (match_operand:SF 0 "register_operand" "=w")
+        (float_truncate:SF (match_operand:DF 1 "register_operand" "w")))]
+  "ARC64_HAS_FPUD"
+  "fd2s\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "fd2s")])
+
+(define_insn "truncsfhf2"
+  [(set (match_operand:HF 0 "register_operand" "=w")
+        (float_truncate:HF (match_operand:SF 1 "register_operand" "w")))]
+  "ARC64_HAS_FPUH"
+  "fs2h\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "fs2h")])
+
+;;(define_expand "truncdfhf2"
+;;  [(match_operand:HF 0 "register_operand")
+;;   (match_operand:DF 1 "register_operand")]
+;;  "ARC64_HAS_FPUH"
+;;  {
+;;    rtx tmp = gen_reg_rtx (SFmode);
+;;    emit_insn (gen_truncdfsf2 (tmp, operands[1]));
+;;    emit_insn (gen_truncsfhf2 (operands[0], tmp));
+;;    DONE;
+;;  })
+
+;; SI->SF SI->DF DI->SF DI->DF
+;; FINT2S FINT2D FL2S FL2D
+(define_insn "float<GPI:mode><GPF:mode>2"
+  [(set (match_operand:GPF 0 "register_operand"           "=w")
+	(float:GPF (match_operand:GPI 1 "register_operand" "r")))]
+  "ARC64_HAS_FP_BASE"
+  "f<GPI:f2tab>2<GPF:sfxtab>\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "int2fp")])
+
+(define_expand "floatsihf2"
+  [(match_operand:HF 0 "register_operand")
+   (match_operand:SI 1 "register_operand")]
+  "ARC64_HAS_FPUH"
+  {
+    rtx tmp = gen_reg_rtx (SFmode);
+    emit_insn (gen_floatsisf2 (tmp, operands[1]));
+    emit_insn (gen_truncsfhf2 (operands[0], tmp));
+    DONE;
+  })
+
+(define_expand "floatdihf2"
+  [(match_operand:HF 0 "register_operand")
+   (match_operand:DI 1 "register_operand")]
+  "ARC64_HAS_FPUH"
+  {
+    rtx tmp = gen_reg_rtx (SFmode);
+    emit_insn (gen_floatdisf2 (tmp, operands[1]));
+    emit_insn (gen_truncsfhf2 (operands[0], tmp));
+    DONE;
+    })
+
+;; uSI->SF uSI->DF uDI->SF uDI->DF
+;; FUINT2S FUINT2D FUL2S FUL2D
+(define_insn "floatuns<GPI:mode><GPF:mode>2"
+  [(set (match_operand:GPF 0 "register_operand"                    "=w")
+	(unsigned_float:GPF (match_operand:GPI 1 "register_operand" "r")))]
+  "ARC64_HAS_FP_BASE"
+  "fu<GPI:f2tab>2<GPF:sfxtab>\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "uint2fp")])
+
+;; SF->uSI SF->uDI DF->uSI DF->uDI (using rounding towards zero)
+;; FS2UINT_RZ FS2UL_RZ FD2UINT_RZ FD2UL_RZ
+(define_insn "fixuns_trunc<GPF:mode><GPI:mode>2"
+  [(set (match_operand:GPI 0 "register_operand"         "=r")
+	(unsigned_fix:GPI (match_operand:GPF 1 "register_operand" "w")))]
+  "ARC64_HAS_FP_BASE"
+  "f<GPF:sfxtab>2u<GPI:f2tab>_rz\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "fp2uint")])
+
+;; SF->SI SF->DI DF->SI DF->DI (using rounding towards zero)
+;; FS2INT_RZ FS2L_RZ FD2INT_RZ FD2L_RZ
+(define_insn "fix_trunc<GPF:mode><GPI:mode>2"
+  [(set (match_operand:GPI 0 "register_operand"         "=r")
+	(fix:GPI (match_operand:GPF 1 "register_operand" "w")))]
+  "ARC64_HAS_FP_BASE"
+  "f<GPF:sfxtab>2<GPI:f2tab>_rz\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "fp2int")])
+
+;; -------------------------------------------------------------------
+;; Floating-point arithmetic
+;; -------------------------------------------------------------------
+
+;; F<P>ADD F<P>SUB F<P>MUL F<P>DIV F<P>MIN F<P>MAX
+(define_insn "<optab><mode>3"
+  [(set (match_operand:GPF_HF 0 "register_operand" "=w")
+	(DOPF:GPF_HF (match_operand:GPF_HF 1 "register_operand" "w")
+		     (match_operand:GPF_HF 2 "register_operand" "w")))]
+  "ARC64_HAS_FP_BASE"
+  "f<sfxtab><mntab>\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "f<mntab>")])
+
+;; F<P>ABS
+;; FIXME! bclr can be short. Also we can predicate it
+(define_insn "abs<mode>2"
+  [(set (match_operand:GPF_HF 0 "register_operand" "=w,*r")
+	(abs:GPF_HF (match_operand:GPF_HF 1 "register_operand" "w,*r")))]
+  ""
+  "@
+  f<sfxtab>sgnjx\\t%0,%1,%1
+  bclr<fptab>\\t%0,%1,<sizen>"
+  [(set_attr "length" "4")
+   (set_attr "type" "fsgnjx,bclr")])
+
+;; F<P>NEG
+;; FIXME! bxor can be predicated
+(define_insn "neg<mode>2"
+  [(set (match_operand:GPF_HF 0 "register_operand" "=w,*r")
+	(neg:GPF_HF (match_operand:GPF_HF 1 "register_operand" "w,*r")))]
+  ""
+  "@
+  f<sfxtab>sgnjn\\t%0,%1,%1
+  bxor<fptab>\\t%0,%1,<sizen>"
+  [(set_attr "length" "4")
+   (set_attr "type" "fsgnjn,bxor")])
+
+;; F<P>MADD
+(define_insn "fma<mode>4"
+  [(set (match_operand:GPF_HF 0 "register_operand" "=w")
+	(fma:GPF_HF (match_operand:GPF_HF 1 "register_operand"  "w")
+		    (match_operand:GPF_HF 2 "register_operand"  "w")
+		    (match_operand:GPF_HF 3 "register_operand"  "w")))]
+  "ARC64_HAS_FP_BASE"
+  "f<sfxtab>madd\\t%0,%1,%2,%3"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmadd")])
+
+;; F<P>MSUB
+(define_insn "fnma<mode>4"
+  [(set (match_operand:GPF_HF 0 "register_operand" "=w")
+	(fma:GPF_HF (neg:GPF_HF (match_operand:GPF_HF 1 "register_operand"  "w"))
+		    (match_operand:GPF_HF 2 "register_operand"  "w")
+		    (match_operand:GPF_HF 3 "register_operand"  "w")))]
+  "ARC64_HAS_FP_BASE"
+  "f<sfxtab>msub\\t%0,%1,%2,%3"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmsub")])
+
+;; F<P>NMSUB
+;; TBI: the md.texi says Like @code{fma@var{m}4}, except
+;; operand 3 subtracted from the product instead of added to the
+;; product. However, fnmsub does -(s3 - (s1 * s2))
+(define_insn "fms<mode>4"
+  [(set (match_operand:GPF_HF 0 "register_operand" "=w")
+	(fma:GPF_HF (match_operand:GPF_HF 1 "register_operand"  "w")
+		    (match_operand:GPF_HF 2 "register_operand"  "w")
+		    (neg:GPF_HF (match_operand:GPF_HF 3 "register_operand"  "w"))))]
+  "!HONOR_SIGNED_ZEROS (<MODE>mode) && ARC64_HAS_FP_BASE"
+  "f<sfxtab>nmsub\\t%0,%1,%2,%3"
+  [(set_attr "length" "4")
+   (set_attr "type" "fnmsub")])
+
+;; -(op3 - (op1 * op2))
+(define_insn "*nfnms<mode>4"
+  [(set (match_operand:GPF_HF 0 "register_operand" "=w")
+	(neg:GPF_HF (fma:GPF_HF (neg:GPF_HF (match_operand:GPF_HF 1 "register_operand"  "w"))
+			  (match_operand:GPF_HF 2 "register_operand"  "w")
+			  (match_operand:GPF_HF 3 "register_operand"  "w"))))]
+  "ARC64_HAS_FP_BASE"
+  "f<sfxtab>nmsub\\t%0,%1,%2,%3"
+  [(set_attr "length" "4")
+   (set_attr "type" "fnmsub")])
+
+;; F<P>NMADD
+;; Likewise like above
+(define_insn "fnms<mode>4"
+  [(set (match_operand:GPF_HF 0 "register_operand" "=w")
+	(fma:GPF_HF (neg:GPF_HF (match_operand:GPF_HF 1 "register_operand"  "w"))
+		    (match_operand:GPF_HF 2 "register_operand"  "w")
+		    (neg:GPF_HF (match_operand:GPF_HF 3 "register_operand"  "w"))))]
+  "!HONOR_SIGNED_ZEROS (<MODE>mode) && ARC64_HAS_FP_BASE"
+  "f<sfxtab>nmadd\\t%0,%1,%2,%3"
+  [(set_attr "length" "4")
+   (set_attr "type" "fnmadd")])
+
+;; -(op3 + (op1 * op2))
+(define_insn "*nfms<mode>4"
+  [(set (match_operand:GPF_HF 0 "register_operand" "=w")
+	(neg:GPF_HF (fma:GPF_HF (match_operand:GPF_HF 1 "register_operand"  "w")
+				(match_operand:GPF_HF 2 "register_operand"  "w")
+				(match_operand:GPF_HF 3 "register_operand"  "w"))))]
+  "ARC64_HAS_FP_BASE"
+  "f<sfxtab>nmadd\\t%0,%1,%2,%3"
+  [(set_attr "length" "4")
+   (set_attr "type" "fnmadd")])
+
+;; F<P>SQRT
+(define_insn "sqrt<mode>2"
+  [(set (match_operand:GPF_HF 0 "register_operand" "=w")
+	(sqrt:GPF_HF (match_operand:GPF_HF 1 "register_operand" "w")))]
+  "ARC64_HAS_FP_BASE"
+  "f<sfxtab>sqrt\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "fsqrt")])
+
+;; F<P>SGNJ
+(define_insn "copysign<mode>3"
+  [(set (match_operand:GPF_HF 0 "register_operand" "=w")
+	(unspec:GPF_HF [(match_operand:GPF_HF 1 "register_operand" "w")
+			(match_operand:GPF_HF 2 "register_operand" "w")]
+		       ARC64_UNSPEC_COPYSIGN))]
+  "ARC64_HAS_FP_BASE"
+  "f<sfxtab>sgnj\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fsgnj")])
+
+;; F<P>SGNJX
+(define_insn "xorsign<mode>3"
+  [(set (match_operand:GPF_HF 0 "register_operand" "=w")
+	(unspec:GPF_HF [(match_operand:GPF_HF 1 "register_operand" "w")
+			(match_operand:GPF_HF 2 "register_operand" "w")]
+		       ARC64_UNSPEC_XORSIGN))]
+  "ARC64_HAS_FP_BASE"
+  "f<sfxtab>sgnjx\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fsgnjx")])
+
+;; F<P>SGNJN
+(define_insn "*ncopysign<mode>3"
+  [(set (match_operand:GPF_HF 0 "register_operand" "=w")
+	(neg:GPF_HF (unspec:GPF_HF
+		     [(match_operand:GPF_HF 1 "register_operand" "w")
+		      (match_operand:GPF_HF 2 "register_operand" "w")]
+		     ARC64_UNSPEC_COPYSIGN)))]
+  "ARC64_HAS_FP_BASE"
+  "f<sfxtab>sgnjn\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fsgnjn")])
+
+;; -------------------------------------------------------------------
+;; Builtins
+;; -------------------------------------------------------------------
+
+(define_insn "lr"
+  [(set (match_operand:SI  0 "register_operand" "=r,r,r,r")
+	(unspec_volatile:SI
+	 [(match_operand:SI 1 "nonmemory_operand" "U06S0,S12S0,r,i")]
+	 ARC64_VUNSPEC_LR))]
+  ""
+  "lr\\t%0,[%1]"
+  [(set_attr "length" "4,4,4,8")
+   (set_attr "type" "lr")])
+
+(define_insn "sr"
+  [(unspec_volatile
+    [(match_operand:SI 0 "register_operand"  "    r,    r, r, r")
+     (match_operand:SI 1 "nonmemory_operand" "U06S0,S12S0, i, r")]
+    ARC64_VUNSPEC_SR)]
+  ""
+  "sr\\t%0,[%1]"
+  [(set_attr "length" "4,4,4,8")
+   (set_attr "type" "sr")])
+
+(define_insn "lrl"
+  [(set (match_operand:DI  0 "register_operand" "=r,r,r,r")
+	(unspec_volatile:DI
+	 [(match_operand:DI 1 "nonmemory_operand" "U06S0,S12S0,r,i")]
+	 ARC64_VUNSPEC_LRL))]
+  ""
+  "lrl\\t%0,[%1]"
+  [(set_attr "length" "4,4,4,8")
+   (set_attr "type" "lr")])
+
+(define_insn "srl"
+  [(unspec_volatile
+    [(match_operand:DI 0 "register_operand"  "    r,    r, r, r")
+     (match_operand:DI 1 "nonmemory_operand" "U06S0,S12S0, i, r")]
+    ARC64_VUNSPEC_SRL)]
+  ""
+  "srl\\t%0,[%1]"
+  [(set_attr "length" "4,4,4,8")
+   (set_attr "type" "sr")])
+
+(define_insn "flag"
+  [(unspec_volatile [(match_operand:SI 0 "nonmemory_operand" "U06S0,S12S0,r,i")]
+		   ARC64_VUNSPEC_FLAG)]
+  ""
+  "@
+    flag%?\\t%0
+    flag\\t%0
+    flag%?\\t%0
+    flag%?\\t%0"
+  [(set_attr "length" "4,4,4,8")
+   (set_attr "type" "flag")
+   (set_attr "predicable" "yes,no,yes,yes")])
+
+(define_insn "brk"
+  [(unspec_volatile [(const_int 0)] ARC64_VUNSPEC_BRK)]
+  ""
+  "brk"
+  [(set_attr "length" "4")
+  (set_attr "type" "brk")])
+
+(define_insn "nopv"
+  [(unspec_volatile [(const_int 0)] ARC64_VUNSPEC_NOP)]
+  ""
+  "nop_s"
+  [(set_attr "type" "nop")
+   (set_attr "length" "2")])
+
+
+;; For thread pointer builtins
+(define_expand "get_thread_pointerdi"
+  [(set (match_operand:DI 0 "register_operand") (match_dup 1))]
+ ""
+ "operands[1] = gen_rtx_REG (Pmode, R30_REGNUM);")
+
+(define_expand "set_thread_pointerdi"
+  [(set (match_dup 1) (match_operand:DI 0 "register_operand"))]
+ ""
+ "operands[1] = gen_rtx_REG (Pmode, R30_REGNUM);")
+
+
+(include "arith.md")
+
+(define_insn "sync"
+  [(unspec_volatile [(const_int 1)]
+		   ARC64_VUNSPEC_SYNC)]
+  ""
+  "sync"
+  [(set_attr "length" "4")
+  (set_attr "type" "sync")])
+
+(include "atomic.md")
+
+
+;; mode:emacs-lisp
+;; comment-start: ";; "
+;; eval: (set-syntax-table (copy-sequence (syntax-table)))
+;; eval: (modify-syntax-entry ?[ "(]")
+;; eval: (modify-syntax-entry ?] ")[")
+;; eval: (modify-syntax-entry ?{ "(}")
+;; eval: (modify-syntax-entry ?} "){")
+;; eval: (setq indent-tabs-mode t)
+;; End:
diff --git a/gcc/config/arc64/arc64.opt b/gcc/config/arc64/arc64.opt
new file mode 100644
index 00000000000..863b27a2a6d
--- /dev/null
+++ b/gcc/config/arc64/arc64.opt
@@ -0,0 +1,109 @@
+; Machine description for ARC64 architecture.
+; Copyright (C) 2019x Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it
+; under the terms of the GNU General Public License as published by
+; the Free Software Foundation; either version 3, or (at your option)
+; any later version.
+;
+; GCC is distributed in the hope that it will be useful, but
+; WITHOUT ANY WARRANTY; without even the implied warranty of
+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+; General Public License for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+HeaderInclude
+config/arc64/arc64-opts.h
+
+Enum
+Name(cmodel) Type(enum arc64_code_model)
+The code model option names for -mcmodel:
+
+EnumValue
+Enum(cmodel) String(small) Value(ARC64_CMODEL_SMALL)
+
+EnumValue
+Enum(cmodel) String(medium) Value(ARC64_CMODEL_MEDIUM)
+
+EnumValue
+Enum(cmodel) String(large) Value(ARC64_CMODEL_LARGE)
+
+mcmodel=
+Target RejectNegative Joined Enum(cmodel) Var(arc64_cmodel_var) Init(ARC64_CMODEL_MEDIUM) Save
+Specify the code model.
+
+Enum
+Name(arc64_atomic) Type(int)
+
+EnumValue
+Enum(arc64_atomic) String(0) Value(0)
+
+EnumValue
+Enum(arc64_atomic) String(1) Value(1)
+
+EnumValue
+Enum(arc64_atomic) String(2) Value(2)
+
+EnumValue
+Enum(arc64_atomic) String(3) Value(3)
+
+matomic=
+Target RejectNegative Joined Enum(arc64_atomic) Var(arc64_atomic_option) Init(DEFAULT_ARC64_ATOMIC_OPTION)
+-matomic=atomic	Enable atomic instructions: {0, 1, 2, 3}
+
+Enum
+Name(fpmodel) Type(int)
+
+EnumValue
+Enum(fpmodel) String(none) Value(0)
+
+EnumValue
+Enum(fpmodel) String(fpus) Value(1)
+
+EnumValue
+Enum(fpmodel) String(fpud) Value(2)
+
+mfpu=
+Target RejectNegative Joined Enum(fpmodel) Var(arc64_fp_model) Init(0)
+Specify hardware FP model used.
+
+mdiv-rem
+Target Report Var(TARGET_ARC64_DIVREM) Init(TARGET_ARC64_DIVREM_DEFAULT)
+Enable DIV-REM instructions.
+
+mbitscan
+Target Mask(BITSCAN)
+Enable NORM, NORMH, FFS, FLS, NORML, FFSL, and FLSL bitscan instructions.
+
+mcpu=
+Target RejectNegative Joined
+-mcpu= Generate code for specific ARCv3 CPU variant.
+
+munaligned-access
+Target Report Var(unaligned_access) Init(UNALIGNED_ACCESS_DEFAULT)
+Enable unaligned accesses to packed data.
+
+mvolatile-di
+Target Mask(VOLATILE_DI)
+Enable uncached access for volatile memories.
+
+mcode-density
+Target Report Mask(CODE_DENSITY)
+Enable code-density instructions.
+
+msimd
+Target Report Mask(SIMD)
+Enable integer SIMD instructions.
+
+mwide
+Target Report Mask(WIDE_SIMD)
+Enable wide floating point SIMD support.
+
+m128
+Target Report Mask(WIDE_LDST)
+Enable wide data transfer support.
diff --git a/gcc/config/arc64/arith.md b/gcc/config/arc64/arith.md
new file mode 100644
index 00000000000..0b966f7e901
--- /dev/null
+++ b/gcc/config/arc64/arith.md
@@ -0,0 +1,1868 @@
+;; -------------------------------------------------------------------
+;; Code Attributes
+;; -------------------------------------------------------------------
+(define_code_iterator COMMUTATIVE [and ior xor])
+
+(define_code_iterator COMMUTATIVEF [plus and ior xor])
+
+;; Operations which can be predicated non commutative
+(define_code_iterator ARITHP [minus ashift ashiftrt lshiftrt])
+
+(define_code_iterator BIT [ior xor])
+
+(define_code_iterator DIVREM [div udiv mod umod])
+
+(define_code_attr bit_optab [(plus   "adc")
+			     (minus  "sbc")
+			     (ior    "bset")
+			     (xor    "bxor")
+			     ])
+
+(define_code_iterator ADDSUB [plus minus] )
+
+;; SI instructions having short instruction variant
+(define_insn "*<optab><mode>_insn"
+  [(set (                match_operand:GPI 0 "register_operand"   "=q,q,     r,    r,     r,    r,    r,    r,r")
+	(COMMUTATIVE:GPI (match_operand:GPI 1 "nonmemory_operand" "%0,q,     0,    0,     r,U06S0,S12S0,S32S0,r")
+			 (match_operand:GPI 2 "nonmemory_operand" " q,0,rU06S0,S12S0,rU06S0,    r,    0,    r,S32S0")))]
+  "register_operand (operands[1], <MODE>mode)
+   || register_operand (operands[2], <MODE>mode)"
+  "@
+   <mntab><sfxtab>%?\\t%0,%1,%2
+   <mntab><sfxtab>%?\\t%0,%2,%1
+   <mntab><sfxtab>%?\\t%0,%1,%2
+   <mntab><sfxtab>%?\\t%0,%1,%2
+   <mntab><sfxtab>%?\\t%0,%1,%2
+   <mntab><sfxtab>%?\\t%0,%2,%1
+   <mntab><sfxtab>%?\\t%0,%2,%1
+   <mntab><sfxtab>%?\\t%0,%1,%2
+   <mntab><sfxtab>%?\\t%0,%1,%2"
+  [(set_attr "iscompact" "maybe,maybe,no,no,no,no,no,no,no")
+   (set_attr "predicable" "no,no,yes,no,no,no,no,no,no")
+   (set_attr "length"     "*,*,4,4,4,4,4,8,8")
+   (set_attr "type"       "<mntab>")]
+  )
+
+;; The zero extend variant of the above
+(define_insn "*<optab>si3_zextend"
+  [(set (match_operand:DI 0 "register_operand"   "=q,q,     r,    r,     r,    r,    r,    r,r")
+	(zero_extend:DI
+	 (COMMUTATIVE:SI
+	  (match_operand:SI 1 "nonmemory_operand" "%0,q,     0,    0,     r,U06S0,S12S0,S32S0,r")
+	  (match_operand:SI 2 "nonmemory_operand" " q,0,rU06S0,S12S0,rU06S0,    r,    0,    r,S32S0"))))]
+  "register_operand (operands[1], SImode)
+   || register_operand (operands[2], SImode)"
+  "@
+   <mntab>%?\\t%0,%1,%2
+   <mntab>%?\\t%0,%2,%1
+   <mntab>%?\\t%0,%1,%2
+   <mntab>%?\\t%0,%1,%2
+   <mntab>%?\\t%0,%1,%2
+   <mntab>%?\\t%0,%2,%1
+   <mntab>%?\\t%0,%2,%1
+   <mntab>%?\\t%0,%1,%2
+   <mntab>%?\\t%0,%1,%2"
+  [(set_attr "iscompact" "maybe,maybe,no,no,no,no,no,no,no")
+   (set_attr "predicable" "no,no,yes,no,no,no,no,no,no")
+   (set_attr "length"     "*,*,4,4,4,4,4,8,8")
+   (set_attr "type"       "<mntab>")]
+  )
+
+(define_insn "*<optab><mode>_insn"
+  [(set (            match_operand:GPI 0 "register_operand"  "=q,     r,    r,    r,    r,r")
+	(ASHIFT:GPI (match_operand:GPI 1 "nonmemory_operand" " 0,     0,    0,    r,S32S0,r")
+		    (match_operand:GPI 2 "nonmemory_operand" " q,rU06S0,S12S0,rU06S0,   r,S32S0")))]
+  "register_operand (operands[1], <MODE>mode)
+   || register_operand (operands[2], <MODE>mode)"
+  "<mntab><sfxtab>%?\\t%0,%1,%2"
+  [(set_attr "iscompact" "maybe,no,no,no,no,no")
+   (set_attr "predicable" "no,yes,no,no,no,no")
+   (set_attr "length"     "*,4,4,4,8,8")
+   (set_attr "type"       "<mntab>")]
+  )
+
+(define_insn "*sub<mode>_insn"
+  [(set (           match_operand:GPI 0 "register_operand"  "=q,    q,    q,     r,     r,    r,     r,    r,    r,    r,r")
+	(minus:GPI (match_operand:GPI 1 "nonmemory_operand" " 0,    0,    q,     0,rU06S0,    0,     r,U06S0,S12S0,S32S0,r")
+		   (match_operand:GPI 2 "nonmemory_operand" " q,U05S0,U03S0,rU06Sx,     0,S12S0,rU06Sx,    r,    0,    r,S32S0")))]
+  "register_operand (operands[1], <MODE>mode)
+   || register_operand (operands[2], <MODE>mode)"
+  "@
+   sub<sfxtab>%?\\t%0,%1,%2
+   sub<sfxtab>%?\\t%0,%1,%2
+   sub<sfxtab>%?\\t%0,%1,%2
+   sub%s2<sfxtab>%?\\t%0,%1,%S2
+   rsub<sfxtab>%?\\t%0,%2,%1
+   sub<sfxtab>%?\\t%0,%1,%2
+   sub%s2<sfxtab>%?\\t%0,%1,%S2
+   rsub<sfxtab>%?\\t%0,%2,%1
+   rsub<sfxtab>%?\\t%0,%2,%1
+   sub<sfxtab>%?\\t%0,%1,%2
+   sub<sfxtab>%?\\t%0,%1,%2"
+  [(set_attr "iscompact"  "yes,maybe,maybe,no,no,no,no,no,no,no,no")
+   (set_attr "predicable" "no,yes,no,yes,yes,no,no,no,no,no,no")
+   (set_attr "length"     "2,*,*,4,4,4,4,4,4,8,8")
+   (set_attr "type"       "sub")]
+  )
+
+;; zero extend of the above
+(define_insn "*subsi3r_zextend"
+  [(set (match_operand:DI 0 "register_operand"   "=q,r")
+	(zero_extend:DI
+	 (minus:SI
+	  (match_operand:SI 1 "register_operand" " 0,r")
+	  (match_operand:SI 2 "register_operand" " q,r"))))]
+  ""
+  "sub%?\\t%0,%1,%2"
+  [(set_attr "iscompact"  "yes,no")
+   (set_attr "length"     "2,4")
+   (set_attr "type"       "sub")]
+  )
+
+(define_insn "*add<mode>_insn"
+  [(set (          match_operand:GPI 0 "register_operand"  "=q, q,q,    q,     r,    r,    r,     r,    r,r")
+	(plus:GPI (match_operand:GPI 1 "register_operand"  "%0, 0,q,    q,     0,    0,    0,     r,    r,r")
+		  (match_operand:GPI 2 "nonmemory_operand" " q,qh,q,U03S0,rU06Sx,N06Sx,S12Sx,rU06Sx,N06Sx,S32S0")))]
+  "register_operand (operands[1], <MODE>mode)
+   || register_operand (operands[2], <MODE>mode)"
+  "@
+   add<sfxtab>%?\\t%0,%1,%2
+   add<sfxtab>%?\\t%0,%1,%2
+   add<sfxtab>%?\\t%0,%1,%2
+   add<sfxtab>%?\\t%0,%1,%2
+   add%s2<sfxtab>%?\\t%0,%1,%S2
+   sub%s2<sfxtab>%?\\t%0,%1,%N2
+   add%s2<sfxtab>%?\\t%0,%1,%S2
+   add%s2<sfxtab>%?\\t%0,%1,%S2
+   sub%s2<sfxtab>%?\\t%0,%1,%N2
+   add<sfxtab>%?\\t%0,%1,%2"
+  [(set_attr "iscompact"  "yes,maybe,maybe,maybe,no,no,no,no,no,no")
+   (set_attr "length"     "2,*,*,*,4,4,4,4,4,8")
+   (set_attr "type"       "add")]
+  )
+
+;; zero extend of the above
+(define_insn "*addsi3_zextend"
+  [(set (match_operand:DI 0 "register_operand"  "=q, q,q,    q,     r,    r,    r,     r,    r,r")
+	(zero_extend:DI
+	 (plus:SI (match_operand:SI 1 "register_operand"  "%0, 0,q,    q,     0,    0,    0,     r,    r,r")
+		  (match_operand:SI 2 "nonmemory_operand" " q,qh,q,U03S0,rU06Sx,N06Sx,S12Sx,rU06Sx,N06Sx,S32S0"))))]
+  "register_operand (operands[1], SImode)
+   || register_operand (operands[2], SImode)"
+  "@
+   add%?\\t%0,%1,%2
+   add%?\\t%0,%1,%2
+   add%?\\t%0,%1,%2
+   add%?\\t%0,%1,%2
+   add%s2%?\\t%0,%1,%S2
+   sub%s2%?\\t%0,%1,%N2
+   add%s2%?\\t%0,%1,%S2
+   add%s2%?\\t%0,%1,%S2
+   sub%s2%?\\t%0,%1,%N2
+   add%?\\t%0,%1,%2"
+  [(set_attr "iscompact"  "yes,maybe,maybe,maybe,no,no,no,no,no,no")
+   (set_attr "length"     "2,*,*,*,4,4,4,4,4,8")
+   (set_attr "type"       "add")])
+
+; Conditional execution
+(define_insn "*<optab><mode>_ce"
+  [(cond_exec
+    (match_operator 3 "arc64_comparison_operator"
+		    [(match_operand 4 "cc_register" "") (const_int 0)])
+    (set (match_operand:GPI 0 "register_operand"             "=     r,r")
+	 (ARITHP:GPI (match_operand:GPI 1 "register_operand"  "     0,0")
+		     (match_operand:GPI 2 "nonmemory_operand" "rU06S0,S32S0"))))]
+  ""
+  "<mntab><sfxtab>.%m3\\t%0,%1,%2"
+  [(set_attr "iscompact" "no")
+   (set_attr "length"     "4,8")
+   (set_attr "type"       "<mntab>")])
+
+(define_insn "*<optab><mode>_ce"
+  [(cond_exec
+    (match_operator 3 "arc64_comparison_operator"
+		    [(match_operand 4 "cc_register" "") (const_int 0)])
+    (set (match_operand:GPI 0 "register_operand"  "=     r,    r,r")
+	 (COMMUTATIVEF:GPI
+	  (match_operand:GPI 1 "nonmemory_operand" "     0,S32S0,0")
+	  (match_operand:GPI 2 "nonmemory_operand" "rU06S0,    0,S32S0"))))]
+  "register_operand (operands[1], <MODE>mode)
+   || register_operand (operands[2], <MODE>mode)"
+  "@
+   <mntab><sfxtab>.%m3\\t%0,%1,%2
+   <mntab><sfxtab>.%m3\\t%0,%2,%1
+   <mntab><sfxtab>.%m3\\t%0,%1,%2"
+  [(set_attr "iscompact" "no")
+   (set_attr "length"     "4,8,8")
+   (set_attr "type"       "<mntab>")])
+
+;; Arithmetic patterns used by the combiner.
+(define_insn "*bic<mode>3"
+  [(set (                  match_operand:GPI 0 "register_operand"  "=q,r,r,    r")
+	(and:GPI (not:GPI (match_operand:GPI 1 "register_operand"   "q,r,r,    r"))
+		 (         match_operand:GPI 2 "nonmemory_operand"  "0,0,r,S32S0")))]
+  ""
+  "bic<sfxtab>%?\\t%0,%2,%1"
+  [(set_attr "iscompact" "maybe,no,no,no")
+   (set_attr "predicable" "no,yes,no,no")
+   (set_attr "length"     "*,4,4,8")
+   (set_attr "type"       "bic")])
+
+(define_insn "*bic<mode>3_cmp0"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN
+	 (and:GPI
+	  (not:GPI (match_operand:GPI 1 "register_operand"   "r,r,    r"))
+	  (match_operand:GPI 2 "nonmemory_operand"  "0,r,S32S0"))
+	 (const_int 0)))
+   (set (match_operand:GPI 0 "register_operand"  "=r,r,r")
+	(and:GPI (not:GPI (match_dup 1)) (match_dup 2)))]
+  ""
+  "bic<sfxtab>%?.f\\t%0,%2,%1"
+  [(set_attr "iscompact" "no,no,no")
+   (set_attr "predicable" "yes,no,no")
+   (set_attr "length"     "4,4,8")
+   (set_attr "type"       "bic")])
+
+(define_insn "*bic<mode>3_cmp0_noout"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN
+	 (and:GPI
+	  (not:GPI (match_operand:GPI 0 "register_operand"   "r,r"))
+	  (match_operand:GPI 1 "nonmemory_operand"  "r,S32S0"))
+	 (const_int 0)))]
+  ""
+  "bic<sfxtab>.f\\t0,%1,%0"
+  [(set_attr "iscompact"  "no,no")
+   (set_attr "predicable" "no,no")
+   (set_attr "length"     "4,8")
+   (set_attr "type"       "bic")])
+
+(define_insn "*<bit_optab><mode>3"
+  [(set (match_operand:GPI 0 "register_operand" "=r,r,r")
+	(BIT:GPI
+	 (ashift:GPI
+	  (const_int 1)
+	  (match_operand:GPI 1 "register_operand" "r,r,r"))
+	 (match_operand:GPI 2 "nonmemory_operand" "0,r,S32S0")))]
+  ""
+  "<bit_optab><sfxtab>%?\\t%0,%2,%1"
+  [(set_attr "type" "<bit_optab>")
+   (set_attr "iscompact" "no")
+   (set_attr "length" "4,4,8")
+   (set_attr "predicable" "yes,no,no")])
+
+(define_insn "*bset<mode>3_cmp0"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN
+	 (BIT:GPI
+	  (ashift:GPI
+	   (const_int 1)
+	   (match_operand:GPI 1 "register_operand" "r,r,r"))
+	  (match_operand:GPI 2 "nonmemory_operand" "0,r,S32S0"))
+	 (const_int 0)))
+   (set (match_operand:GPI 0 "register_operand" "=r,r,r")
+	(BIT:GPI
+	 (ashift:GPI
+	  (const_int 1)
+	  (match_dup 1))
+	 (match_dup 2)))]
+  ""
+  "<bit_optab><sfxtab>%?.f\\t%0,%2,%1"
+  [(set_attr "type" "<bit_optab>")
+   (set_attr "iscompact" "no")
+   (set_attr "length" "4,4,8")
+   (set_attr "predicable" "yes,no,no")])
+
+(define_insn "*bset<mode>3_cmp0_noout"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN
+	 (BIT:GPI
+	  (ashift:GPI
+	   (const_int 1)
+	   (match_operand:GPI 0 "register_operand" "r,r"))
+	  (match_operand:GPI 1 "nonmemory_operand" "r,S32S0"))
+	 (const_int 0)))]
+  ""
+  "<bit_optab><sfxtab>.f\\t0,%1,%0"
+  [(set_attr "type" "<bit_optab>")
+   (set_attr "iscompact" "no")
+   (set_attr "length" "4,8")
+   (set_attr "predicable" "no,no")])
+
+(define_insn "<optab><mode>_cmp0"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN
+	 (COMMUTATIVEF:GPI
+	  (match_operand:GPI 1 "nonmemory_operand" "%     0,    0,     r,U06S0,S12S0,S32S0,r")
+	  (match_operand:GPI 2 "nonmemory_operand" " rU06S0,S12S0,rU06S0,    r,    0,    r,S32S0"))
+	 (const_int 0)))
+   (set (match_operand:GPI 0 "register_operand"  "=     r,    r,     r,    r,    r,    r,r")
+	(COMMUTATIVEF:GPI (match_dup 1) (match_dup 2)))]
+  "register_operand (operands[1], <MODE>mode)
+   || register_operand (operands[2], <MODE>mode)"
+  "@
+   <mntab><sfxtab>%?.f\\t%0,%1,%2
+   <mntab><sfxtab>%?.f\\t%0,%1,%2
+   <mntab><sfxtab>%?.f\\t%0,%1,%2
+   <mntab><sfxtab>%?.f\\t%0,%2,%1
+   <mntab><sfxtab>%?.f\\t%0,%2,%1
+   <mntab><sfxtab>%?.f\\t%0,%1,%2
+   <mntab><sfxtab>%?.f\\t%0,%1,%2"
+  [(set_attr "iscompact"  "no,no,no,no,no,no,no")
+   (set_attr "predicable" "yes,no,no,no,no,no,no")
+   (set_attr "length"     "4,4,4,4,4,8,8")
+   (set_attr "type"       "<mntab>")]
+  )
+
+(define_insn "*<optab><mode>_cmp0_noout"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN
+	 (COMMUTATIVEF:GPI
+	  (match_operand:GPI 0 "nonmemory_operand" "%     r,U06S0,S32S0,r")
+	  (match_operand:GPI 1 "nonmemory_operand" " rU06S0,    r,    r,S32S0"))
+	 (const_int 0)))]
+  "register_operand (operands[0], <MODE>mode)
+   || register_operand (operands[1], <MODE>mode)"
+  "@
+   <mntab><sfxtab>.f\\t0,%0,%1
+   <mntab><sfxtab>.f\\t0,%1,%0
+   <mntab><sfxtab>.f\\t0,%0,%1
+   <mntab><sfxtab>.f\\t0,%0,%1"
+  [(set_attr "iscompact"  "no")
+   (set_attr "predicable" "no")
+   (set_attr "length"     "4,4,8,8")
+   (set_attr "type"       "<mntab>")]
+  )
+
+(define_insn "*sub<mode>_insn_cmp0"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN
+	 (minus:GPI (match_operand:GPI 1 "nonmemory_operand" "    0,     r,U06S0,S12S0,S32S0,r")
+		    (match_operand:GPI 2 "nonmemory_operand" "S12S0,rU06Sx,    r,    0,    r,S32S0"))
+	 (const_int 0)))
+   (set (           match_operand:GPI 0 "register_operand"  "=    r,     r,    r,    r,    r,r")
+	(minus:GPI (match_dup 1) (match_dup 2)))]
+  "register_operand (operands[1], <MODE>mode)
+   || register_operand (operands[2], <MODE>mode)"
+  "@
+   sub<sfxtab>.f\\t%0,%1,%2
+   sub%s2<sfxtab>.f\\t%0,%1,%S2
+   rsub<sfxtab>.f\\t%0,%2,%1
+   rsub<sfxtab>.f\\t%0,%2,%1
+   sub<sfxtab>.f\\t%0,%1,%2
+   sub<sfxtab>.f\\t%0,%1,%2"
+  [(set_attr "iscompact"  "no")
+   (set_attr "length"     "4,4,4,4,8,8")
+   (set_attr "type"       "sub")]
+  )
+
+(define_insn "*sub<mode>_insn_cmp0_noout"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN
+	 (minus:GPI (match_operand:GPI 0 "nonmemory_operand" "     r,U06S0,S32S0,r")
+		    (match_operand:GPI 1 "nonmemory_operand" "rU06Sx,    r,    r,S32S0"))
+	 (const_int 0)))]
+  "register_operand (operands[0], <MODE>mode)
+   || register_operand (operands[1], <MODE>mode)"
+  "@
+   sub%s1<sfxtab>.f\\t0,%0,%S1
+   rsub<sfxtab>.f\\t0,%1,%0
+   sub<sfxtab>.f\\t0,%0,%1
+   sub<sfxtab>.f\\t0,%0,%1"
+  [(set_attr "iscompact"  "no")
+   (set_attr "length"     "4,4,8,8")
+   (set_attr "type"       "sub")]
+  )
+
+(define_insn "*<ANY_EXTEND:optab><SHORT:mode>si2_cmp0_noout"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN
+	 (ANY_EXTEND:SI (match_operand:SHORT 0 "register_operand" "r"))
+	 (const_int 0)))]
+  ""
+  "<ANY_EXTEND:mntab><SHORT:exttab>.f\\t0,%0"
+  [(set_attr "type" "<ANY_EXTEND:mntab>")
+   (set_attr "length" "4")])
+
+(define_insn "*extend<EXT:mode>di2_cmp0_noout"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN
+	 (sign_extend:DI (match_operand:EXT 0 "register_operand" "r"))
+	 (const_int 0)))]
+  ""
+  "sex<EXT:exttab>l.f\\t0,%0"
+  [(set_attr "type" "sex")
+   (set_attr "length" "4")])
+
+(define_insn "*<ANY_EXTEND:optab><SHORT:mode>si_cmp0"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN
+	 (ANY_EXTEND:SI (match_operand:SHORT 1 "register_operand" "r"))
+	 (const_int 0)))
+   (set (match_operand:SI 0 "register_operand" "=r")
+	(ANY_EXTEND:SI (match_dup 1)))]
+  ""
+  "<ANY_EXTEND:mntab><SHORT:exttab>.f\\t%0,%1"
+  [(set_attr "type" "<ANY_EXTEND:mntab>")
+   (set_attr "length" "4")])
+
+(define_insn "*extend<EXT:mode>di_cmp0"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN
+	 (sign_extend:DI (match_operand:EXT 1 "register_operand" "r"))
+	 (const_int 0)))
+   (set (match_operand:DI 0 "register_operand" "=r")
+	(sign_extend:DI (match_dup 1)))]
+  ""
+  "sex<EXT:exttab>l.f\\t%0,%1"
+  [(set_attr "type" "sex")
+   (set_attr "length" "4")])
+
+(define_insn "*btst<mode>"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN (zero_extract:GPI
+			(match_operand:GPI 0 "register_operand"   "q,r")
+			(const_int 1)
+			(match_operand 1 "const_int_operand" "U05S0,S12S0"))
+		       (const_int 0)))]
+  ""
+  "btst<sfxtab>%?\\t%0,%1"
+  [(set_attr "type" "btst")
+   (set_attr "length" "*,4")
+   (set_attr "iscompact" "maybe,no")
+   (set_attr "cost" "2,4")])
+
+;; SI/DI DIV/REM instructions.
+(define_expand "<optab><mode>3"
+  [(set (match_operand:GPI 0 "register_operand")
+	(DIVREM:GPI (match_operand:GPI 1 "nonmemory_operand")
+		    (match_operand:GPI 2 "nonmemory_operand")))]
+  "TARGET_ARC64_DIVREM"
+  {
+   if (<MODE>mode == DImode
+       && !register_operand (operands[2], DImode))
+     operands[2] = force_reg (DImode, operands[2]);
+   if (<MODE>mode == DImode
+       && !register_operand (operands[1], DImode))
+     operands[1] = force_reg (DImode, operands[1]);
+  }
+  )
+
+(define_insn "*<optab><mode>3"
+  [(set (match_operand:GPI 0 "register_operand"                 "=r,    r,    r,    r,r,    r,    r")
+	(DIVREM:GPI (match_operand:GPI 1 "arc64_nonmem_operand" " 0,    0,    0,    r,r,S32S0,    r")
+		    (match_operand:GPI 2 "arc64_nonmem_operand" " r,U06S0,S12S0,U06S0,r,    r,S32S0")))]
+  "TARGET_ARC64_DIVREM
+   && (register_operand (operands[1], <MODE>mode)
+       || register_operand (operands[2], <MODE>mode))"
+  "<mntab><sfxtab>%?\\t%0,%1,%2"
+  [(set_attr "predicable" "yes,yes,no,no,no,no,no")
+   (set_attr "length"     "4,4,4,4,4,8,8")
+   (set_attr "type"       "<optab><sfxtab>")]
+  )
+
+;; To be merged into adddi3
+(define_insn "*add_tls_off"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(plus:DI (match_operand:DI 1 "register_operand" "r")
+		 (unspec:DI [(match_operand 2 "" "")]
+			    ARC64_UNSPEC_TLS_OFF)))]
+  ""
+  "addl\\t%0,%1,%2@tpoff"
+  [(set_attr "type" "addl")
+   (set_attr "length" "8")]
+  )
+
+(define_insn "<optab>di3_cmp"
+  [(set (match_operand:DI 0 "register_operand"     "=r,    r,    r,    r,r,    r,    r")
+	(ADDSUB:DI (match_operand:DI 1 "arc64_nonmem_operand" " 0,    0,    0,    r,r,S32S0,    r")
+		   (match_operand:DI 2 "arc64_nonmem_operand" " r,U06S0,S12S0,U06S0,r,    r,S32S0")))
+   (set (reg:CC_C CC_REGNUM)
+	(compare:CC_C (ADDSUB:DI (match_dup 1)
+				 (match_dup 2))
+		      (match_dup 2)))]
+
+  "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)"
+  "<optab>l.f\\t%0,%1,%2"
+  [(set_attr "predicable" "yes,yes,no,no,no,no,no")
+   (set_attr "length"     "4,4,4,4,4,8,8")
+   (set_attr "type"       "<optab>l")]
+  )
+
+(define_insn "<optab>di3_carry"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(ADDSUB:DI
+	 (ADDSUB:DI (match_operand:DI 1 "register_operand" "r")
+		    (match_operand:DI 2 "register_operand" "r"))
+	 (ltu:DI (reg:CC_C CC_REGNUM) (const_int 0))))]
+  ""
+  "<bit_optab>l\\t%0,%1,%2"
+  [(set_attr "type" "<bit_optab>l")
+   (set_attr "length" "4")]
+)
+
+(define_expand "<optab>ti3"
+  [(set (match_operand:TI 0 "register_operand")
+	(ADDSUB:TI (match_operand:TI 1 "register_operand")
+		   (match_operand:TI 2 "nonmemory_operand")))]
+  ""
+{
+  rtx low_dest, op1_low, op2_low, high_dest, op1_high, op2_high;
+
+  high_dest = gen_highpart (DImode, operands[0]);
+  low_dest = gen_lowpart (DImode, operands[0]);
+  op1_high = gen_highpart (DImode, operands[1]);
+  op1_low = gen_lowpart (DImode, operands[1]);
+  op2_high = gen_highpart_mode (DImode, TImode, operands[2]);
+  op2_low = gen_lowpart (DImode, operands[2]);
+
+  emit_insn (gen_<optab>di3_cmp (low_dest, op1_low,
+				 force_reg (DImode, op2_low)));
+  emit_insn (gen_<optab>di3_carry (high_dest, op1_high,
+				   force_reg (DImode, op2_high)));
+
+  DONE;
+})
+
+;; Shifted adds and subs
+(define_insn "*add<mode>_shift"
+  [(set (match_operand:GPI 0 "register_operand" "=q,r,r,r")
+	(plus:GPI
+	 (ashift:GPI (match_operand:GPI 1 "register_operand" "q,r,r,r")
+		     (match_operand:GPI 2 "_1_2_3_operand" ""))
+	 (match_operand:GPI 3 "arc64_regsym_operand"  "0,0,r,S32S0SymMV")))]
+  ""
+  "add%2<sfxtab>%?\\t%0,%3,%1"
+  [(set_attr "type" "add")
+   (set_attr "length" "*,4,4,8")
+   (set_attr "predicable" "yes,yes,no,no")
+   (set_attr "iscompact" "maybe,no,no,no")])
+
+(define_insn "*addx<mode>_cmp0"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN
+	 (plus:GPI (ashift:GPI (match_operand:GPI 1 "register_operand" "r,r,r")
+			       (match_operand:GPI 2 "_1_2_3_operand" ""))
+		  (match_operand:GPI 3 "arc64_regsym_operand"  "0,r,S32S0SymMV"))
+	 (const_int 0)))
+   (set (match_operand:GPI 0 "register_operand" "=r,r,r")
+	(plus:GPI (ashift:GPI (match_dup 1) (match_dup 2))
+		  (match_dup 3)))]
+  ""
+  "add%2<sfxtab>%?.f\\t%0,%3,%1"
+  [(set_attr "type" "add<sfxtab>")
+   (set_attr "length" "4,4,8")
+   (set_attr "predicable" "yes,no,no")])
+
+(define_insn "*addx<mode>_cmp0_noout"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN
+	 (plus:GPI (ashift:GPI (match_operand:GPI 0 "register_operand" "r,r,r")
+			       (match_operand:GPI 1 "_1_2_3_operand" ""))
+		  (match_operand:GPI 2 "arc64_regsym_operand"  "0,r,S32S0SymMV"))
+	 (const_int 0)))]
+  ""
+  "add%1<sfxtab>%?.f\\t0,%2,%1"
+  [(set_attr "type" "add<sfxtab>")
+   (set_attr "length" "4,4,8")
+   (set_attr "predicable" "yes,no,no")])
+
+(define_insn "*sub<mode>_shift"
+  [(set (match_operand:GPI 0 "register_operand" "=r,r,r")
+	(minus:GPI (match_operand:GPI 1 "arc64_regsym_operand" "0,r,S32S0SymMV")
+		   (ashift:GPI (match_operand:GPI 2 "register_operand" "r,r,r")
+			       (match_operand:GPI 3 "_1_2_3_operand" ""))))]
+  ""
+  "sub%3<sfxtab>\\t%0,%1,%2"
+  [(set_attr "type" "sub<sfxtab>")
+   (set_attr "length" "4,4,8")
+   (set_attr "predicable" "yes,no,no")])
+
+(define_insn "*add<mode>_mult"
+  [(set (match_operand:GPI 0 "register_operand" "=q,r,r")
+	(plus:GPI
+	 (mult:GPI (match_operand:GPI 1 "register_operand" "q,r,r")
+		   (match_operand:GPI 2 "_2_4_8_operand" ""))
+	 (match_operand:GPI 3 "arc64_regsym_operand"  "0,r,S32S0SymMV")))]
+  ""
+  "add%s2<sfxtab>%?\\t%0,%3,%1"
+  [(set_attr "type" "add")
+   (set_attr "length" "*,4,8")
+   (set_attr "iscompact" "maybe,no,no")])
+
+(define_insn "*add<mode>_mult2"
+  [(set (match_operand:GPI 0 "register_operand" "=q,r,r")
+	(plus:GPI
+	 (match_operand:GPI 1 "nonmemory_operand"  "0,r,S32S0")
+	 (mult:GPI (match_operand:GPI 2 "register_operand" "q,r,r")
+		   (match_operand:GPI 3 "_2_4_8_operand" ""))))]
+  ""
+  "add%s3<sfxtab>%?\\t%0,%1,%2"
+  [(set_attr "type" "add")
+   (set_attr "length" "*,4,8")
+   (set_attr "iscompact" "maybe,no,no")])
+
+;; Multiplications
+
+(define_expand "<ANY_EXTEND:su_optab>mulhisi3"
+  [(set (match_operand:SI 0 "register_operand")
+	(mult:SI (ANY_EXTEND:SI (match_operand:HI 1 "register_operand"))
+		 (ANY_EXTEND:SI (match_operand:HI 2 "nonmemory_operand"))))]
+   ""
+   "
+    if (CONSTANT_P (operands[2]))
+    {
+      operands[2] = force_reg (HImode, operands[2]);
+    }
+   "
+  )
+
+(define_insn "*<ANY_EXTEND:su_optab>mulhisi3r"
+  [(set (match_operand:SI 0 "register_operand"                         "=q,r,r")
+	(mult:SI (ANY_EXTEND:SI (match_operand:HI 1 "register_operand" "%0,0,r"))
+		 (ANY_EXTEND:SI (match_operand:HI 2 "register_operand"  "q,r,r"))))]
+  ""
+  "mpy<ANY_EXTEND:su_optab>w%?\\t%0,%1,%2"
+  [(set_attr "length" "*,4,4")
+   (set_attr "iscompact" "maybe,no,no")
+   (set_attr "type" "mpy")
+   (set_attr "predicable" "yes,yes,no")
+   ])
+
+(define_insn "*<ANY_EXTEND:su_optab>mulhisi3rze"
+  [(set (match_operand:DI 0 "register_operand"                         "=q,r,r")
+	(zero_extend:DI
+	 (mult:SI (ANY_EXTEND:SI (match_operand:HI 1 "register_operand" "%0,0,r"))
+		  (ANY_EXTEND:SI (match_operand:HI 2 "register_operand"  "q,r,r")))))]
+  ""
+  "mpy<ANY_EXTEND:su_optab>w%?\\t%0,%1,%2"
+  [(set_attr "length" "*,4,4")
+   (set_attr "iscompact" "maybe,no,no")
+   (set_attr "type" "mpy")
+   (set_attr "predicable" "yes,yes,no")
+   ])
+
+(define_insn "*<ANY_EXTEND:su_optab>mulhisi3r_ce"
+  [(cond_exec
+    (match_operator 3 "arc64_comparison_operator"
+		    [(match_operand 4 "cc_register" "") (const_int 0)])
+   (set (match_operand:SI 0 "register_operand"                         "=r")
+	(mult:SI (ANY_EXTEND:SI (match_operand:HI 1 "register_operand" "%0"))
+		 (ANY_EXTEND:SI (match_operand:HI 2 "register_operand"  "r")))))]
+  ""
+  "mpy<ANY_EXTEND:su_optab>w.%m3\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "mpy")
+   ])
+
+(define_insn "mulhisi3i"
+  [(set (match_operand:SI 0 "register_operand"            "=r,    r,    r,r,r")
+	(mult:SI
+	 (sign_extend:SI
+	  (match_operand:HI 1 "register_operand"          "%0,    r,    0,0,r"))
+	 (match_operand:HI 2 "short_immediate_operand" "U06S0,U06S0,S12S0,S16S0,S16S0")))]
+  ""
+  "mpyw%?\\t%0,%1,%2"
+  [(set_attr "length" "4,4,4,8,8")
+   (set_attr "type" "mpy")
+   (set_attr "predicable" "yes,no,no,yes,no")])
+
+(define_insn "umulhisi3i"
+  [(set (match_operand:SI 0 "register_operand"            "=r,     r,    r,r,r")
+	(mult:SI
+	 (zero_extend:SI
+	  (match_operand:HI 1 "register_operand"           "%0,    r,    0,0,r"))
+	 (match_operand:HI 2 "unsign_immediate_operand" "U06S0,U06S0,U12S0,U16S0,U16S0")))]
+  ""
+  "mpyuw%?\\t%0,%1,%2"
+  [(set_attr "length" "4,4,4,8,8")
+   (set_attr "type" "mpy")
+   (set_attr "predicable" "yes,no,no,yes,no")])
+
+;faulty;(define_insn "<ANY_EXTEND:su_optab>mulhisi3ize"
+;faulty;  [(set (match_operand:DI 0 "register_operand"              "=r,    r,    r,r,r")
+;faulty;	(zero_extend:DI
+;faulty;	 (mult:SI (ANY_EXTEND:SI
+;faulty;		   (match_operand:HI 1 "register_operand"    "%0,    r,    0,0,r"))
+;faulty;		  (match_operand:HI 2 "immediate_operand" "U06S0,U06S0,S12S0,i,i"))))]
+;faulty;  ""
+;faulty;  "mpy<ANY_EXTEND:su_optab>w%?\\t%0,%1,%2"
+;faulty;  [(set_attr "length" "4,4,4,8,8")
+;faulty;   (set_attr "type" "mpy")
+;faulty;   (set_attr "predicable" "yes,no,no,yes,no")])
+
+(define_insn "*mul<mode>3"
+ [(set (match_operand:GPI 0 "register_operand"             "=q,q,     r,     r,    r,    r,    r")
+       (mult:GPI (match_operand:GPI 1 "register_operand"  "%0,q,     0,     r,    0,    0,    r")
+		 (match_operand:GPI 2 "nonmemory_operand"  "q,0,rU06S0,rU06S0,S12S0,S32S0,S32S0")))]
+ ""
+ "@
+  mpy<sfxtab>%?\\t%0,%1,%2
+  mpy<sfxtab>%?\\t%0,%2,%1
+  mpy<sfxtab>%?\\t%0,%1,%2
+  mpy<sfxtab>%?\\t%0,%1,%2
+  mpy<sfxtab>%?\\t%0,%1,%2
+  mpy<sfxtab>%?\\t%0,%1,%2
+  mpy<sfxtab>%?\\t%0,%1,%2"
+ [(set_attr "length" "*,*,4,4,4,8,8")
+  (set_attr "iscompact" "maybe,maybe,no,no,no,no,no")
+  (set_attr "type" "mpy<sfxtab>")
+  (set_attr "predicable" "no,no,yes,no,no,yes,no")])
+
+(define_insn "*mulsi3ze"
+  [(set (match_operand:DI 0 "register_operand"             "=q,q,     r,     r,    r,    r,    r")
+	(zero_extend:DI
+	 (mult:SI
+	  (match_operand:SI 1 "register_operand"  "%0,q,     0,     r,    0,    0,    r")
+	  (match_operand:SI 2 "nonmemory_operand"  "q,0,rU06S0,rU06S0,S12S0,S32S0,S32S0"))))]
+ ""
+ "@
+  mpy%?\\t%0,%1,%2
+  mpy%?\\t%0,%2,%1
+  mpy%?\\t%0,%1,%2
+  mpy%?\\t%0,%1,%2
+  mpy%?\\t%0,%1,%2
+  mpy%?\\t%0,%1,%2
+  mpy%?\\t%0,%1,%2"
+ [(set_attr "length" "*,*,4,4,4,8,8")
+  (set_attr "iscompact" "yes,yes,no,no,no,no,no")
+  (set_attr "type" "mpy")
+  (set_attr "predicable" "no,no,yes,no,no,yes,no")])
+
+(define_insn "*mul<mode>3_ce"
+  [(cond_exec
+    (match_operator 3 "arc64_comparison_operator"
+		    [(match_operand 4 "cc_register" "") (const_int 0)])
+    (set (match_operand:GPI 0 "register_operand"             "=     r,    r")
+	 (mult:GPI (match_operand:GPI 1 "register_operand"  "%     0,    0")
+		   (match_operand:GPI 2 "nonmemory_operand"  "rU06S0,S32S0"))))]
+ ""
+ "mpy<sfxtab>.%m3\\t%0,%1,%2"
+ [(set_attr "length" "4,8")
+  (set_attr "type" "mpy<sfxtab>")])
+
+(define_insn "*mulsi3_cmp0"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN
+	 (mult:SI
+	  (match_operand:SI 1 "register_operand"  "%     0,     r,    0,    0,    r")
+	  (match_operand:SI 2 "nonmemory_operand"  "rU06S0,rU06S0,S12S0,S32S0,S32S0"))
+	 (const_int 0)))
+   (set (match_operand:SI 0 "register_operand"   "=     r,     r,    r,    r,    r")
+	(mult:SI (match_dup 1) (match_dup 2)))]
+ ""
+ "mpy%?.f\\t%0,%1,%2"
+ [(set_attr "length" "4,4,4,8,8")
+  (set_attr "iscompact" "no,no,no,no,no")
+  (set_attr "type" "mpy")
+  (set_attr "predicable" "yes,no,no,yes,no")])
+
+(define_insn "*mulsi3_cmp0_noout"
+  [(set (reg:CC_ZN CC_REGNUM)
+	(compare:CC_ZN
+	 (mult:SI
+	  (match_operand:SI 0 "register_operand"  "%     r,    r,    r")
+	  (match_operand:SI 1 "nonmemory_operand"  "rU06S0,S12S0,S32S0"))
+	 (const_int 0)))]
+ ""
+ "mpy%?.f\\t0,%0,%1"
+ [(set_attr "length" "4,4,8")
+  (set_attr "iscompact" "no,no,no")
+  (set_attr "type" "mpy")
+  (set_attr "predicable" "no,no,no")])
+
+(define_insn "<su>mulsi3_highpart"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(truncate:SI
+	 (lshiftrt:DI
+	  (mult:DI
+	   (ANY_EXTEND:DI (match_operand:SI 1 "register_operand" "%0,r"))
+	   (ANY_EXTEND:DI (match_operand:SI 2 "register_operand"  "r,r")))
+	  (const_int 32))))]
+  ""
+  "mpym<su_optab>%?\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "mpy")
+   (set_attr "predicable" "yes,no")])
+
+(define_insn "<su>muldi3_highpart"
+  [(set (match_operand:DI 0 "register_operand" "=r,r")
+	(truncate:DI
+	 (lshiftrt:TI
+	  (mult:TI
+	   (ANY_EXTEND:TI (match_operand:DI 1 "register_operand" "%0,r"))
+	   (ANY_EXTEND:TI (match_operand:DI 2 "register_operand" "r,r")))
+	  (const_int 64))))]
+  ""
+  "mpym<su_optab>l%?\\t%0,%1,%2"
+  [(set_attr "type" "mpyl")
+   (set_attr "length" "4")
+   (set_attr "predicable" "yes,no")])
+
+(define_expand "<su_optab>mulditi3"
+  [(set (match_operand:TI 0 "register_operand")
+	(mult:TI (ANY_EXTEND:TI (match_operand:DI 1 "register_operand"))
+		 (ANY_EXTEND:TI (match_operand:DI 2 "register_operand"))))]
+  ""
+{
+  rtx low = gen_reg_rtx (DImode);
+  emit_insn (gen_muldi3 (low, operands[1], operands[2]));
+
+  rtx high = gen_reg_rtx (DImode);
+  emit_insn (gen_<su>muldi3_highpart (high, operands[1], operands[2]));
+
+  emit_move_insn (gen_lowpart (DImode, operands[0]), low);
+  emit_move_insn (gen_highpart (DImode, operands[0]), high);
+  DONE;
+})
+
+(define_expand "usmulditi3"
+  [(set (match_operand:TI                          0 "register_operand")
+	(mult:TI (zero_extend:TI (match_operand:DI 1 "register_operand"))
+		 (sign_extend:TI (match_operand:DI 2 "register_operand"))))]
+  ""
+{
+  rtx low = gen_reg_rtx (DImode);
+  emit_insn (gen_muldi3 (low, operands[1], operands[2]));
+
+  rtx high = gen_reg_rtx (DImode);
+  emit_insn (gen_usmuldi3_highpart (high, operands[1], operands[2]));
+
+  emit_move_insn (gen_lowpart (DImode, operands[0]), low);
+  emit_move_insn (gen_highpart (DImode, operands[0]), high);
+  DONE;
+})
+
+(define_insn "usmuldi3_highpart"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(truncate:DI
+	 (lshiftrt:TI
+	  (mult:TI (zero_extend:TI
+		    (match_operand:DI 1 "register_operand"  "r"))
+		   (sign_extend:TI
+		    (match_operand:DI 2 "register_operand" " r")))
+	  (const_int 64))))]
+  ""
+  "mpymsul\t%0,%2,%1"
+  [(set_attr "type" "mpyl")
+   (set_attr "length" "4")])
+
+;; 16bit operations using SIMD instructions
+(define_insn "<optab>hi3"
+  [(set (match_operand:HI 0 "register_operand"       "=r,    r,r")
+	(ADDSUB:HI
+	 (match_operand:HI 1 "register_operand"       "r,    0,r")
+	 (match_operand:HI 2 "nonmemory_operand" "rU06S0,S12S0,i")))]
+  "TARGET_SIMD"
+  "v<optab>2h\\t%0,%1,%2"
+   [(set_attr "length"     "4,4,8")
+   (set_attr "type"       "v<optab>")])
+
+;; -------------------------------------------------------------------
+;; Integer SIMD instructions
+;; -------------------------------------------------------------------
+
+(define_expand "mov<mode>"
+  [(set (match_operand:VALL 0 "nonimmediate_operand")
+	(match_operand:VALL 1 "general_operand"))]
+  "TARGET_SIMD"
+  "
+   if (arc64_prepare_move_operands (operands[0], operands[1], <MODE>mode))
+    DONE;
+  ")
+
+(define_expand "movmisalign<mode>"
+  [(set (match_operand:VALL 0 "nonimmediate_operand")
+	(match_operand:VALL 1 "general_operand"))]
+  "TARGET_SIMD && !STRICT_ALIGNMENT"
+  {
+   if (!register_operand (operands[0], <MODE>mode)
+       && !register_operand (operands[1], <MODE>mode))
+    operands[1] = force_reg (<MODE>mode, operands[1]);
+  })
+
+(define_insn "*mov<mode>_insn"
+  [(set (match_operand:VALL 0 "arc64_dest_operand"  "=r,r,m")
+	(match_operand:VALL 1 "nonimmediate_operand" "r,m,r"))]
+  "TARGET_SIMD
+   && (register_operand (operands[0], <MODE>mode)
+       || register_operand (operands[1], <MODE>mode))"
+  "@
+   mov<mcctab>\\t%0,%1
+   ld<mcctab>%U1\\t%0,%1
+   st<mcctab>%U0\\t%1,%0"
+  [(set_attr "type" "move,ld,st")])
+
+(define_insn "<optab><mode>3"
+  [(set (match_operand:VALL 0 "register_operand"           "=r")
+	(ADDSUB:VALL (match_operand:VALL 1 "register_operand" "r")
+		     (match_operand:VALL 2 "register_operand" "r")))]
+  "TARGET_SIMD"
+  "v<mntab><sfxtab>\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "v<mntab>")])
+
+(define_insn "neg<mode>2"
+  [(set (match_operand:VALL 0 "register_operand" "=r")
+	(neg:VALL (match_operand:VALL 1 "register_operand" "r")))]
+  "TARGET_SIMD"
+  "vsub<sfxtab>\\t%0,0,%1"
+  [(set_attr "length" "8")
+   (set_attr "type" "vsub")])
+
+(define_expand "vec_widen_<su>mult_lo_v4hi"
+ [(match_operand:V2SI 0 "register_operand")
+  (ANY_EXTEND:V2SI (match_operand:V4HI 1 "register_operand"))
+  (ANY_EXTEND:V2SI (match_operand:V4HI 2 "register_operand"))]
+  "TARGET_SIMD"
+  {
+    emit_insn (gen_arc64_<su>vmpy2h (operands[0],
+				     operands[1],
+				     operands[2]));
+    DONE;
+  })
+
+(define_expand "vec_widen_<su>mult_hi_v4hi"
+ [(match_operand:V2SI 0 "register_operand")
+  (ANY_EXTEND:V2SI (match_operand:V4HI 1 "register_operand"))
+  (ANY_EXTEND:V2SI (match_operand:V4HI 2 "register_operand"))]
+  "TARGET_SIMD"
+  {
+   rtx tmp1 = gen_reg_rtx (V4HImode);
+   rtx tmp2 = gen_reg_rtx (V4HImode);
+   emit_insn (gen_arc64_swapl (tmp1, operands[1]));
+   emit_insn (gen_arc64_swapl (tmp2, operands[2]));
+   emit_insn (gen_arc64_<su>vmpy2h (operands[0], tmp1, tmp2));
+   DONE;
+  })
+
+ (define_insn "arc64_<su>vmpy2h"
+   [(set (match_operand:V2SI 0 "register_operand"  "=r")
+	 (mult:V2SI
+	  (ANY_EXTEND:V2SI
+	   (vec_select:V2HI
+	    (match_operand:V4HI 1 "register_operand" "r")
+	    (parallel [(const_int 0) (const_int 1)])))
+	  (ANY_EXTEND:V2SI
+	   (vec_select:V2HI
+	    (match_operand:V4HI 2 "register_operand" "r")
+	    (parallel [(const_int 0) (const_int 1)])))))
+    (clobber (reg:V2SI R58_REGNUM))]
+   "TARGET_SIMD"
+   "vmpy2h<su_optab>\\t%0,%1,%2"
+   [(set_attr "length" "4")
+    (set_attr "type" "vmpy2h")])
+
+(define_insn "arc64_swapl"
+  [(set (match_operand:V4HI 0 "register_operand" "=r")
+	(vec_concat:V4HI
+	 (vec_select:V2HI (match_operand:V4HI 1 "register_operand" "r")
+			  (parallel [(const_int 2) (const_int 3)]))
+	 (vec_select:V2HI (match_dup 1) (parallel [(const_int 0) (const_int 1)]))))]
+  "TARGET_SIMD"
+  "swapl\\t%0,%1"
+   [(set_attr "length" "4")
+    (set_attr "type" "swapl")])
+
+(define_expand "<su>dot_prodv4hi"
+  [(match_operand:V2SI 0 "register_operand")
+   (ANY_EXTEND:V2SI (match_operand:V4HI 1 "register_operand"))
+   (ANY_EXTEND:V2SI (match_operand:V4HI 2 "register_operand"))
+   (match_operand:V2SI 3 "register_operand")]
+  "TARGET_SIMD"
+{
+ rtx acc_reg  = gen_rtx_REG  (V2SImode, R58_REGNUM);
+ rtx op1_high = gen_reg_rtx (V4HImode);
+ rtx op2_high = gen_reg_rtx (V4HImode);
+
+ emit_move_insn (acc_reg, operands[3]);
+ emit_insn (gen_arc64_swapl (op1_high, operands[1]));
+ emit_insn (gen_arc64_swapl (op2_high, operands[2]));
+ emit_insn (gen_arc64_<su>vmach_zero (operands[1], operands[2]));
+ emit_insn (gen_arc64_<su>vmach (operands[0], op1_high, op2_high));
+ DONE;
+})
+
+(define_insn "arc64_<su>vmach"
+ [(set (match_operand:V2SI 0 "register_operand" "=r")
+       (plus:V2SI
+	(mult:V2SI
+	 (ANY_EXTEND:V2SI
+	  (vec_select:V2HI (match_operand:V4HI 1 "register_operand" "r")
+			   (parallel [(const_int 0) (const_int 1)])))
+	 (ANY_EXTEND:V2SI
+	  (vec_select:V2HI (match_operand:V4HI 2 "register_operand" "r")
+			   (parallel [(const_int 0) (const_int 1)]))))
+	(reg:V2SI R58_REGNUM)))
+  (clobber (reg:V2SI R58_REGNUM))]
+  "TARGET_SIMD"
+  "vmac2h<su_optab>%?\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "vmac2h")])
+
+(define_insn "arc64_<su>vmach_zero"
+ [(set (reg:V2SI R58_REGNUM)
+       (plus:V2SI
+	(mult:V2SI
+	 (ANY_EXTEND:V2SI
+	  (vec_select:V2HI (match_operand:V4HI 0 "register_operand" "r")
+			   (parallel [(const_int 0) (const_int 1)])))
+	 (ANY_EXTEND:V2SI
+	  (vec_select:V2HI (match_operand:V4HI 1 "register_operand" "r")
+			   (parallel [(const_int 0) (const_int 1)]))))
+	(reg:V2SI R58_REGNUM)))]
+  "TARGET_SIMD"
+  "vmac2h<su_optab>%?\\t0,%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "vmac2h")])
+
+;; FIXME! for v2hi -> dmpyh
+(define_insn "reduc_plus_scal_v4hi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(unspec:HI [(match_operand:V4HI 1 "register_operand" "r")]
+		   ARC64_UNSPEC_QMPYH))
+   (clobber (reg:DI R58_REGNUM))]
+  "TARGET_SIMD"
+  "qmpyh\\t%0,%1,1"
+  [(set_attr "length" "4")
+   (set_attr "type" "qmpyh")])
+
+(define_insn "reduc_plus_scal_v2si"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(match_operand:V2SI 1 "register_operand" "r")]
+		   ARC64_UNSPEC_DMPYWH))
+   (clobber (reg:DI R58_REGNUM))]
+  "TARGET_SIMD"
+  "dmpywh\\t%0,%1,1"
+  [(set_attr "length" "4")
+   (set_attr "type" "dmpywh")])
+
+;; FIXME! for v2hi -> dmach
+(define_expand "fold_left_plus_v4hi"
+  [(set (match_operand:HI 0 "register_operand")
+        (unspec:HI [(match_operand:HI 1 "register_operand")
+                    (match_operand:V4HI 2 "register_operand")]
+                   ARC64_UNSPEC_QMACH))
+   (clobber (reg:DI R58_REGNUM))]
+  "TARGET_SIMD"
+  {
+    rtx acc_reg = gen_rtx_REG (HImode, R58_REGNUM);
+    emit_move_insn (acc_reg, operands[1]);
+    operands[1] = acc_reg;
+  })
+
+(define_insn "*qmach"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (unspec:HI [(reg:HI R58_REGNUM)
+                    (match_operand:V4HI 1 "register_operand" "r")]
+                   ARC64_UNSPEC_QMACH))
+   (clobber (reg:DI R58_REGNUM))]
+  "TARGET_SIMD"
+  "qmach\\t%0,%1,1"
+  [(set_attr "length" "4")
+   (set_attr "type" "qmach")])
+
+(define_expand "mulv2hi3"
+  [(set (match_operand:V2HI 0 "register_operand")
+	(mult:V2HI (match_operand:V2HI 1 "register_operand")
+		   (match_operand:V2HI 2 "register_operand")))]
+  "TARGET_SIMD"
+  {
+    rtx tmp = gen_reg_rtx (V2SImode);
+    emit_insn (gen_arc64_svmpy2h_lo (tmp, operands[1], operands[2]));
+    emit_insn (gen_arc64_packv2hi_lo (operands[0], tmp));
+    DONE;
+  })
+
+(define_insn "arc64_packv2hi_lo"
+  [(set (match_operand:V2HI 0 "register_operand" "=r")
+	(unspec:V2HI [(match_operand:V2SI 1 "register_operand" "r")
+		      (const_int 0)]
+		     ARC64_UNSPEC_VPACK4HL))]
+  "TARGET_SIMD"
+  "vpack4hl\\t%0,%1,0"
+  [(set_attr "length" "4")
+   (set_attr "type" "vpack")])
+
+(define_expand "<su>mulv2hi3_highpart"
+  [(match_operand:V2HI 0 "register_operand")
+   (ANY_EXTEND:SI (match_operand:V2HI 1 "register_operand"))
+   (ANY_EXTEND:SI (match_operand:V2HI 2 "register_operand"))]
+  "TARGET_SIMD"
+  {
+    rtx tmp = gen_reg_rtx (V2SImode);
+    emit_insn (gen_arc64_<su>vmpy2h_lo (tmp, operands[1], operands[2]));
+    emit_insn (gen_arc64_packv2hi_hi (operands[0], tmp));
+    DONE;
+  })
+
+(define_insn "arc64_packv2hi_hi"
+  [(set (match_operand:V2HI 0 "register_operand" "=r")
+	(unspec:V2HI [(match_operand:V2SI 1 "register_operand" "r")
+		      (const_int 1)]
+		     ARC64_UNSPEC_VPACK4HM))]
+  "TARGET_SIMD"
+  "vpack4hm\\t%0,%1,0"
+  [(set_attr "length" "4")
+   (set_attr "type" "vpack")])
+
+ (define_insn "arc64_<su>vmpy2h_lo"
+   [(set (match_operand:V2SI 0 "register_operand"  "=r")
+	 (mult:V2SI
+	  (ANY_EXTEND:V2SI
+	    (match_operand:V2HI 1 "register_operand" "r"))
+	  (ANY_EXTEND:V2SI
+	    (match_operand:V2HI 2 "register_operand" "r"))))
+    (clobber (reg:V2SI R58_REGNUM))]
+   "TARGET_SIMD"
+   "vmpy2h<su_optab>\\t%0,%1,%2"
+   [(set_attr "length" "4")
+    (set_attr "type" "vmpy2h")])
+
+(define_expand "mulv4hi3"
+  [(match_operand:V4HI 0 "register_operand")
+   (match_operand:V4HI 1 "register_operand")
+   (match_operand:V4HI 2 "register_operand")]
+  "TARGET_SIMD"
+  {
+    rtx tmpA = gen_reg_rtx (V2SImode);
+    rtx tmpB = gen_reg_rtx (V2SImode);
+    rtx tmp1 = gen_reg_rtx (V4HImode);
+    rtx tmp2 = gen_reg_rtx (V4HImode);
+    emit_insn (gen_arc64_swapl (tmp1, operands[1]));
+    emit_insn (gen_arc64_swapl (tmp2, operands[2]));
+    emit_insn (gen_arc64_svmpy2h (tmpA, operands[1], operands[2]));
+    emit_insn (gen_arc64_svmpy2h (tmpB, tmp1, tmp2));
+    emit_insn (gen_arc64_pack4hi (operands[0], tmpA, tmpB));
+    DONE;
+    })
+
+(define_insn "arc64_pack4hi"
+  [(set (match_operand:V4HI 0 "register_operand" "=r")
+	(unspec:V4HI [(match_operand:V2SI 1 "register_operand" "r")
+		      (match_operand:V2SI 2 "register_operand" "r")]
+		     ARC64_UNSPEC_VPACK4HL))]
+  "TARGET_SIMD"
+  "vpack4hl\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "vpack")])
+
+(define_insn "bswap<mode>2"
+  [(set (match_operand:VALL 0 "register_operand" "=r")
+	(bswap:VALL (match_operand:VALL 1 "register_operand" "r")))]
+  "TARGET_SIMD"
+  "swap<mcctab>e\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "swap")])
+
+(define_insn "vec_extract<mode>"
+  [(set (match_operand:<VEL> 0 "register_operand" "=r")
+	(vec_select:<VEL> (match_operand:VALL 1 "register_operand" "r")
+			  (parallel [(match_operand:SI 2 "const_int_operand" "n")])))]
+  "TARGET_SIMD"
+  {
+    HOST_WIDE_INT elem = INTVAL (operands[2]);
+    gcc_assert (elem < 4);
+    elem = (((<vextrsz> - 1) & <vextrmsk>) << <vextrsh>)
+      | ((elem * <vextrsz>) & <vextrmsk>);
+    operands[2] = GEN_INT (elem);
+    return "xbfu<mcctab>\\t%0,%1,%2";
+  }
+  [(set_attr "length" "8")
+   (set_attr "type" "xbfu")])
+
+;; Alternative
+;;   emit_insn (gen_arc64_swap (tmpA, operands[1])); swap tmpA op1
+;;   emit_insn (gen_arc64_sel_lo (tmpB, operands[1])); bmask tmpB,15
+;;   emit_insn (gen_arc64_pack2si (operands[0], tmpB, tmpA)); vpack4hl op0,tmpB,tmpA
+(define_expand "vec_unpacku_lo_v4hi"
+  [(set (match_operand:V2SI 0 "register_operand")
+        (zero_extend:V2SI
+         (vec_select:V2HI
+          (match_operand:V4HI 1 "register_operand")
+          (parallel [(const_int 0)(const_int 1)]))))]
+  "TARGET_SIMD"
+ {
+   rtx tmpA = gen_reg_rtx (HImode);
+   rtx tmpB = gen_reg_rtx (HImode);
+
+   emit_insn (gen_vec_extractv4hi (tmpA, operands[1], GEN_INT (0)));
+   emit_insn (gen_vec_extractv4hi (tmpB, operands[1], GEN_INT (1)));
+   emit_insn (gen_arc64_vec_concat (operands[0], tmpA, tmpB));
+   DONE;
+ })
+
+;; Alternative
+;;   emit_insn (gen_arc64_swapl (tmp0, operands[1]));
+;;   emit_insn (gen_arc64_swap (tmpA, tmp0));
+;;   emit_insn (gen_arc64_sel_lo (tmpB, tmp0));
+;;   emit_insn (gen_arc64_pack2si (operands[0], tmpB, tmpA));
+(define_expand "vec_unpacku_hi_v4hi"
+  [(set (match_operand:V2SI 0 "register_operand")
+        (zero_extend:V2SI
+         (vec_select:V2HI
+          (match_operand:V4HI 1 "register_operand")
+          (parallel [(const_int 2)(const_int 3)]))))]
+  "TARGET_SIMD"
+ {
+   rtx tmpA = gen_reg_rtx (HImode);
+   rtx tmpB = gen_reg_rtx (HImode);
+
+   emit_insn (gen_vec_extractv4hi (tmpA, operands[1], GEN_INT (2)));
+   emit_insn (gen_vec_extractv4hi (tmpB, operands[1], GEN_INT (3)));
+   emit_insn (gen_arc64_vec_concat (operands[0], tmpA, tmpB));
+   DONE;
+ })
+
+(define_insn "arc64_vec_concat"
+  [(set (match_operand:V2SI 0 "register_operand" "=r")
+	(unspec:V2SI [(match_operand:HI 1 "register_operand" "r")
+		      (match_operand:HI 2 "register_operand" "r")]
+		     ARC64_UNSPEC_VPACK2WL))]
+  "TARGET_SIMD"
+  "vpack2wl\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "vpack")])
+
+(define_expand "vec_duplicatev4hi"
+  [(set (match_operand:V4HI 0 "register_operand")
+	(vec_duplicate:V4HI (match_operand:HI 1 "register_operand")))]
+ "TARGET_SIMD"
+ {
+   rtx tmp = gen_reg_rtx (V2SImode);
+   emit_insn (gen_arc64_duplicate_v2hi(tmp, operands[1]));
+   emit_insn (gen_arc64_pack4hi(operands[0], tmp, tmp));
+   DONE;
+ })
+
+(define_insn "arc64_duplicate_v2hi"
+  [(set (match_operand:V2SI 0 "register_operand" "=r")
+	(unspec:V2SI [(match_operand:HI 1 "register_operand" "r")
+		      (const_int 0)]
+		     ARC64_UNSPEC_VPACK4HL))]
+  "TARGET_SIMD"
+  "vpack4hl\\t%0,%1,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "vpack")])
+
+(define_insn "vec_duplicatev2si"
+  [(set (match_operand:V2SI 0 "register_operand" "=r")
+	(vec_duplicate:V2SI (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_SIMD"
+  "vpack2wl\\t%0,%1,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "vpack")])
+
+(define_insn "vec_shr_<mode>"
+  [(set (match_operand:V64I 0 "register_operand" "=r,r")
+	(unspec:V64I [(match_operand:V64I 1 "register_operand"  "0,r")
+		      (match_operand:SI 2 "immediate_operand" "S12S0,i")]
+		     ARC64_UNSPEC_VEC_SHR))]
+  "TARGET_SIMD"
+  "asrl\\t%0,%1,%2"
+  [(set_attr "length" "4,8")
+   (set_attr "type" "asl")])
+
+(define_insn "vec_shl_<mode>"
+  [(set (match_operand:V64I 0 "register_operand" "=r,r")
+	(unspec:V64I [(match_operand:V64I 1 "register_operand"  "0,r")
+		      (match_operand:SI 2 "immediate_operand" "S12S0,i")]
+		     ARC64_UNSPEC_VEC_SHL))]
+  "TARGET_SIMD"
+  "asll\\t%0,%1,%2"
+  [(set_attr "length" "4,8")
+   (set_attr "type" "asl")])
+
+;; Patterns used by vect_perm
+(define_insn "arc64_dup_lane0v2si"
+  [(set (match_operand:V2SI 0 "register_operand" "=r")
+	(vec_duplicate:V2SI
+	 (vec_select:SI
+	  (match_operand:V2SI 1 "register_operand" "r")
+	  (parallel [(const_int 0)])
+	  )))]
+  "TARGET_SIMD"
+  "vpack2wl\\t%0,%1,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "vpack")])
+
+(define_insn "arc64_dup_lane1v2si"
+  [(set (match_operand:V2SI 0 "register_operand" "=r")
+	(vec_duplicate:V2SI
+	 (vec_select:SI
+	  (match_operand:V2SI 1 "register_operand" "r")
+	  (parallel [(const_int 1)])
+	  )))]
+  "TARGET_SIMD"
+  "vpack2wm\\t%0,%1,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "vpack")])
+
+(define_insn "arc64_sel_lane0_v2si"
+  [(set (match_operand:V2SI 0 "register_operand" "=r")
+	(vec_concat:V2SI
+	 (vec_select:SI
+	  (match_operand:V2SI 1 "register_operand" "r")
+	  (parallel [(const_int 0)]))
+	 (vec_select:SI
+	  (match_operand:V2SI 2 "register_operand" "r")
+	  (parallel [(const_int 0)]))
+	 ))]
+  "TARGET_SIMD"
+  "vpack2wl\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "vpack")])
+
+(define_insn "arc64_sel_lane1_v2si"
+  [(set (match_operand:V2SI 0 "register_operand" "=r")
+	(vec_concat:V2SI
+	 (vec_select:SI
+	  (match_operand:V2SI 1 "register_operand" "r")
+	  (parallel [(const_int 1)]))
+	 (vec_select:SI
+	  (match_operand:V2SI 2 "register_operand" "r")
+	  (parallel [(const_int 1)]))
+	 ))]
+  "TARGET_SIMD"
+  "vpack2wm\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "vpack")])
+
+(define_insn "arc64_sel_lane2_0v4hi"
+  [(set (match_operand:V4HI 0 "register_operand" "=r")
+	(vec_concat:V4HI
+	  (vec_select:V2HI
+	   (match_operand:V4HI 1 "register_operand" "r")
+	   (parallel [(const_int 0) (const_int 2)]))
+	  (vec_select:V2HI
+	   (match_operand:V4HI 2 "register_operand" "r")
+	   (parallel [(const_int 0) (const_int 2)]))))]
+  "TARGET_SIMD"
+  "vpack4hl\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "vpack")])
+
+(define_insn "arc64_sel_lane3_1v4hi"
+  [(set (match_operand:V4HI 0 "register_operand" "=r")
+	(vec_concat:V4HI
+	  (vec_select:V2HI
+	   (match_operand:V4HI 1 "register_operand" "r")
+	   (parallel [(const_int 1) (const_int 3)]))
+	  (vec_select:V2HI
+	   (match_operand:V4HI 2 "register_operand" "r")
+	   (parallel [(const_int 1) (const_int 3)]))))]
+  "TARGET_SIMD"
+  "vpack4hm\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "vpack")])
+
+(define_insn "arc64_swaplv2si"
+  [(set (match_operand:V2SI 0 "register_operand" "=r")
+        (unspec:V2SI
+          [(match_operand:V2SI 1 "register_operand" "r")]
+          ARC64_UNSPEC_SWAPL))]
+  ""
+  "swapl\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "swapl")])
+
+(define_insn "arc64_swapv4hi"
+  [(set (match_operand:V4HI 0 "register_operand" "=r")
+        (unspec:V4HI
+         [(match_operand:V4HI 1 "register_operand" "r")]
+          ARC64_UNSPEC_SWAP))]
+  ""
+  "swap\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "swap")])
+
+(define_insn "arc64_swp_lane0_v4hi"
+  [(set (match_operand:V4HI 0 "register_operand" "=r")
+	(vec_concat:V4HI
+	 (vec_select:V2HI
+	  (match_operand:V4HI 1 "register_operand" "r")
+	  (parallel [(const_int 0) (const_int 1)]))
+	 (vec_select:V2HI
+	  (match_operand:V4HI 2 "register_operand" "r")
+	  (parallel [(const_int 0) (const_int 1)]))
+	 ))]
+  "TARGET_SIMD"
+  "vpack2wl\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "vpack")])
+
+(define_insn "arc64_swp_lane1_v4hi"
+  [(set (match_operand:V4HI 0 "register_operand" "=r")
+	(vec_concat:V4HI
+	 (vec_select:V2HI
+	  (match_operand:V4HI 1 "register_operand" "r")
+	  (parallel [(const_int 2) (const_int 3)]))
+	 (vec_select:V2HI
+	  (match_operand:V4HI 2 "register_operand" "r")
+	  (parallel [(const_int 2) (const_int 3)]))
+	 ))]
+  "TARGET_SIMD"
+  "vpack2wm\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "vpack")])
+
+
+;; -------------------------------------------------------------------
+;; FP SIMD instructions
+;; -------------------------------------------------------------------
+
+(define_expand "mov<mode>"
+  [(set (match_operand:VALLF 0 "nonimmediate_operand")
+	(match_operand:VALLF 1 "general_operand"))]
+  "ARC64_HAS_FP_BASE"
+  "
+   if (arc64_prepare_move_operands (operands[0], operands[1], <MODE>mode))
+    DONE;
+  ")
+
+(define_expand "movmisalign<mode>"
+  [(set (match_operand:VALLF 0 "nonimmediate_operand")
+	(match_operand:VALLF 1 "general_operand"))]
+  "ARC64_HAS_FP_BASE && !STRICT_ALIGNMENT"
+  {
+   if (!register_operand (operands[0], <MODE>mode)
+       && !register_operand (operands[1], <MODE>mode))
+    operands[1] = force_reg (<MODE>mode, operands[1]);
+  })
+
+(define_insn "*mov<mode>"
+  [(set (match_operand:VALLF_64 0 "arc64_dest_operand"  "=w,    w,Ufpms,*r,*w,*r,*r,*m")
+	(match_operand:VALLF_64 1 "nonimmediate_operand" "w,Ufpms,    w,*w,*r,*r,*m,*r"))]
+  "ARC64_HAS_FP_BASE
+   && (register_operand (operands[0], <MODE>mode)
+       || register_operand (operands[1], <MODE>mode))"
+  "@
+   vf<sfxtab>mov\\t%0,%1
+   fld<sizef>%U1\\t%0,%1
+   fst<sizef>%U0\\t%1,%0
+   fmv<fmvftab>2<fmvitab>\\t%0,%1
+   fmv<fmvitab>2<fmvftab>\\t%0,%1
+   mov<mcctab>\\t%0,%1
+   ld<slfp>%U1\\t%0,%1
+   st<slfp>%U0\\t%1,%0"
+  [(set_attr "type" "fmov,ld,st,move,move,move,ld,st")
+   (set_attr "length" "4,*,*,4,4,4,*,*")])
+
+;; The 128 bit moves need special care.
+(define_insn_and_split "*mov<mode>"
+  [(set (match_operand:VALLF_128 0 "arc64_fsimd_moperand" "=w,    w,Ufpms,*r,*w")
+	(match_operand:VALLF_128 1 "arc64_fsimd_moperand"  "w,Ufpms,    w,*w,*r"))]
+  "ARC64_HAS_FP_BASE
+   && (register_operand (operands[0], <MODE>mode)
+       || register_operand (operands[1], <MODE>mode))"
+  "@
+   vf<sfxtab>mov\\t%0,%1
+   fld<sizef>%U1\\t%0,%1
+   fst<sizef>%U0\\t%1,%0
+   #
+   #"
+  "&& reload_completed
+   && arc64_simd64x_split_move_p (operands, <MODE>mode)"
+  [(const_int 0)]
+  {
+   arc64_simd128_split_move (operands, <MODE>mode);
+   DONE;
+  }
+  [(set_attr "type" "fmov,ld,st,move,move")
+   (set_attr "length" "4,*,*,8,8")])
+
+(define_insn "<optab><mode>3"
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register"            "=w")
+	(VOPS:VALLF (match_operand:VALLF 1 "arc64_fsimd_register" "w")
+		    (match_operand:VALLF 2 "arc64_fsimd_register" "w")))]
+  "ARC64_HAS_FP_BASE"
+  "vf<sfxtab><mntab>\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "vf<mntab>")])
+
+(define_insn "vec_duplicate<mode>"
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register" "=w")
+	(vec_duplicate:VALLF (match_operand:<VEL> 1 "register_operand" "w")))]
+  "ARC64_HAS_FP_BASE"
+  "vf<sfxtab>rep\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "vfrep")])
+
+(define_insn "<optab><mode>3_rep"
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register" "=w")
+	(VOPS:VALLF
+	 (match_operand:VALLF 1 "arc64_fsimd_register" "w")
+	 (vec_duplicate:VALLF
+	  (match_operand:<VEL> 2 "register_operand" "w"))))]
+  "ARC64_HAS_FP_BASE"
+  "vf<sfxtab><mntab>s\\t%0,%1,%2"
+  [(set_attr "length" "4")
+   (set_attr "type" "vf<mntab>")])
+
+;; Canonical of the above (selected) patterns.
+(define_insn "<optab><mode>3_rep2"
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register" "=w")
+	(VCOP:VALLF
+	 (vec_duplicate:VALLF
+	  (match_operand:<VEL> 1 "register_operand" "w"))
+	 (match_operand:VALLF 2 "arc64_fsimd_register" "w")))]
+  "ARC64_HAS_FP_BASE"
+  "vf<sfxtab><mntab>s\\t%0,%2,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "vf<mntab>")])
+
+(define_expand "vec_set<mode>"
+  [(set (match_operand:VALLF 0 "register_operand")
+	(vec_merge:VALLF
+	 (vec_duplicate:VALLF
+	  (match_operand:<VEL> 1 "register_operand"))
+	 (match_dup 0)
+	 (match_operand:SI 2 "immediate_operand")))]
+  "ARC64_HAS_FP_BASE"
+  {
+   HOST_WIDE_INT elem = (HOST_WIDE_INT) 1 << INTVAL (operands[2]);
+   operands[2] = GEN_INT (elem);
+  })
+
+(define_insn "*vec_set<mode>"
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register" "=w")
+	(vec_merge:VALLF
+	 (vec_duplicate:VALLF
+	  (match_operand:<VEL> 1 "register_operand" "w"))
+	 (match_operand:VALLF 3 "arc64_fsimd_register" "0")
+	 (match_operand:SI 2 "immediate_operand" "i")))]
+  "ARC64_HAS_FP_BASE"
+ {
+   int elt = exact_log2 (INTVAL (operands[2]));
+   gcc_assert (UNSIGNED_INT5 (elt));
+   operands[2] = GEN_INT (elt);
+   return  "vf<sfxtab>ins\\t%0[%2],%1";
+ }
+  [(set_attr "length" "4")
+   (set_attr "type" "vfins")])
+
+(define_insn "vec_extract<mode><vel>"
+  [(set (match_operand:<VEL> 0 "register_operand" "=w")
+	(vec_select:<VEL> (match_operand:VALLF 1 "arc64_fsimd_register" "w")
+			  (parallel [(match_operand:SI 2 "const_int_operand" "U05S0")])))]
+  "ARC64_HAS_FP_BASE"
+  "vf<sfxtab>ext\\t%0,%1[%2]"
+  [(set_attr "length" "4")
+   (set_attr "type" "vfext")])
+
+;; FV<P>MADD
+(define_insn "fma<mode>4"
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register" "=w")
+	(fma:VALLF (match_operand:VALLF 1 "arc64_fsimd_register"  "w")
+		   (match_operand:VALLF 2 "arc64_fsimd_register"  "w")
+		   (match_operand:VALLF 3 "arc64_fsimd_register"  "w")))]
+  "ARC64_HAS_FP_BASE"
+  "vf<sfxtab>madd\\t%0,%1,%2,%3"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmadd")])
+
+;; FV<P>MSUB
+(define_insn "fnma<mode>4"
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register" "=w")
+	(fma:VALLF (neg:VALLF (match_operand:VALLF 1 "arc64_fsimd_register"  "w"))
+		   (match_operand:VALLF 2 "arc64_fsimd_register"  "w")
+		   (match_operand:VALLF 3 "arc64_fsimd_register"  "w")))]
+  "ARC64_HAS_FP_BASE"
+  "vf<sfxtab>msub\\t%0,%1,%2,%3"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmsub")])
+
+(define_insn "fms<mode>4"
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register" "=w")
+	(fma:VALLF (match_operand:VALLF 1 "arc64_fsimd_register"  "w")
+		   (match_operand:VALLF 2 "arc64_fsimd_register"  "w")
+		   (neg:VALLF (match_operand:VALLF 3 "arc64_fsimd_register"  "w"))))]
+  "!HONOR_SIGNED_ZEROS (<MODE>mode) && ARC64_HAS_FP_BASE"
+  "vf<sfxtab>nmsub\\t%0,%1,%2,%3"
+  [(set_attr "length" "4")
+   (set_attr "type" "fnmsub")])
+
+;; -(op3 - (op1 * op2))
+(define_insn "*nfnms<mode>4"
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register" "=w")
+	(neg:VALLF (fma:VALLF (neg:VALLF (match_operand:VALLF 1 "arc64_fsimd_register"  "w"))
+			      (match_operand:VALLF 2 "arc64_fsimd_register"  "w")
+			      (match_operand:VALLF 3 "arc64_fsimd_register"  "w"))))]
+  "ARC64_HAS_FP_BASE"
+  "vf<sfxtab>nmsub\\t%0,%1,%2,%3"
+  [(set_attr "length" "4")
+   (set_attr "type" "fnmsub")])
+
+;; FV<P>NMADD
+(define_insn "fnms<mode>4"
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register" "=w")
+	(fma:VALLF (neg:VALLF (match_operand:VALLF 1 "arc64_fsimd_register"  "w"))
+		   (match_operand:VALLF 2 "arc64_fsimd_register"  "w")
+		   (neg:VALLF (match_operand:VALLF 3 "arc64_fsimd_register"  "w"))))]
+  "!HONOR_SIGNED_ZEROS (<MODE>mode) && ARC64_HAS_FP_BASE"
+  "vf<sfxtab>nmadd\\t%0,%1,%2,%3"
+  [(set_attr "length" "4")
+   (set_attr "type" "fnmadd")])
+
+;; -(op3 + (op1 * op2))
+(define_insn "*nfms<mode>4"
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register" "=w")
+	(neg:VALLF (fma:VALLF (match_operand:VALLF 1 "arc64_fsimd_register"  "w")
+			      (match_operand:VALLF 2 "arc64_fsimd_register"  "w")
+			      (match_operand:VALLF 3 "arc64_fsimd_register"  "w"))))]
+  "ARC64_HAS_FP_BASE"
+  "vf<sfxtab>nmadd\\t%0,%1,%2,%3"
+  [(set_attr "length" "4")
+   (set_attr "type" "fnmadd")])
+
+;; FV<P>SQRT
+(define_insn "sqrt<mode>2"
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register" "=w")
+	(sqrt:VALLF (match_operand:VALLF 1 "arc64_fsimd_register" "w")))]
+  "ARC64_HAS_FP_BASE"
+  "vf<sfxtab>sqrt\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "fsqrt")])
+
+;; FV<P>MADDS
+(define_insn "fma<mode>4_rep"
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register" "=w")
+	(fma:VALLF (match_operand:VALLF 1 "arc64_fsimd_register"  "w")
+		   (match_operand:VALLF 2 "arc64_fsimd_register"  "w")
+		   (vec_duplicate:VALLF
+		    (match_operand:<VEL> 3 "register_operand"  "w"))))]
+  "ARC64_HAS_FP_BASE"
+  "vf<sfxtab>madds\\t%0,%1,%2,%3"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmadd")])
+
+(define_peephole2
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register" "")
+	(vec_duplicate:VALLF (match_operand:<VEL> 1 "register_operand"  "")))
+   (set (match_operand:VALLF 2 "arc64_fsimd_register" "")
+	(fma:VALLF (match_operand:VALLF 3 "arc64_fsimd_register" "")
+		   (match_dup 0)
+		   (match_operand:VALLF 4 "arc64_fsimd_register" "")))]
+  "ARC64_HAS_FP_BASE
+   && peep2_reg_dead_p (2, operands[0])"
+  [(set (match_dup 2)
+	(fma:VALLF (match_dup 3) (match_dup 4)
+		   (vec_duplicate:VALLF (match_dup 1))))]
+  "")
+
+;; FV<P>MSUBS
+(define_insn "fnma<mode>4_rep"
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register" "=w")
+	(fma:VALLF (neg:VALLF (match_operand:VALLF 1 "arc64_fsimd_register"  "w"))
+		   (match_operand:VALLF 2 "arc64_fsimd_register"  "w")
+		   (vec_duplicate:VALLF
+		    (match_operand:<VEL> 3 "register_operand"  "w"))))]
+  "ARC64_HAS_FP_BASE"
+  "vf<sfxtab>msubs\\t%0,%1,%2,%3"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmsub")])
+
+(define_peephole2
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register" "")
+	(vec_duplicate:VALLF (match_operand:<VEL> 1 "register_operand"  "")))
+   (set (match_operand:VALLF 2 "arc64_fsimd_register" "")
+	(fma:VALLF (neg:VALLF (match_operand:VALLF 3 "arc64_fsimd_register" ""))
+		   (match_dup 0)
+		   (match_operand:VALLF 4 "arc64_fsimd_register" "")))]
+  "ARC64_HAS_FP_BASE
+   && peep2_reg_dead_p (2, operands[0])"
+  [(set (match_dup 2)
+	(fma:VALLF (neg:VALLF (match_dup 3)) (match_dup 4)
+		   (vec_duplicate:VALLF (match_dup 1))))]
+  "")
+
+;; Vector reduction instructions (emulated)
+(define_expand "reduc_plus_scal_<mode>"
+  [(match_operand:<VEL> 0 "register_operand")
+   (match_operand:V2xF 1 "register_operand")]
+  ""
+  {
+    rtx low = gen_lowpart (<VEL>mode, operands[1]);
+    rtx high = gen_reg_rtx (<VEL>mode);
+
+    emit_insn (gen_vec_extract<mode><vel> (high, operands[1], GEN_INT (1)));
+    emit_insn (gen_add<vel>3 (operands[0], high, low));
+    DONE;
+  })
+
+(define_expand "reduc_plus_scal_<mode>"
+  [(match_operand:<VEL> 0 "register_operand")
+   (match_operand:V4xF 1 "register_operand")]
+  ""
+  {
+    rtx op0 = gen_lowpart (<VEL>mode, operands[1]);
+    rtx op1 = gen_reg_rtx (<VEL>mode);
+    rtx op2 = gen_reg_rtx (<VEL>mode);
+    rtx op3 = gen_reg_rtx (<VEL>mode);
+    rtx tmp1 = gen_reg_rtx (<VEL>mode);
+    rtx tmp2 = gen_reg_rtx (<VEL>mode);
+
+    emit_insn (gen_vec_extract<mode><vel> (op1, operands[1], GEN_INT (1)));
+    emit_insn (gen_add<vel>3 (tmp1, op1, op0));
+
+    if (<MODE>mode == V4SFmode)
+      op2 = gen_lowpart (SFmode, gen_highpart (DFmode, operands[1]));
+    else
+      emit_insn (gen_vec_extract<mode><vel> (op2, operands[1], GEN_INT (2)));
+
+    emit_insn (gen_vec_extract<mode><vel> (op3, operands[1], GEN_INT (3)));
+    emit_insn (gen_add<vel>3 (tmp2, op2, op3));
+
+    emit_insn (gen_add<vel>3 (operands[0], tmp1, tmp2));
+    DONE;
+  })
+
+;; Emulated vector ops using scalar function, only for double width vectors.
+;; MAX/MIN
+(define_insn_and_split "<optab><mode>3"
+  [(set (match_operand:W2xF 0 "arc64_fsimd_register" "=w")
+	(EV2OP:W2xF (match_operand:W2xF 1 "arc64_fsimd_register" "w")
+		    (match_operand:W2xF 2 "arc64_fsimd_register" "w")))]
+  "ARC64_VFP_128"
+  "#"
+  "&& reload_completed"
+  [(const_int 0)]
+  {
+   rtx high_dest = gen_highpart (<VEL>mode, operands[0]);
+   rtx low_dest = gen_lowpart (<VEL>mode, operands[0]);
+   rtx high_op1 = gen_highpart (<VEL>mode, operands[1]);
+   rtx low_op1 = gen_lowpart (<VEL>mode, operands[1]);
+   rtx high_op2 = gen_highpart (<VEL>mode, operands[2]);
+   rtx low_op2 = gen_lowpart (<VEL>mode, operands[2]);
+   emit_insn (gen_<optab><vel>3 (low_dest, low_op1,  low_op2));
+   emit_insn (gen_<optab><vel>3 (high_dest, high_op1,  high_op2));
+   DONE;
+  }
+  [(set_attr "length" "8")
+   (set_attr "type" "f<mntab>")])
+
+;; NEG/ABS
+(define_insn_and_split "<optab><mode>2"
+  [(set (match_operand:W2xF 0 "arc64_fsimd_register" "=w")
+	(EV1OP:W2xF (match_operand:W2xF 1 "arc64_fsimd_register" "w")))]
+  "ARC64_VFP_128"
+  "#"
+  "&& reload_completed"
+  [(const_int 0)]
+  {
+   rtx high_dest = gen_highpart (<VEL>mode, operands[0]);
+   rtx low_dest = gen_lowpart (<VEL>mode, operands[0]);
+   rtx high_op1 = gen_highpart (<VEL>mode, operands[1]);
+   rtx low_op1 = gen_lowpart (<VEL>mode, operands[1]);
+   emit_insn (gen_<optab><vel>2 (low_dest, low_op1));
+   emit_insn (gen_<optab><vel>2 (high_dest, high_op1));
+   DONE;
+  }
+  [(set_attr "length" "8")
+   (set_attr "type" "fsgnjn")])
+
+;; Conversions.
+(define_expand "vec_pack_trunc_v2df"
+  [(set (match_operand:V4SF 0 "register_operand")
+      (vec_concat:V4SF
+	(float_truncate:V2SF
+	    (match_operand:V2DF 1 "register_operand"))
+	(float_truncate:V2SF
+	    (match_operand:V2DF 2 "register_operand"))
+	  ))]
+  "ARC64_VFP_128"
+  {
+    rtx high_dest = gen_lowpart (SFmode,
+				 gen_highpart (DFmode,
+					      operands[0]));
+    rtx low_dest = gen_lowpart (SFmode, operands[0]);
+
+    rtx high_op1 = gen_highpart (DFmode, operands[1]);
+    rtx low_op1 = gen_lowpart (DFmode, operands[1]);
+    rtx high_op2 = gen_highpart (DFmode, operands[2]);
+    rtx low_op2 = gen_lowpart (DFmode, operands[2]);
+    rtx tmp1 = gen_reg_rtx (SFmode);
+    rtx tmp3 = gen_reg_rtx (SFmode);
+
+    emit_insn (gen_truncdfsf2 (tmp3, high_op1));
+    emit_insn (gen_truncdfsf2 (high_dest, low_op1));
+    emit_insn (gen_truncdfsf2 (tmp1, high_op2));
+    emit_insn (gen_truncdfsf2 (low_dest, low_op2));
+
+    emit_insn (gen_vec_setv4sf (operands[0], tmp1, GEN_INT (1)));
+    emit_insn (gen_vec_setv4sf (operands[0], tmp3, GEN_INT (3)));
+    DONE;
+  })
+
+(define_expand "vec_pack_trunc_df"
+  [(set (match_operand:V2SF 0 "register_operand")
+      (vec_concat:V2SF
+	(float_truncate:SF
+	    (match_operand:DF 1 "register_operand"))
+	(float_truncate:SF
+	    (match_operand:DF 2 "register_operand"))
+	  ))]
+ "ARC64_VFP_64"
+ {
+    rtx low_dest = gen_lowpart (SFmode, operands[0]);
+    rtx tmp1 = gen_reg_rtx (SFmode);
+
+    emit_insn (gen_truncdfsf2 (low_dest, operands[2]));
+    emit_insn (gen_truncdfsf2 (tmp1, operands[1]));
+    emit_insn (gen_vec_setv2sf (operands[0], tmp1, GEN_INT (1)));
+    DONE;
+ })
+
+;; vec_load_lanes used when wide_simd is off and wide_ldst is
+;; on. Hence the simd lengthis 64bit
+
+;; Patterns used to vect permutate.
+
+;; This one pattern is only used when we don't want to make
+;; dup_permutations using vec_dup (see arc64_simd_dup).
+(define_insn "arc64_dup_lane0<mode>"
+  [(set (match_operand:VALLF 0 "arc64_fsimd_register" "=w")
+	(vec_duplicate:VALLF
+	 (vec_select:<VEL>
+	  (match_operand:VALLF 1 "arc64_fsimd_register" "w")
+	  (parallel [(const_int 0)])
+	  )))]
+  "ARC64_HAS_FP_BASE"
+  "vf<sfxtab>rep\\t%0,%1"
+  [(set_attr "length" "4")
+   (set_attr "type" "vfrep")])
+
+(define_insn "arc64_dup_lane1<mode>"
+  [(set (match_operand:W2xF 0 "arc64_fsimd_register" "=w")
+	(vec_duplicate:W2xF
+	 (vec_select:<VEL>
+	  (match_operand:W2xF 1 "arc64_fsimd_register" "w")
+	  (parallel [(const_int 1)])
+	  )))]
+  "ARC64_VFP_128"
+  "vf<sfxtab>rep\\t%0,%h1"
+  [(set_attr "length" "4")
+   (set_attr "type" "vfrep")])
+
+;; Required pattern needed for vector reduction operations.
+;;(define_expand "vec_shr_<mode>"
+;;  [(match_operand:VALLF 0 "register_operand")
+;;   (match_operand:VALLF 1 "register_operand")
+;;   (match_operand:SI 2 "immediate_operand")]
+;;  "ARC64_HAS_FP_BASE"
+;;  {
+;;   if (arc64_expand_fvect_shr (operands))
+;;      DONE;
+;;   FAIL;
+;;  })
+
+;;(define_insn "vec_shr_<mode>"
+;;  [(set (match_operand:VALLF 0 "arc64_fsimd_moperand" "=w")
+;;	(unspec:VALLF [(match_operand:VALLF 1 "arc64_fsimd_moperand" "w")
+;;		       (match_operand:SI 2 "immediate_operand")]
+;;		      ARC64_UNSPEC_VEC_SHR))]
+;;  "ARC64_HAS_FP_BASE"
+;;  "vfasrl\\t%0,%1,%2"
+;;  [(set_attr "length" "4")
+;;   (set_attr "type" "asl")])
diff --git a/gcc/config/arc64/atomic.md b/gcc/config/arc64/atomic.md
new file mode 100644
index 00000000000..22076eafd49
--- /dev/null
+++ b/gcc/config/arc64/atomic.md
@@ -0,0 +1,268 @@
+;; GCC machine description for ARC atomic instructions.
+;; Copyright (C) 2015-2020 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; Operations which can be used with atomic loads and stores.
+(define_code_iterator ATOPS [plus minus ior xor and])
+
+;; Operations which are supported by hardware.
+(define_code_iterator ATHWOPS [plus ior xor and])
+
+(define_expand "memory_barrier"
+  [(set (match_dup 0)
+	(unspec:BLK [(match_dup 0)] ARC64_UNSPEC_MEMBAR))]
+  ""
+{
+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[0]) = 1;
+})
+
+(define_insn "*memory_barrier"
+  [(set (match_operand:BLK 0 "" "")
+	(unspec:BLK [(match_dup 0)] ARC64_UNSPEC_MEMBAR))]
+  ""
+  {
+       return "dmb\\t3";
+  }
+  [(set_attr "type" "dmb")
+   (set_attr "length" "4")])
+
+(define_expand "atomic_compare_and_swap<mode>"
+  [(match_operand:SI 0 "register_operand" "")	;; bool out
+   (match_operand:ALLI 1 "register_operand" "")	;; val out
+   (match_operand:ALLI 2 "mem_noofs_operand" "");; memory
+   (match_operand:ALLI 3 "register_operand" "")	;; expected
+   (match_operand:ALLI 4 "register_operand" "")	;; desired
+   (match_operand:SI 5 "const_int_operand")	;; is_weak
+   (match_operand:SI 6 "const_int_operand")    	;; mod_s
+   (match_operand:SI 7 "const_int_operand")]	;; mod_f
+  "ARC64_HAS_ATOMIC_1"
+{
+  arc64_expand_compare_and_swap (operands);
+  DONE;
+})
+
+(define_insn_and_split "atomic_compare_and_swap<mode>_1"
+  [(set (reg:CC_Z CC_REGNUM)					;; bool out
+	(unspec_volatile:CC_Z [(const_int 0)] ARC64_VUNSPEC_CAS))
+   (set (match_operand:GPI 0 "register_operand"      "=&r")		;; val out
+	(match_operand:GPI 1 "mem_noofs_operand"      "+ATOMC"))	;; memory
+   (set (match_dup 1)
+	(unspec_volatile
+	  [(match_operand:GPI 2 "register_operand"     "r") ;; expect
+	   (match_operand:GPI 3 "register_operand"     "r") ;; desired
+	   (match_operand:SI 4 "const_int_operand")	;; is_weak
+	   (match_operand:SI 5 "const_int_operand")	;; mod_s
+	   (match_operand:SI 6 "const_int_operand")]	;; mod_f
+	  ARC64_VUNSPEC_CAS))]
+  "ARC64_HAS_ATOMIC_1"
+  "#"
+  "&& reload_completed"
+  [(const_int 0)]
+  {
+    arc64_split_compare_and_swap (operands);
+    DONE;
+  })
+
+(define_insn "arc_load_exclusive<mode>"
+  [(set (match_operand:GPI 0 "register_operand" "=r")
+	(unspec_volatile:GPI
+	  [(match_operand:GPI 1 "mem_noofs_operand" "ATOMC")]
+	  ARC64_VUNSPEC_LL))]
+  "ARC64_HAS_ATOMIC_1"
+  "llock<mcctab>\\t%0,%1"
+  [(set_attr "type" "llock")
+   (set_attr "iscompact" "no")
+   (set_attr "predicable" "no")
+   (set_attr "length" "*")])
+
+(define_insn "arc_store_exclusive<mode>"
+  [(set (match_operand:GPI 0 "mem_noofs_operand"     "=ATOMC")
+	(unspec_volatile:GPI[(match_operand:GPI 1 "register_operand" "r")]
+			   ARC64_VUNSPEC_SC))
+   (clobber (reg:CC_Z CC_REGNUM))]
+  "ARC64_HAS_ATOMIC_1"
+  "scond<mcctab>\\t%1,%0"
+  [(set_attr "type" "scond")
+   (set_attr "iscompact" "no")
+   (set_attr "predicable" "no")
+   (set_attr "length" "*")])
+
+(define_expand "atomic_exchangesi"
+  [(match_operand:SI 0 "register_operand" "")
+   (match_operand:SI 1 "mem_noofs_operand" "")
+   (match_operand:SI 2 "register_operand" "")
+   (match_operand:SI 3 "const_int_operand" "")]
+  "ARC64_HAS_ATOMIC_1"
+{
+  enum memmodel model = (enum memmodel) INTVAL (operands[3]);
+
+  if (model == MEMMODEL_SEQ_CST)
+    emit_insn (gen_sync ());
+  emit_insn (gen_exchangesi (operands[0], operands[1], operands[2]));
+  DONE;
+})
+
+(define_insn "exchange<mode>"
+  [(set (match_operand:GPI 0 "register_operand" "=r")
+	(unspec_volatile:GPI [(match_operand:GPI 1 "mem_noofs_operand" "+ATOMC")]
+			    ARC64_VUNSPEC_EX))
+   (set (match_dup 1)
+	(match_operand:GPI 2 "register_operand" "0"))]
+  ""
+  "ex<mcctab>\\t%0,%1"
+  [(set_attr "type" "ex")
+   (set_attr "iscompact" "no")
+   (set_attr "predicable" "no")
+   (set_attr "length" "*")])
+
+;; New Atomic options enabled by option 2
+(define_insn_and_split "atld_<optab><mode>"
+  [(set (match_operand:GPI 0 "register_operand" "=&r,r")
+	(match_operand:GPI 1 "mem_noofs_operand" "+ATOMC,ATOMC"))
+   (set (match_dup 1)
+	(unspec_volatile:GPI
+	 [(ATHWOPS:GPI (match_dup 0)
+		       (match_operand:GPI 2 "register_operand" "0,r"))
+	  (match_operand:SI 3 "const_int_operand")]
+	 ARC64_VUNSPEC_ATOOPS))]
+  "ARC64_HAS_ATOMIC_2"
+  "@
+   atld<sfxtab>.<optab>\\t%0,%1
+   #"
+  "&& reload_completed && !operands_match_p (operands[0], operands[2])"
+  [(const_int 0)]
+  {
+   emit_insn (gen_rtx_SET (operands[0], operands[2]));
+   emit_insn (gen_atld_<optab><mode> (operands[0], operands[1], operands[0], operands[3]));
+   DONE;
+  }
+  [(set_attr "type" "atld<sfxtab>op")])
+
+(define_expand "atomic_<optab><mode>"
+  [(match_operand:GPI 0 "mem_noofs_operand" "")  ;; memory
+   (ATOPS:GPI (match_dup 0)
+	      (match_operand:GPI 1 "register_operand" "")) ;; operand
+   (match_operand:SI 2 "const_int_operand" "")] ;; model
+  "ARC64_HAS_ATOMIC_1"
+{
+  arc64_expand_atomic_op (<CODE>, operands[0], operands[1],
+				NULL_RTX, NULL_RTX, operands[2]);
+  DONE;
+})
+
+(define_expand "atomic_nandsi"
+  [(match_operand:SI 0 "mem_noofs_operand" "")	;; memory
+   (match_operand:SI 1 "register_operand" "")	;; operand
+   (match_operand:SI 2 "const_int_operand" "")]	;; model
+  "ARC64_HAS_ATOMIC_1"
+{
+ arc64_expand_atomic_op (NOT, operands[0], operands[1],
+			    NULL_RTX, NULL_RTX, operands[2]);
+ DONE;
+})
+
+(define_expand "atomic_fetch_<optab><mode>"
+  [(set (match_operand:GPI 0 "register_operand")	;; output
+	(match_operand:GPI 1 "mem_noofs_operand"))	;; memory
+   (set (match_dup 1)
+	(unspec_volatile:GPI
+	 [(ATHWOPS:GPI (match_dup 1)
+		     (match_operand:GPI 2 "register_operand")) ;; operand
+	  (match_operand:SI 3 "const_int_operand")]	;; model
+	 ARC64_VUNSPEC_ATOOPS))]
+  "ARC64_HAS_ATOMIC_1"
+  {
+   if (!ARC64_HAS_ATOMIC_2)
+     {
+       arc64_expand_atomic_op (<CODE>, operands[1], operands[2],
+			       operands[0], NULL_RTX, operands[3]);
+       DONE;
+     }
+    if (!ARC64_HAS_ATOMIC_3)
+      arc64_pre_atomic_barrier ((enum memmodel) INTVAL (operands[3]));
+    emit_insn (gen_atld_<optab><mode> (operands[0], operands[1], operands[2], operands[3]));
+    if (!ARC64_HAS_ATOMIC_3)
+      arc64_post_atomic_barrier ((enum memmodel) INTVAL (operands[3]));
+    DONE;
+   })
+
+;; ARCv3 doesn't have a MINUS atomic memory operation.
+(define_expand "atomic_fetch_sub<mode>"
+  [(set (match_operand:GPI 0 "register_operand")	;; output
+	(match_operand:GPI 1 "mem_noofs_operand"))	;; memory
+   (set (match_dup 1)
+	(unspec_volatile:GPI
+	 [(minus:GPI (match_dup 1)
+		     (match_operand:GPI 2 "register_operand")) ;; operand
+	  (match_operand:SI 3 "const_int_operand")]	;; model
+	 ARC64_VUNSPEC_ATOOPS))]
+  "ARC64_HAS_ATOMIC_1"
+  {
+    arc64_expand_atomic_op (MINUS, operands[1], operands[2],
+			    operands[0], NULL_RTX, operands[3]);
+    DONE;
+  })
+
+(define_expand "atomic_fetch_nand<mode>"
+  [(match_operand:GPI 0 "register_operand" "")	;; output
+   (match_operand:GPI 1 "mem_noofs_operand" "")	;; memory
+   (match_operand:GPI 2 "register_operand" "")	;; operand
+   (match_operand:SI  3 "const_int_operand" "")]	;; model
+  "ARC64_HAS_ATOMIC_1"
+{
+  arc64_expand_atomic_op (NOT, operands[1], operands[2],
+			     operands[0], NULL_RTX, operands[3]);
+  DONE;
+})
+
+(define_expand "atomic_<optab>_fetch<mode>"
+  [(match_operand:GPI 0 "register_operand" "")	;; output
+   (match_operand:GPI 1 "mem_noofs_operand" "")	;; memory
+   (ATOPS:GPI (match_dup 1)
+	      (match_operand:GPI 2 "register_operand" "")) ;; operand
+   (match_operand:SI 3 "const_int_operand" "")]	;; model
+  "ARC64_HAS_ATOMIC_1"
+{
+  arc64_expand_atomic_op (<CODE>, operands[1], operands[2],
+				NULL_RTX, operands[0], operands[3]);
+  DONE;
+})
+
+(define_expand "atomic_nand_fetch<mode>"
+  [(match_operand:GPI 0 "register_operand" "")		;; output
+   (match_operand:GPI 1 "mem_noofs_operand" "")		;; memory
+   (match_operand:GPI 2 "register_operand" "")		;; operand
+   (match_operand:SI 3 "const_int_operand" "")]	;; model
+  "ARC64_HAS_ATOMIC_1"
+{
+  arc64_expand_atomic_op (NOT, operands[1], operands[2],
+			     NULL_RTX, operands[0], operands[3]);
+  DONE;
+})
+
+
+;; mode:emacs-lisp
+;; comment-start: ";; "
+;; eval: (set-syntax-table (caopy-sequence (syntax-table)))
+;; eval: (modify-syntax-entry ?[ "(]")
+;; eval: (modify-syntax-entry ?] ")[")
+;; eval: (modify-syntax-entry ?{ "(}")
+;; eval: (modify-syntax-entry ?} "){")
+;; eval: (setq indent-tabs-mode t)
+;; End:
diff --git a/gcc/config/arc64/builtins.def b/gcc/config/arc64/builtins.def
new file mode 100644
index 00000000000..7bd063a20c6
--- /dev/null
+++ b/gcc/config/arc64/builtins.def
@@ -0,0 +1,42 @@
+/* Copyright (C) 2020 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3, or (at your option) any later
+   version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This file contains the definitions and documentation for the
+   builtins defined in the ARC part of the GNU compiler.  Before
+   including this file, define a macro
+
+   DEF_BUILTIN(NAME, N_ARGS, TYPE, ICODE, MASK)
+
+   NAME:    `__builtin_arc_name' will be the user-level name of the builtin.
+            `ARC64_BUILTIN_NAME' will be the internal builtin's id.
+   N_ARGS:  Number of input arguments.  If special treatment is needed,
+            set to -1 and handle it by hand, see arc.c:arc_expand_builtin().
+   TYPE:    A tree node describing the prototype of the built-in.
+   ICODE:   Name of attached insn or expander.  If special treatment in arc.c
+            is needed to expand the built-in, use `nothing'.
+   MASK:    CPU selector mask.  */
+
+DEF_BUILTIN (NOP,        0, void_ftype_void,        nothing,    1)
+DEF_BUILTIN (SR,         2, void_ftype_usint_usint, sr,         1)
+DEF_BUILTIN (LR,         1, usint_ftype_usint,      lr,         1)
+DEF_BUILTIN (BRK,        0, void_ftype_void,        brk,        1)
+DEF_BUILTIN (FLAG,       1, void_ftype_usint,       flag,       1)
+DEF_BUILTIN (SRL,        2, void_ftype_long_long,   srl,        1)
+DEF_BUILTIN (LRL,        1, long_ftype_long,        lrl,        1)
+
+DEF_BUILTIN (TRAP_S,     1, void_ftype_usint,       trap_s,      1)
diff --git a/gcc/config/arc64/constraints.md b/gcc/config/arc64/constraints.md
new file mode 100644
index 00000000000..249d0a4d8b4
--- /dev/null
+++ b/gcc/config/arc64/constraints.md
@@ -0,0 +1,375 @@
+;; Constraint definitions for Synopsys DesignWare ARC.
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; Register constraints
+
+;; Register suited for short instructions.
+(define_register_constraint "q" "AC16_REGS"
+  "Registers usable in short 16-bit like instructions: @code{r0}-@code{r3},
+@code{r12}-@code{r15}")
+
+;; Register suited for sibling calls.
+(define_register_constraint "Sbreg" "SIBCALL_REGS"
+  "@internal
+   Sibling call register")
+
+(define_register_constraint "w" "ARC64_HAS_FP_BASE ? FP_REGS : NO_REGS"
+  "Floating point and SIMD vector registers.")
+
+;; Register suited for mov_s g,h instructions like.
+;; FIXME! check if we get better code when it is register_constraint.
+(define_constraint "h"
+  "@internal
+   Register usable in short move instructions: @code{r0}-@code{r31}"
+  (and (match_code "reg")
+       (match_test "REGNO (op) < ILINK_REGNUM")))
+
+; Usc constant is only used for storing long constants, hence we can
+; have only [b,s9], and [b] types of addresses.
+(define_memory_constraint "Ucnst" "@internal
+   A valid memory operand for storing constants"
+  (and (match_code "mem")
+       (match_test "!CONSTANT_P (XEXP (op, 0))")))
+
+(define_memory_constraint "Uldms" "@internal
+  A valid memory operand for loading using short instructions"
+  (and (match_code "mem")
+       (match_test "arc64_short_access_p (op, mode, true)")))
+
+(define_memory_constraint "Ustms" "@internal
+  A valid memory operand for loading using short instructions"
+  (and (match_code "mem")
+       (match_test "arc64_short_access_p (op, mode, false)")))
+
+(define_memory_constraint "Ufpms" "@internal
+   A valid memory operand for floating point operations"
+  (and (match_code "mem")
+       (match_test "arc64_fp_access_p (op, mode)")))
+
+;(define_constraint "Us<"
+;  "@internal
+;   Stack pre-decrement"
+;  (and (match_code "mem")
+;       (match_test "GET_CODE (XEXP (op, 0)) == PRE_DEC")
+;       (match_test "REG_P (XEXP (XEXP (op, 0), 0))")
+;       (match_test "REGNO (XEXP (XEXP (op, 0), 0)) == SP_REG")))
+;
+;(define_constraint "Us>"
+;  "@internal
+;   Stack post-increment"
+;  (and (match_code "mem")
+;       (match_test "GET_CODE (XEXP (op, 0)) == POST_INC")
+;       (match_test "REG_P (XEXP (XEXP (op, 0), 0))")
+;       (match_test "REGNO (XEXP (XEXP (op, 0), 0)) == SP_REG")))
+;
+;;; Internal immediate constraint used to split move instructions.
+;(define_constraint "Cax"
+;  "@internal
+;  special const_int pattern used to split move insns"
+;  (and (match_code "const_int")
+;       (match_test "optimize_size")
+;       (match_test "arc_check_mov_const (ival)")))
+
+(define_constraint "BLsym"
+  "@internal
+  is a symbol reference allowed by the BL instruction"
+  (match_code "symbol_ref"))
+
+(define_constraint "U06M1"
+  "@internal
+   An unsigned 6-bit integer constant, up to 62."
+  (and (match_code "const_int")
+       (match_test "UNSIGNED_INT6 (ival - 1)")))
+
+(define_constraint "SymMV"
+  "@internal
+   Special constant/symbol which fits in limm field."
+  (and (match_code "label_ref, symbol_ref")
+       (match_test "arc64_allow_direct_access_p (op)")))
+
+(define_constraint "SymIm"
+  "@internal
+   Special constant/symbol which fits in limm field."
+  (ior (match_code "label_ref, symbol_ref")
+       (and (match_code "const_int")
+	    (match_test "SIGNED_INT32 (ival)"))))
+
+(define_constraint "S32S0"
+  "@internal
+   Special constant/symbol which fits in limm field."
+  (and (match_code "const_int")
+       (ior (match_test "UNSIGNED_INT32 (ival)")
+	    (match_test "SIGNED_INT32 (ival)"))))
+
+(define_constraint "U32S0"
+  "@internal
+   Special constant/symbol which fits in limm field."
+  (and (match_code "const_int")
+       (match_test "UNSIGNED_INT32 (ival)")))
+
+(define_constraint "S06S0" "@internal
+  A 6-bit signed integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "SIGNED_INT6 (ival)")))
+
+(define_constraint "SyPic"
+  "@internal
+   Special symbol used for PIC addressing."
+  (match_code "unspec"))
+
+(define_constraint "U06Sx" "@internal
+  A 6-bit unsigned integer constant shifted by x-bit(s)"
+  (and (match_code "const_int")
+       (ior (match_test "UNSIGNED_INT9_SHIFTED (ival,3)")
+	    (match_test "UNSIGNED_INT8_SHIFTED (ival,2)")
+	    (match_test "UNSIGNED_INT7_SHIFTED (ival,1)")
+	    (match_test "UNSIGNED_INT6 (ival)"))))
+
+(define_constraint "N06Sx" "@internal
+  A negate 6-bit unsigned integer constant shifted by x-bit(s) used by add."
+  (and (match_code "const_int")
+       (match_test "ival < 0")
+       (match_test "SIGNED_INT10(ival)")
+       (ior (match_test "UNSIGNED_INT9_SHIFTED (-ival,3)")
+	    (match_test "UNSIGNED_INT8_SHIFTED (-ival,2)")
+	    (match_test "UNSIGNED_INT7_SHIFTED (-ival,1)")
+	    (match_test "UNSIGNED_INT6 (-ival)"))))
+
+(define_constraint "S12Sx" "@internal
+  A 12-bit signed integer constant shifted by x-bit(s)"
+  (and (match_code "const_int")
+       (ior (match_test "SIGNED_INT15_SHIFTED (ival,3)")
+	    (match_test "SIGNED_INT14_SHIFTED (ival,2)")
+	    (match_test "SIGNED_INT13_SHIFTED (ival,1)")
+	    (match_test "SIGNED_INT12 (ival)"))))
+
+(define_constraint "S03MV" "@internal
+  A 3-bit Integer signed constant in the interval [-1,6]"
+  (and (match_code "const_int")
+       (match_test "(ival >= -1) && (ival <= 6)")))
+
+(define_constraint "Z"
+  "Match single precision and a floating-point zero"
+  (and (match_code "const_double")
+       (ior (match_test "op == CONST0_RTX (DFmode)
+                         || op == CONST0_RTX (SFmode)"))))
+
+(define_constraint "G" "@internal
+  Match single precision and a floating-point zero"
+  (and (match_code "const_double")
+       (ior (match_test "op == CONST0_RTX (DFmode)")
+	    (match_test "GET_MODE_SIZE (GET_MODE (op)) <= 4"))))
+;---------------------------------------------------------
+
+(define_constraint "U06S0" "@internal
+  A 6-bit unsigned integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "UNSIGNED_INT6 (ival)")))
+
+(define_constraint "U06S1" "@internal
+  A 6-bit unsigned integer constant shifted by 1-bit(s)"
+  (and
+    (match_code "const_int")
+    (match_test "UNSIGNED_INT7_SHIFTED (ival,1)")))
+
+(define_constraint "U06S2" "@internal
+  A 6-bit unsigned integer constant shifted by 2-bit(s)"
+  (and
+    (match_code "const_int")
+    (match_test "UNSIGNED_INT8_SHIFTED (ival,2)")))
+
+(define_constraint "U06S3" "@internal
+  A 6-bit unsigned integer constant shifted by 3-bit(s)"
+  (and
+    (match_code "const_int")
+    (match_test "UNSIGNED_INT9_SHIFTED (ival,3)")))
+
+(define_constraint "S12S0" "@internal
+  A 12-bit signed integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "SIGNED_INT12 (ival)")))
+
+(define_constraint "S12S1" "@internal
+  A 12-bit signed integer constant shifted by 1-bit(s)"
+  (and
+    (match_code "const_int")
+    (match_test "SIGNED_INT13_SHIFTED (ival,1)")))
+
+(define_constraint "S12S2" "@internal
+  A 12-bit signed integer constant shifted by 2-bit(s)"
+  (and
+    (match_code "const_int")
+    (match_test "SIGNED_INT14_SHIFTED (ival,2)")))
+
+(define_constraint "S12S3" "@internal
+  A 12-bit signed integer constant shifted by 3-bit(s)"
+  (and
+    (match_code "const_int")
+    (match_test "SIGNED_INT15_SHIFTED (ival,3)")))
+
+(define_constraint "S03S0" "@internal
+  A 3-bit signed integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "SIGNED_INT3 (ival)")))
+
+(define_constraint "U07S0" "@internal
+  A 7-bit unsigned integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "UNSIGNED_INT7 (ival)")))
+
+(define_constraint "U03S0" "@internal
+  A 3-bit unsigned integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "UNSIGNED_INT3 (ival)")))
+
+(define_constraint "S11S0" "@internal
+  A 11-bit signed integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "SIGNED_INT11 (ival)")))
+
+(define_constraint "U05S0" "@internal
+  A 5-bit unsigned integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "UNSIGNED_INT5 (ival)")))
+
+(define_constraint "S09S0" "@internal
+  A 9-bit signed integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "SIGNED_INT9 (ival)")))
+
+(define_constraint "S21S0" "@internal
+  A 21-bit signed integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "SIGNED_INT21 (ival)")))
+
+(define_constraint "S25S0" "@internal
+  A 25-bit signed integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "SIGNED_INT25 (ival)")))
+
+(define_constraint "S10S0" "@internal
+  A 10-bit signed integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "SIGNED_INT10 (ival)")))
+
+(define_constraint "S07S0" "@internal
+  A 7-bit signed integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "SIGNED_INT7 (ival)")))
+
+(define_constraint "S13S0" "@internal
+  A 13-bit signed integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "SIGNED_INT13 (ival)")))
+
+(define_constraint "S08S0" "@internal
+  A 8-bit signed integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "SIGNED_INT8 (ival)")))
+
+(define_constraint "U10S0" "@internal
+  A 10-bit unsigned integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "UNSIGNED_INT10 (ival)")))
+
+(define_constraint "U08S0" "@internal
+  A 8-bit unsigned integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "UNSIGNED_INT8 (ival)")))
+
+(define_constraint "U09S0" "@internal
+  A 9-bit unsigned integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "UNSIGNED_INT9 (ival)")))
+
+(define_constraint "U12S0" "@internal
+  A 16-bit unsigned integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "UNSIGNED_INT12 (ival)")))
+
+(define_constraint "U16S0" "@internal
+  A 16-bit unsigned integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "UNSIGNED_INT16 (ival)")))
+
+(define_constraint "S16S0" "@internal
+  A 16-bit signed integer constant"
+  (and
+    (match_code "const_int")
+    (match_test "SIGNED_INT16 (ival)")))
+
+
+; TODO: Below this line definition should be corrected
+(define_constraint "SR_R0"
+  "@internal
+   @code{R0} register."
+  (and (match_code "reg")
+       (match_test "REGNO (op) == R0_REGNUM")))
+
+(define_constraint "SR_R1"
+  "@internal
+   @code{R1} register."
+  (and (match_code "reg")
+       (match_test "REGNO (op) == R1_REGNUM")))
+
+(define_constraint "SR_SP"
+  "@internal
+   @code{SP} register."
+  (and (match_code "reg")
+       (match_test "REGNO (op) == SP_REGNUM")))
+
+; TODO: FIX THIS
+(define_constraint "SR_GP"
+  "@internal
+   @code{GP} register."
+  (and (match_code "reg")
+       (match_test "REGNO (op) == R0_REGNUM")))
+
+; TODO: FIX THIS
+(define_constraint "SRPCL"
+  "@internal
+   @code{PCL} register."
+  (and (match_code "reg")
+       (match_test "REGNO (op) == R0_REGNUM")))
+
+;; Memory constraint used for atomic ops.
+(define_memory_constraint "ATOMC"
+  "A memory with only a base register"
+  (match_operand 0 "mem_noofs_operand"))
+
diff --git a/gcc/config/arc64/elf.h b/gcc/config/arc64/elf.h
new file mode 100644
index 00000000000..69f7ee63b46
--- /dev/null
+++ b/gcc/config/arc64/elf.h
@@ -0,0 +1,42 @@
+/* Target macros for arc64-elf targets.
+
+   Copyright (C) 2020 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#undef DWARF2_UNWIND_INFO
+#define DWARF2_UNWIND_INFO 0
+
+/* If no specs file is enforced, default to nosys libarary.  */
+#undef LINK_GCC_C_SEQUENCE_SPEC
+#define LINK_GCC_C_SEQUENCE_SPEC				\
+  "--start-group %G %{!specs=*:%{!nolibc:-lc -lnosys}} --end-group"
+
+/* Make sure we include the crtbegin.o.  */
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC "crt0%O%s crti%O%s crtbegin%O%s"
+
+#undef  LINK_SPEC
+#define LINK_SPEC "%{h*} \
+   %{static:-Bstatic}				\
+   %{shared:-shared}				\
+   %{symbolic:-Bsymbolic}			\
+   %{!static:%{rdynamic:-export-dynamic}}"
+
+/* ...and crtend.o.  */
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC "crtend%O%s crtn%O%s"
diff --git a/gcc/config/arc64/generate/arith.md b/gcc/config/arc64/generate/arith.md
new file mode 100644
index 00000000000..3b0bcd4a828
--- /dev/null
+++ b/gcc/config/arc64/generate/arith.md
@@ -0,0 +1,1395 @@
+; HEADER FOR THE FILE
+
+
+; TODO: addsi3: add1, add2, add3 were not included.
+; START:addsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (plus:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "add"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "add_s c:R3, b:R3, u3:uimm3 (67)", "assembly": "add_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q", "op2": "U03S0" } },
+;       { "_comment": "add_s b:R3, b:R3, u7:uimm7 (66)", "assembly": "add_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q", "op2": "U07S0" } },
+;       { "_comment": "add_s a:R3, b:R3, c:R3 (60)", "assembly": "add_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q", "op2": "q" } },
+;       { "_comment": "add_s b:R3, b:R3, limm:limm (64)", "assembly": "add_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "6" }, "constraints":   { "op0": "q", "op1": "q", "op2": "ULIMM" } },
+;       { "_comment": "add.cc.f b:R6, b:R6, c:R6 (54)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } },
+;       { "_comment": "add.cc.f b:R6, b:R6, limm:limm (55)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "add.cc.f b:R6, b:R6, u6:uimm6 (58)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "add.f a:R6, b:R6, u6:uimm6 (48)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "add.f b:R6, b:R6, s12:simm12 (52)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "S12S0" } },
+;       { "_comment": "add.f a:R6, b:R6, c:R6 (40)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } },
+;       { "_comment": "add.f a:R6, limm:limm, c:R6 (41)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "add.f a:R6, limm:limm, limm:limm (43)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "ULIMM" } },
+;       { "_comment": "add.f a:R6, limm:limm, u6:uimm6 (49)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "U06S0" } },
+;       { "_comment": "add.f a:R6, b:R6, limm:limm (42)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "add %0,%1,%2",
+;       "add_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "not included": [
+;         { "_comment": "add_s R0:r0, b:R3, u6:uimm6 (70)", "assembly": "add_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "TODO:R0", "op1": "q", "op2": "U06S0" } },
+;         { "_comment": "add_s R1:r1, b:R3, u6:uimm6 (71)", "assembly": "add_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "TODO:R1", "op1": "q", "op2": "U06S0" } },
+;         { "_comment": "add_s b:R3, b:R3, h:h (61)", "assembly": "add_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q", "op2": "TODO:h" } },
+;         { "_comment": "add_s h:h, h:h, s3:simm3 (62)", "assembly": "add_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "TODO:h", "op1": "TODO:h", "op2": "S03S0" } }
+;     ]
+;     }
+;   }
+; OUTPUT:addsi3
+(define_insn "addsi3" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=q,q,q,q,r,r,r,r,r,r,r,r,r,r") 
+      (plus:SI 
+        (match_operand:SI 1 "nonmemory_operand" "q,q,q,q,r,r,r,r,r,r,ULIMM,ULIMM,ULIMM,r") 
+        (match_operand:SI 2 "nonmemory_operand" "U03S0,U07S0,q,ULIMM,r,ULIMM,U06S0,U06S0,S12S0,r,r,ULIMM,U06S0,ULIMM")))]
+ "true" "@
+  add_s %0,%1,%2
+  add_s %0,%1,%2
+  add_s %0,%1,%2
+  add_s %0,%1,%2
+  add %0,%1,%2
+  add %0,%1,%2
+  add %0,%1,%2
+  add %0,%1,%2
+  add %0,%1,%2
+  add %0,%1,%2
+  add %0,%1,%2
+  add %0,%1,%2
+  add %0,%1,%2
+  add %0,%1,%2" [
+    (set_attr "predicable" "no,no,no,no,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "2,2,2,6,4,8,4,4,4,4,8,8,8,8")
+    (set_attr "type" "add,add,add,add,add,add,add,add,add,add,add,add,add,add")]
+)
+; END:addsi3
+
+; START:adddi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (minus:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "addl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "addl_s R0:r0, GP:gp, s11:simm11 (6584)", "assembly": "addl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "SR_R0", "op1": "SR_GP", "op2": "S11S0" } },
+;       { "_comment": "addl_s SP:sp, SP:sp, u9:uimm9 (6575)", "assembly": "addl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "SR_SP", "op1": "0", "op2": "U09S0" } },
+;       { "_comment": "addl_s b:R3, SP:sp, u7:uimm7 (6574)", "assembly": "addl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "SR_SP", "op2": "U07S0" } },
+;       { "_comment": "addl_s b:R3, b:R3, c:R3 (6585)", "assembly": "addl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "q" } },
+;       { "_comment": "addl.cc.f RB:rb, RB:rb, u6:uimm6 (4968)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "addl.cc.f RB:rb, RB:rb, limm:limm (4975)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "addl.cc.f RB:rb, RB:rb, ximm:ximm (4988)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "addl.cc.f RB:rb, RB:rb, RC:rc (4965)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "addl.f RA:ra, RB:rb, u6:uimm6 (4966)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "addl.f RB:rb, RB:rb, s12:simm12 (4969)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "S12S0" } },
+;       { "_comment": "addl.f RA:ra, limm:limm, u6:uimm6 (4976)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "U06S0" } },
+;       { "_comment": "addl.f RA:ra, ximm:ximm, u6:uimm6 (4989)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "U06S0" } },
+;       { "_comment": "addl.f RA:ra, limm:limm, RC:rc (4970)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "addl.f RA:ra, ximm:ximm, RC:rc (4983)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "addl.f RA:ra, RB:rb, limm:limm (4971)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "addl.f RA:ra, RB:rb, ximm:ximm (4984)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "addl.f RA:ra, RB:rb, RC:rc (4963)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "addl %0,%1,%2",
+;       "addl_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "not included": [
+;         { "_comment": "addl_s h:h, PCL:pcl, ximm:ximm (6595)", "assembly": "addl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "TODO:h", "op1": "SRPCL", "op2": "UXIMM" } },
+;         { "_comment": "addl_s h:h, h:h, ximm:ximm (6594)", "assembly": "addl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "TODO:h", "op1": "TODO:h", "op2": "UXIMM" } },
+;         { "_comment": "addl.f RA:ra, limm:limm, limm:limm (4980)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "ULIMM" } },
+;         { "_comment": "addl.f RA:ra, ximm:ximm, ximm:ximm (4993)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "UXIMM" } }
+;     ]
+;     }
+;   }
+; OUTPUT:adddi3
+(define_insn "adddi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=SR_R0,SR_SP,q,q,r,r,r,r,r,r,r,r,r,r,r,r,r") 
+      (minus:DI 
+        (match_operand:DI 1 "nonmemory_operand" "SR_GP,0,SR_SP,0,0,0,0,0,r,r,ULIMM,UXIMM,ULIMM,UXIMM,r,r,r") 
+        (match_operand:DI 2 "nonmemory_operand" "S11S0,U09S0,U07S0,q,U06S0,ULIMM,UXIMM,r,U06S0,S12S0,U06S0,U06S0,r,r,ULIMM,UXIMM,r")))]
+ "true" "@
+  addl_s %0,%1,%2
+  addl_s %0,%1,%2
+  addl_s %0,%1,%2
+  addl_s %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2" [
+    (set_attr "predicable" "no,no,no,no,yes,yes,yes,yes,no,no,no,no,no,no,no,no,no")
+    (set_attr "length" "2,2,2,2,4,8,4,4,4,4,8,4,8,4,8,4,4")
+    (set_attr "type" "addl,addl,addl,addl,addl,addl,addl,addl,addl,addl,addl,addl,addl,addl,addl,addl,addl")]
+)
+; END:adddi3
+
+; START:subsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (minus:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "sub"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "sub_s b:R3, b:R3, c:R3 (3279)", "assembly": "sub_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "q" } },
+;       { "_comment": "sub_s c:R3, b:R3, u3:uimm3 (3277)", "assembly": "sub_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q", "op2": "U03S0" } },
+;       { "_comment": "sub_s b:R3, b:R3, u5:uimm5 (3280)", "assembly": "sub_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "U05S0" } },
+;       { "_comment": "sub_s a:R3, b:R3, c:R3 (3282)", "assembly": "sub_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q", "op2": "q" } },
+;       { "_comment": "sub.cc.f b:R6, b:R6, u6:uimm6 (3275)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "sub.cc.f b:R6, b:R6, limm:limm (3272)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "sub.cc.f b:R6, b:R6, c:R6 (3271)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "sub.f a:R6, b:R6, limm:limm (3259)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "sub.f a:R6, b:R6, u6:uimm6 (3265)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "sub.f b:R6, b:R6, s12:simm12 (3269)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "sub.f a:R6, limm:limm, c:R6 (3258)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "sub.f a:R6, limm:limm, u6:uimm6 (3266)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "U06S0" } },
+;       { "_comment": "sub.f a:R6, b:R6, c:R6 (3257)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "sub %0,%1,%2",
+;       "sub_s %0,%1,%2",
+;       "sub1 %0,%1,%2",
+;       "sub2 %0,%1,%2",
+;       "sub3 %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "not included": [
+;         { "_comment": "sub_s.NE b:R3, b:R3, b:R3 (3278)", "assembly": "sub_s %0,%1,%2", "attributes":   { "predicable": "yes", "length": "2" }, "constraints":   { "op0": "q", "op1": "q", "op2": "q" } },
+;         { "_comment": "sub.f a:R6, limm:limm, limm:limm (3260)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "ULIMM" } }
+;     ]
+;     }
+;   }
+; END:subsi3
+
+; START:subdi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (minus:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "sub"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "subl_s SP:sp, SP:sp, u9:uimm9 (6576)", "assembly": "subl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "SR_SP", "op1": "0", "op2": "U09S0" } },
+;       { "_comment": "subl_s b:R3, b:R3, c:R3 (6586)", "assembly": "subl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "q" } },
+;       { "_comment": "subl.cc.f RB:rb, RB:rb, RC:rc (5031)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "subl.cc.f RB:rb, RB:rb, limm:limm (5041)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "subl.cc.f RB:rb, RB:rb, u6:uimm6 (5034)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "subl.cc.f RB:rb, RB:rb, ximm:ximm (5054)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "subl.f RA:ra, RB:rb, u6:uimm6 (5032)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "subl.f RB:rb, RB:rb, s12:simm12 (5035)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "subl.f RA:ra, RB:rb, limm:limm (5037)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "subl.f RA:ra, RB:rb, ximm:ximm (5050)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "subl.f RA:ra, limm:limm, RC:rc (5036)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "subl.f RA:ra, ximm:ximm, RC:rc (5049)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "subl.f RA:ra, RB:rb, RC:rc (5029)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "subl %0,%1,%2",
+;       "subl_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:subdi3
+(define_insn "subdi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=SR_SP,q,r,r,r,r,r,r,r,r,r,r,r") 
+      (minus:DI 
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,0,0,r,0,r,r,ULIMM,UXIMM,r") 
+        (match_operand:DI 2 "nonmemory_operand" "U09S0,q,r,ULIMM,U06S0,UXIMM,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  subl_s %0,%1,%2
+  subl_s %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2" [
+    (set_attr "predicable" "no,no,yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "2,2,4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "sub,sub,sub,sub,sub,sub,sub,sub,sub,sub,sub,sub,sub")]
+)
+; END:subdi3
+
+; START:abssi2
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (abs:SI @op1{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "abs"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "",
+;   "ordered_constraints": [
+;       { "_comment": "abs_s b:R3, c:R3 (7)", "assembly": "abs_s %0,%1", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q" } },
+;       { "_comment": "abs.f b:R6, u6:uimm6 (5)", "assembly": "abs %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "abs.f b:R6, limm:limm (2)", "assembly": "abs %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "abs.f b:R6, c:R6 (1)", "assembly": "abs %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "abs %0,%1",
+;       "abs_s %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:abssi2
+(define_insn "abssi2" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=q,r,r,r") 
+      (abs:SI 
+        (match_operand:SI 1 "nonmemory_operand" "q,U06S0,ULIMM,r")))]
+ "true" "@
+  abs_s %0,%1
+  abs %0,%1
+  abs %0,%1
+  abs %0,%1" [
+    (set_attr "predicable" "no,no,no,no")
+    (set_attr "length" "2,4,8,4")
+    (set_attr "type" "abs,abs,abs,abs")]
+)
+; END:abssi2
+
+
+; START:absdi2
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (abs:DI @op1{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "abs"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "",
+;   "ordered_constraints": [
+;       { "_comment": "absl.f RB:rb, u6:uimm6 (6300)", "assembly": "absl %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "absl.f RB:rb, limm:limm (6302)", "assembly": "absl %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "absl.f RB:rb, ximm:ximm (6304)", "assembly": "absl %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM" } },
+;       { "_comment": "absl.f RB:rb, RC:rc (6298)", "assembly": "absl %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "absl %0,%1",
+;       "absl_s %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:absdi2
+(define_insn "absdi2" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=r,r,r,r") 
+      (abs:DI 
+        (match_operand:DI 1 "nonmemory_operand" "U06S0,ULIMM,UXIMM,r")))]
+ "true" "@
+  absl %0,%1
+  absl %0,%1
+  absl %0,%1
+  absl %0,%1" [
+    (set_attr "predicable" "no,no,no,no")
+    (set_attr "length" "4,8,4,4")
+    (set_attr "type" "abs,abs,abs,abs")]
+)
+; END:absdi2
+
+
+; START:negsi2
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (neg:SI @op1{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "neg"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "neg_s b:R3, c:R3 (2495)", "assembly": "neg_s %0,%1", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q" } },
+;       { "_comment": "neg.cc.f b:R6, b:R6 (2493)", "assembly": "neg %0,%1", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0" } },
+;       { "_comment": "neg.f a:R6, limm:limm (2492)", "assembly": "neg %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "neg.f a:R6, b:R6 (2491)", "assembly": "neg %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "neg %0,%1",
+;       "neg_s %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:negsi2
+(define_insn "negsi2" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=q,r,r,r") 
+      (neg:SI 
+        (match_operand:SI 1 "nonmemory_operand" "q,0,ULIMM,r")))]
+ "true" "@
+  neg_s %0,%1
+  neg %0,%1
+  neg %0,%1
+  neg %0,%1" [
+    (set_attr "predicable" "no,yes,no,no")
+    (set_attr "length" "2,4,8,4")
+    (set_attr "type" "neg,neg,neg,neg")]
+)
+; END:negsi2
+
+; START:divsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (div:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "div"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "div.cc.f b:R6, b:R6, c:R6 (780)", "assembly": "div %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "div.cc.f b:R6, b:R6, u6:uimm6 (784)", "assembly": "div %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "div.cc.f b:R6, b:R6, limm:limm (781)", "assembly": "div %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "div.f b:R6, b:R6, s12:simm12 (778)", "assembly": "div %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "div.f a:R6, b:R6, u6:uimm6 (774)", "assembly": "div %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "div.f a:R6, b:R6, limm:limm (768)", "assembly": "div %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "div.f a:R6, limm:limm, c:R6 (767)", "assembly": "div %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "div.f a:R6, b:R6, c:R6 (766)", "assembly": "div %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "div %0,%1,%2",
+;       "div_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:divsi3
+(define_insn "divsi3" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,r") 
+      (div:SI 
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,0,r,r,ULIMM,r") 
+        (match_operand:SI 2 "nonmemory_operand" "r,U06S0,ULIMM,S12S0,U06S0,ULIMM,r,r")))]
+ "true" "@
+  div %0,%1,%2
+  div %0,%1,%2
+  div %0,%1,%2
+  div %0,%1,%2
+  div %0,%1,%2
+  div %0,%1,%2
+  div %0,%1,%2
+  div %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "4,4,8,4,4,8,8,4")
+    (set_attr "type" "div,div,div,div,div,div,div,div")]
+)
+; END:divsi3
+
+; START:divdi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (div:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "div"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "divl.cc.f RB:rb, RB:rb, u6:uimm6 (5760)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "divl.cc.f RB:rb, RB:rb, limm:limm (5767)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "divl.cc.f RB:rb, RB:rb, ximm:ximm (5780)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "divl.cc.f RB:rb, RB:rb, RC:rc (5757)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "divl.f RA:ra, RB:rb, u6:uimm6 (5758)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "divl.f RB:rb, RB:rb, s12:simm12 (5761)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "divl.f RA:ra, RB:rb, limm:limm (5763)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "divl.f RA:ra, RB:rb, ximm:ximm (5776)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "divl.f RA:ra, limm:limm, RC:rc (5762)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "divl.f RA:ra, ximm:ximm, RC:rc (5775)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "divl.f RA:ra, RB:rb, RC:rc (5755)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "divl %0,%1,%2",
+;       "divl_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:divdi3
+(define_insn "divdi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r") 
+      (div:DI 
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r") 
+        (match_operand:DI 2 "nonmemory_operand" "U06S0,ULIMM,UXIMM,r,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "div,div,div,div,div,div,div,div,div,div,div")]
+)
+; END:divdi3
+
+; START:udivsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (udiv:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "udiv"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "divu.cc.f b:R6, b:R6, u6:uimm6 (804)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "divu.cc.f b:R6, b:R6, limm:limm (801)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "divu.cc.f b:R6, b:R6, c:R6 (800)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "divu.f a:R6, b:R6, u6:uimm6 (794)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "divu.f b:R6, b:R6, s12:simm12 (798)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "divu.f a:R6, b:R6, limm:limm (788)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "divu.f a:R6, limm:limm, c:R6 (787)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "divu.f a:R6, limm:limm, limm:limm (789)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "ULIMM" } },
+;       { "_comment": "divu.f a:R6, limm:limm, u6:uimm6 (795)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "U06S0" } },
+;       { "_comment": "divu.f a:R6, b:R6, c:R6 (786)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "divu %0,%1,%2",
+;       "divu_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:udivsi3
+(define_insn "udivsi3" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r") 
+      (udiv:SI 
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,r,0,r,ULIMM,ULIMM,ULIMM,r") 
+        (match_operand:SI 2 "nonmemory_operand" "U06S0,ULIMM,r,U06S0,S12S0,ULIMM,r,ULIMM,U06S0,r")))]
+ "true" "@
+  divu %0,%1,%2
+  divu %0,%1,%2
+  divu %0,%1,%2
+  divu %0,%1,%2
+  divu %0,%1,%2
+  divu %0,%1,%2
+  divu %0,%1,%2
+  divu %0,%1,%2
+  divu %0,%1,%2
+  divu %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,8,8,8,8,4")
+    (set_attr "type" "udiv,udiv,udiv,udiv,udiv,udiv,udiv,udiv,udiv,udiv")]
+)
+; END:udivsi3
+
+; START:udivdi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (udiv:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "udivl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "divl.cc.f RB:rb, RB:rb, u6:uimm6 (5760)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "divl.cc.f RB:rb, RB:rb, limm:limm (5767)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "divl.cc.f RB:rb, RB:rb, ximm:ximm (5780)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "divl.cc.f RB:rb, RB:rb, RC:rc (5757)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "divl.f RA:ra, RB:rb, u6:uimm6 (5758)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "divl.f RB:rb, RB:rb, s12:simm12 (5761)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "divl.f RA:ra, RB:rb, limm:limm (5763)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "divl.f RA:ra, RB:rb, ximm:ximm (5776)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "divl.f RA:ra, limm:limm, RC:rc (5762)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "divl.f RA:ra, ximm:ximm, RC:rc (5775)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "divl.f RA:ra, RB:rb, RC:rc (5755)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "divul %0,%1,%2",
+;       "divul_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:udivdi3
+(define_insn "udivdi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r") 
+      (udiv:DI 
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r") 
+        (match_operand:DI 2 "nonmemory_operand" "U06S0,ULIMM,UXIMM,r,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "udivl,udivl,udivl,udivl,udivl,udivl,udivl,udivl,udivl,udivl,udivl")]
+)
+; END:udivdi3
+
+; START:smaxsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (smax:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "max"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "max.cc.f b:R6, b:R6, u6:uimm6 (2043)", "assembly": "max %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "max.cc.f b:R6, b:R6, limm:limm (2040)", "assembly": "max %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "max.cc.f b:R6, b:R6, c:R6 (2039)", "assembly": "max %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "max.f a:R6, b:R6, u6:uimm6 (2033)", "assembly": "max %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "max.f b:R6, b:R6, s12:simm12 (2037)", "assembly": "max %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "max.f a:R6, b:R6, limm:limm (2027)", "assembly": "max %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "max.f a:R6, limm:limm, c:R6 (2026)", "assembly": "max %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "max.f a:R6, b:R6, c:R6 (2025)", "assembly": "max %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "max %0,%1,%2",
+;       "max_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:smaxsi3
+(define_insn "smaxsi3" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,r") 
+      (smax:SI 
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,r,0,r,ULIMM,r") 
+        (match_operand:SI 2 "nonmemory_operand" "U06S0,ULIMM,r,U06S0,S12S0,ULIMM,r,r")))]
+ "true" "@
+  max %0,%1,%2
+  max %0,%1,%2
+  max %0,%1,%2
+  max %0,%1,%2
+  max %0,%1,%2
+  max %0,%1,%2
+  max %0,%1,%2
+  max %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,8,8,4")
+    (set_attr "type" "max,max,max,max,max,max,max,max")]
+)
+; END:smaxsi3
+
+; START:smaxdi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (smax:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "maxl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "maxl.cc.f RB:rb, RB:rb, u6:uimm6 (5232)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "maxl.cc.f RB:rb, RB:rb, limm:limm (5239)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "maxl.cc.f RB:rb, RB:rb, ximm:ximm (5252)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "maxl.cc.f RB:rb, RB:rb, RC:rc (5229)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "maxl.f RA:ra, RB:rb, u6:uimm6 (5230)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "maxl.f RB:rb, RB:rb, s12:simm12 (5233)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "maxl.f RA:ra, RB:rb, limm:limm (5235)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "maxl.f RA:ra, RB:rb, ximm:ximm (5248)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "maxl.f RA:ra, limm:limm, RC:rc (5234)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "maxl.f RA:ra, ximm:ximm, RC:rc (5247)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "maxl.f RA:ra, RB:rb, RC:rc (5227)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "maxl %0,%1,%2",
+;       "maxl_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ],
+;     "failed_for_operands": [
+;         { "_comment": "maxl.aq RB:rb, RC:rc (6426)" },
+;         { "_comment": "maxl.aq 0:0, RC:rc (6427)" },
+;         { "_comment": "maxl.aq RB:rb, u6:uimm6 (6428)" },
+;         { "_comment": "maxl.aq 0:0, u6:uimm6 (6429)" },
+;         { "_comment": "maxl.aq RB:rb, limm:limm (6430)" },
+;         { "_comment": "maxl.aq 0:0, limm:limm (6431)" },
+;         { "_comment": "maxl.aq RB:rb, ximm:ximm (6432)" },
+;         { "_comment": "maxl.aq 0:0, ximm:ximm (6433)" }
+;     ]
+;     }
+;   }
+; OUTPUT:smaxdi3
+(define_insn "smaxdi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r") 
+      (smax:DI 
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r") 
+        (match_operand:DI 2 "nonmemory_operand" "U06S0,ULIMM,UXIMM,r,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "maxl,maxl,maxl,maxl,maxl,maxl,maxl,maxl,maxl,maxl,maxl")]
+)
+; END:smaxdi3
+
+
+; START:sminsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (smin:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "min"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "min.cc.f b:R6, b:R6, c:R6 (2059)", "assembly": "min %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "min.cc.f b:R6, b:R6, limm:limm (2060)", "assembly": "min %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "min.cc.f b:R6, b:R6, u6:uimm6 (2063)", "assembly": "min %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "min.f a:R6, b:R6, u6:uimm6 (2053)", "assembly": "min %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "min.f b:R6, b:R6, s12:simm12 (2057)", "assembly": "min %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "min.f a:R6, b:R6, limm:limm (2047)", "assembly": "min %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "min.f a:R6, limm:limm, c:R6 (2046)", "assembly": "min %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "min.f a:R6, b:R6, c:R6 (2045)", "assembly": "min %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "min %0,%1,%2",
+;       "min_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:sminsi3
+(define_insn "sminsi3" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,r") 
+      (smin:SI 
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,r,0,r,ULIMM,r") 
+        (match_operand:SI 2 "nonmemory_operand" "r,ULIMM,U06S0,U06S0,S12S0,ULIMM,r,r")))]
+ "true" "@
+  min %0,%1,%2
+  min %0,%1,%2
+  min %0,%1,%2
+  min %0,%1,%2
+  min %0,%1,%2
+  min %0,%1,%2
+  min %0,%1,%2
+  min %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,8,8,4")
+    (set_attr "type" "min,min,min,min,min,min,min,min")]
+)
+; END:sminsi3
+
+
+; START:smindi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (smin:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "minl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "minl.cc.f RB:rb, RB:rb, RC:rc (5262)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "minl.cc.f RB:rb, RB:rb, limm:limm (5272)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "minl.cc.f RB:rb, RB:rb, u6:uimm6 (5265)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "minl.cc.f RB:rb, RB:rb, ximm:ximm (5285)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "minl.f RA:ra, RB:rb, u6:uimm6 (5263)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "minl.f RB:rb, RB:rb, s12:simm12 (5266)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "minl.f RA:ra, RB:rb, limm:limm (5268)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "minl.f RA:ra, RB:rb, ximm:ximm (5281)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "minl.f RA:ra, limm:limm, RC:rc (5267)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "minl.f RA:ra, ximm:ximm, RC:rc (5280)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "minl.f RA:ra, RB:rb, RC:rc (5260)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "minl %0,%1,%2",
+;       "minl_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ],
+;     "failed_for_operands": [
+;         { "_comment": "minl.aq RB:rb, RC:rc (6410)" },
+;         { "_comment": "minl.aq 0:0, RC:rc (6411)" },
+;         { "_comment": "minl.aq RB:rb, u6:uimm6 (6412)" },
+;         { "_comment": "minl.aq 0:0, u6:uimm6 (6413)" },
+;         { "_comment": "minl.aq RB:rb, limm:limm (6414)" },
+;         { "_comment": "minl.aq 0:0, limm:limm (6415)" },
+;         { "_comment": "minl.aq RB:rb, ximm:ximm (6416)" },
+;         { "_comment": "minl.aq 0:0, ximm:ximm (6417)" }
+;     ]
+;     }
+;   }
+; OUTPUT:smindi3
+(define_insn "smindi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r") 
+      (smin:DI 
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r") 
+        (match_operand:DI 2 "nonmemory_operand" "r,ULIMM,U06S0,UXIMM,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "minl,minl,minl,minl,minl,minl,minl,minl,minl,minl,minl")]
+)
+; END:smindi3
+
+; START:modsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (mod:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "rem"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "rem.cc.f b:R6, b:R6, c:R6 (2882)", "assembly": "rem %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "rem.cc.f b:R6, b:R6, limm:limm (2883)", "assembly": "rem %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "rem.cc.f b:R6, b:R6, u6:uimm6 (2886)", "assembly": "rem %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "rem.f a:R6, b:R6, u6:uimm6 (2876)", "assembly": "rem %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "rem.f b:R6, b:R6, s12:simm12 (2880)", "assembly": "rem %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "rem.f a:R6, b:R6, limm:limm (2870)", "assembly": "rem %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "rem.f a:R6, limm:limm, c:R6 (2869)", "assembly": "rem %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "rem.f a:R6, b:R6, c:R6 (2868)", "assembly": "rem %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "rem %0,%1,%2",
+;       "rem_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:modsi3
+(define_insn "modsi3" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,r") 
+      (mod:SI 
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,r,0,r,ULIMM,r") 
+        (match_operand:SI 2 "nonmemory_operand" "r,ULIMM,U06S0,U06S0,S12S0,ULIMM,r,r")))]
+ "true" "@
+  rem %0,%1,%2
+  rem %0,%1,%2
+  rem %0,%1,%2
+  rem %0,%1,%2
+  rem %0,%1,%2
+  rem %0,%1,%2
+  rem %0,%1,%2
+  rem %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,8,8,4")
+    (set_attr "type" "rem,rem,rem,rem,rem,rem,rem,rem")]
+)
+; END:modsi3
+
+; START:moddi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (mod:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "reml"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "reml.cc.f RB:rb, RB:rb, u6:uimm6 (5826)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "reml.cc.f RB:rb, RB:rb, RC:rc (5823)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "reml.cc.f RB:rb, RB:rb, limm:limm (5833)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "reml.cc.f RB:rb, RB:rb, ximm:ximm (5846)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "reml.f RA:ra, RB:rb, u6:uimm6 (5824)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "reml.f RB:rb, RB:rb, s12:simm12 (5827)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "reml.f RA:ra, RB:rb, limm:limm (5829)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "reml.f RA:ra, RB:rb, ximm:ximm (5842)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "reml.f RA:ra, limm:limm, RC:rc (5828)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "reml.f RA:ra, ximm:ximm, RC:rc (5841)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "reml.f RA:ra, RB:rb, RC:rc (5821)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "reml %0,%1,%2",
+;       "reml_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:moddi3
+(define_insn "moddi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r") 
+      (mod:DI 
+        (match_operand:DI 1 "nonmemory_operand" "r,0,0,0,r,0,r,r,ULIMM,UXIMM,r") 
+        (match_operand:DI 2 "nonmemory_operand" "U06S0,r,ULIMM,UXIMM,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,4,8,4,4,4,8,4,8,4,4")
+    (set_attr "type" "reml,reml,reml,reml,reml,reml,reml,reml,reml,reml,reml")]
+)
+; END:moddi3
+
+; START:umodsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (umod:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "remu"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "remu.cc.f b:R6, b:R6, c:R6 (2902)", "assembly": "remu %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "remu.cc.f b:R6, b:R6, limm:limm (2903)", "assembly": "remu %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "remu.cc.f b:R6, b:R6, u6:uimm6 (2906)", "assembly": "remu %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "remu.f a:R6, b:R6, u6:uimm6 (2896)", "assembly": "remu %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "remu.f b:R6, b:R6, s12:simm12 (2900)", "assembly": "remu %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "remu.f a:R6, b:R6, limm:limm (2890)", "assembly": "remu %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "remu.f a:R6, limm:limm, c:R6 (2889)", "assembly": "remu %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "remu.f a:R6, b:R6, c:R6 (2888)", "assembly": "remu %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "remu %0,%1,%2",
+;       "remu_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:umodsi3
+(define_insn "umodsi3" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,r") 
+      (umod:SI 
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,r,0,r,ULIMM,r") 
+        (match_operand:SI 2 "nonmemory_operand" "r,ULIMM,U06S0,U06S0,S12S0,ULIMM,r,r")))]
+ "true" "@
+  remu %0,%1,%2
+  remu %0,%1,%2
+  remu %0,%1,%2
+  remu %0,%1,%2
+  remu %0,%1,%2
+  remu %0,%1,%2
+  remu %0,%1,%2
+  remu %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,8,8,4")
+    (set_attr "type" "remu,remu,remu,remu,remu,remu,remu,remu")]
+)
+; END:umodsi3
+
+; START:umoddi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (umod:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "remul"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "remul.cc.f RB:rb, RB:rb, RC:rc (5856)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "remul.cc.f RB:rb, RB:rb, limm:limm (5866)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "remul.cc.f RB:rb, RB:rb, u6:uimm6 (5859)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "remul.cc.f RB:rb, RB:rb, ximm:ximm (5879)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "remul.f RB:rb, RB:rb, s12:simm12 (5860)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "S12S0" } },
+;       { "_comment": "remul.f RA:ra, RB:rb, u6:uimm6 (5857)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "remul.f RA:ra, RB:rb, limm:limm (5862)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "remul.f RA:ra, RB:rb, ximm:ximm (5875)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "remul.f RA:ra, limm:limm, RC:rc (5861)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "remul.f RA:ra, ximm:ximm, RC:rc (5874)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "remul.f RA:ra, RB:rb, RC:rc (5854)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "remul %0,%1,%2",
+;       "remul_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:umoddi3
+(define_insn "umoddi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r") 
+      (umod:DI 
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r") 
+        (match_operand:DI 2 "nonmemory_operand" "r,ULIMM,U06S0,UXIMM,S12S0,U06S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "remul,remul,remul,remul,remul,remul,remul,remul,remul,remul,remul")]
+)
+; END:umoddi3
+
+
+; START:xorsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (xor:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "xor"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "xor.cc.f b:R6, b:R6, c:R6 (4502)", "assembly": "xor %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "xor.cc.f b:R6, b:R6, limm:limm (4504)", "assembly": "xor %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "xor.cc.f b:R6, b:R6, u6:uimm6 (4506)", "assembly": "xor %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "xor.f b:R6, b:R6, s12:simm12 (4500)", "assembly": "xor %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "xor.f a:R6, b:R6, limm:limm (4490)", "assembly": "xor %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "xor.f a:R6, b:R6, u6:uimm6 (4496)", "assembly": "xor %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "xor.f a:R6, limm:limm, c:R6 (4489)", "assembly": "xor %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "xor_s b:R3, b:R3, c:R3 (4508)", "assembly": "xor_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "q" } },
+;       { "_comment": "xor.f a:R6, b:R6, c:R6 (4488)", "assembly": "xor %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "xor %0,%1,%2",
+;       "xor_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:xorsi3
+(define_insn "xorsi3" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,q,r") 
+      (xor:SI 
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,0,r,r,ULIMM,0,r") 
+        (match_operand:SI 2 "nonmemory_operand" "r,ULIMM,U06S0,S12S0,ULIMM,U06S0,r,q,r")))]
+ "true" "@
+  xor %0,%1,%2
+  xor %0,%1,%2
+  xor %0,%1,%2
+  xor %0,%1,%2
+  xor %0,%1,%2
+  xor %0,%1,%2
+  xor %0,%1,%2
+  xor_s %0,%1,%2
+  xor %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,8,4,8,2,4")
+    (set_attr "type" "xor,xor,xor,xor,xor,xor,xor,xor,xor")]
+)
+; END:xorsi3
+
+; START:xordi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (xor:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "xorl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "xorl.cc.f RB:rb, RB:rb, RC:rc (5196)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "xorl.cc.f RB:rb, RB:rb, limm:limm (5206)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "xorl.cc.f RB:rb, RB:rb, u6:uimm6 (5199)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "xorl.cc.f RB:rb, RB:rb, ximm:ximm (5219)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "xorl.f RA:ra, RB:rb, u6:uimm6 (5197)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "xorl.f RB:rb, RB:rb, s12:simm12 (5200)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "xorl.f RA:ra, RB:rb, limm:limm (5202)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "xorl.f RA:ra, RB:rb, ximm:ximm (5215)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "xorl.f RA:ra, limm:limm, RC:rc (5201)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "xorl.f RA:ra, ximm:ximm, RC:rc (5214)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "xorl.f RA:ra, RB:rb, RC:rc (5194)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "xorl %0,%1,%2",
+;       "xorl_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ],
+;     "failed_for_operands": [
+;         { "_comment": "xorl.aq RB:rb, RC:rc (6394)" },
+;         { "_comment": "xorl.aq 0:0, RC:rc (6395)" },
+;         { "_comment": "xorl.aq RB:rb, u6:uimm6 (6396)" },
+;         { "_comment": "xorl.aq 0:0, u6:uimm6 (6397)" },
+;         { "_comment": "xorl.aq RB:rb, limm:limm (6398)" },
+;         { "_comment": "xorl.aq 0:0, limm:limm (6399)" },
+;         { "_comment": "xorl.aq RB:rb, ximm:ximm (6400)" },
+;         { "_comment": "xorl.aq 0:0, ximm:ximm (6401)" }
+;     ]
+;     }
+;   }
+; OUTPUT:xordi3
+(define_insn "xordi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r") 
+      (xor:DI 
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r") 
+        (match_operand:DI 2 "nonmemory_operand" "r,ULIMM,U06S0,UXIMM,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "xorl,xorl,xorl,xorl,xorl,xorl,xorl,xorl,xorl,xorl,xorl")]
+)
+; END:xordi3
+
+
diff --git a/gcc/config/arc64/generate/logic.md b/gcc/config/arc64/generate/logic.md
new file mode 100644
index 00000000000..3db5ffdd43d
--- /dev/null
+++ b/gcc/config/arc64/generate/logic.md
@@ -0,0 +1,2190 @@
+
+; START:andsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (and:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "and"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "and_s b:R3, b:R3, c:R3 (189)", "assembly": "and_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "q" } },
+;       { "_comment": "and.cc.f b:R6, b:R6, u6:uimm6 (187)", "assembly": "and %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "and.cc.f b:R6, b:R6, limm:limm (184)", "assembly": "and %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "and.cc.f b:R6, b:R6, c:R6 (183)", "assembly": "and %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "and.f a:R6, b:R6, u6:uimm6 (177)", "assembly": "and %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "and.f b:R6, b:R6, s12:simm12 (181)", "assembly": "and %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "and.f a:R6, b:R6, c:R6 (169)", "assembly": "and %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } },
+;       { "_comment": "and.f a:R6, b:R6, limm:limm (171)", "assembly": "and %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "and.f a:R6, limm:limm, c:R6 (170)", "assembly": "and %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "and %0,%1,%2",
+;       "and_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:andsi3
+(define_insn "andsi3" [
+    (set
+      (match_operand:SI 0 "register_operand" "=q,r,r,r,r,r,r,r,r")
+      (and:SI
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM")
+        (match_operand:SI 2 "nonmemory_operand" "q,U06S0,ULIMM,r,U06S0,S12S0,r,ULIMM,r")))]
+ "true" "@
+  and_s %0,%1,%2
+  and %0,%1,%2
+  and %0,%1,%2
+  and %0,%1,%2
+  and %0,%1,%2
+  and %0,%1,%2
+  and %0,%1,%2
+  and %0,%1,%2
+  and %0,%1,%2" [
+    (set_attr "predicable" "no,yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "2,4,8,4,4,4,4,8,8")
+    (set_attr "type" "and,and,and,and,and,and,and,and,and")]
+)
+; END:andsi3
+
+; START:anddi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (and:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "andl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "andl_s b:R3, b:R3, c:R3 (6587)", "assembly": "andl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "q" } },
+;       { "_comment": "andl.cc.f RB:rb, RB:rb, u6:uimm6 (5100)", "assembly": "andl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "andl.cc.f RB:rb, RB:rb, limm:limm (5107)", "assembly": "andl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "andl.cc.f RB:rb, RB:rb, ximm:ximm (5120)", "assembly": "andl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "andl.cc.f RB:rb, RB:rb, RC:rc (5097)", "assembly": "andl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "andl.f RA:ra, RB:rb, u6:uimm6 (5098)", "assembly": "andl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "andl.f RB:rb, RB:rb, s12:simm12 (5101)", "assembly": "andl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "andl.f RA:ra, RB:rb, limm:limm (5103)", "assembly": "andl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "andl.f RA:ra, RB:rb, ximm:ximm (5116)", "assembly": "andl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "andl.f RA:ra, limm:limm, RC:rc (5102)", "assembly": "andl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "andl.f RA:ra, ximm:ximm, RC:rc (5115)", "assembly": "andl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "andl.f RA:ra, RB:rb, RC:rc (5095)", "assembly": "andl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "andl %0,%1,%2",
+;       "andl_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ],
+;     "failed_for_operands": [
+;         { "_comment": "andl.aq RB:rb, RC:rc (6402)" },
+;         { "_comment": "andl.aq 0:0, RC:rc (6403)" },
+;         { "_comment": "andl.aq RB:rb, u6:uimm6 (6404)" },
+;         { "_comment": "andl.aq 0:0, u6:uimm6 (6405)" },
+;         { "_comment": "andl.aq RB:rb, limm:limm (6406)" },
+;         { "_comment": "andl.aq 0:0, limm:limm (6407)" },
+;         { "_comment": "andl.aq RB:rb, ximm:ximm (6408)" },
+;         { "_comment": "andl.aq 0:0, ximm:ximm (6409)" }
+;     ]
+;     }
+;   }
+; OUTPUT:anddi3
+(define_insn "anddi3" [
+    (set
+      (match_operand:DI 0 "register_operand" "=q,r,r,r,r,r,r,r,r,r,r,r")
+      (and:DI
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,0,r,0,r,r,ULIMM,UXIMM,r")
+        (match_operand:DI 2 "nonmemory_operand" "q,U06S0,ULIMM,UXIMM,r,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  andl_s %0,%1,%2
+  andl %0,%1,%2
+  andl %0,%1,%2
+  andl %0,%1,%2
+  andl %0,%1,%2
+  andl %0,%1,%2
+  andl %0,%1,%2
+  andl %0,%1,%2
+  andl %0,%1,%2
+  andl %0,%1,%2
+  andl %0,%1,%2
+  andl %0,%1,%2" [
+    (set_attr "predicable" "no,yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "2,4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "andl,andl,andl,andl,andl,andl,andl,andl,andl,andl,andl,andl")]
+)
+; END:anddi3
+
+
+; START:ashlsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (ashift:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "asl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "asl_s c:R3, b:R3, u3:uimm3 (217)", "assembly": "asl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "U03S0" } },
+;       { "_comment": "asl_s b:R3, b:R3, u5:uimm5 (219)", "assembly": "asl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "U05S0" } },
+;       { "_comment": "asl_s b:R3, b:R3, c:R3 (218)", "assembly": "asl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "q" } },
+;       { "_comment": "asl.cc.f b:R6, b:R6, u6:uimm6 (215)", "assembly": "asl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "asl.cc.f b:R6, b:R6, limm:limm (212)", "assembly": "asl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "asl.cc.f b:R6, b:R6, c:R6 (211)", "assembly": "asl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "asl.f a:R6, b:R6, u6:uimm6 (205)", "assembly": "asl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "asl.f b:R6, b:R6, s12:simm12 (209)", "assembly": "asl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "asl.f a:R6, b:R6, limm:limm (199)", "assembly": "asl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "asl.f a:R6, limm:limm, c:R6 (198)", "assembly": "asl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "asl.f a:R6, b:R6, c:R6 (197)", "assembly": "asl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "asl %0,%1,%2",
+;       "asl_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ],
+;     "failed_for_operands": [
+;         { "_comment": "asl.f b:R6, c:R6 (190)" },
+;         { "_comment": "asl.f b:R6, limm:limm (191)" },
+;         { "_comment": "asl.f 0:0, c:R6 (192)" },
+;         { "_comment": "asl.f 0:0, limm:limm (193)" },
+;         { "_comment": "asl.f b:R6, u6:uimm6 (194)" },
+;         { "_comment": "asl.f 0:0, u6:uimm6 (195)" },
+;         { "_comment": "asl_s b:R3, c:R3 (196)" }
+;     ]
+;     }
+;   }
+; OUTPUT:ashlsi3
+(define_insn "ashlsi3" [
+    (set
+      (match_operand:SI 0 "register_operand" "=q,q,q,r,r,r,r,r,r,r,r")
+      (ashift:SI
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,0,0,0,r,0,r,ULIMM,r")
+        (match_operand:SI 2 "nonmemory_operand" "U03S0,U05S0,q,U06S0,ULIMM,r,U06S0,S12S0,ULIMM,r,r")))]
+ "true" "@
+  asl_s %0,%1,%2
+  asl_s %0,%1,%2
+  asl_s %0,%1,%2
+  asl %0,%1,%2
+  asl %0,%1,%2
+  asl %0,%1,%2
+  asl %0,%1,%2
+  asl %0,%1,%2
+  asl %0,%1,%2
+  asl %0,%1,%2
+  asl %0,%1,%2" [
+    (set_attr "predicable" "no,no,no,yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "2,2,2,4,8,4,4,4,8,8,4")
+    (set_attr "type" "asl,asl,asl,asl,asl,asl,asl,asl,asl,asl,asl")]
+)
+; END:ashlsi3
+
+
+; START:ashldi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (ashift:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "asll"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "asll.cc.f RB:rb, RB:rb, RC:rc (5658)", "assembly": "asll %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "asll.cc.f RB:rb, RB:rb, limm:limm (5668)", "assembly": "asll %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "asll.cc.f RB:rb, RB:rb, u6:uimm6 (5661)", "assembly": "asll %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "asll.cc.f RB:rb, RB:rb, ximm:ximm (5681)", "assembly": "asll %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "asll.f RA:ra, RB:rb, u6:uimm6 (5659)", "assembly": "asll %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "asll.f RB:rb, RB:rb, s12:simm12 (5662)", "assembly": "asll %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "asll.f RA:ra, RB:rb, limm:limm (5664)", "assembly": "asll %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "asll.f RA:ra, RB:rb, ximm:ximm (5677)", "assembly": "asll %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "asll.f RA:ra, limm:limm, RC:rc (5663)", "assembly": "asll %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "asll.f RA:ra, ximm:ximm, RC:rc (5676)", "assembly": "asll %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "asll.f RA:ra, RB:rb, RC:rc (5656)", "assembly": "asll %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "asll %0,%1,%2",
+;       "asll_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ],
+;     "failed_for_operands": [
+;         { "_comment": "asll.f RB:rb, RC:rc (6250)" },
+;         { "_comment": "asll.f 0:0, RC:rc (6251)" },
+;         { "_comment": "asll.f RB:rb, u6:uimm6 (6252)" },
+;         { "_comment": "asll.f 0:0, u6:uimm6 (6253)" },
+;         { "_comment": "asll.f RB:rb, limm:limm (6254)" },
+;         { "_comment": "asll.f 0:0, limm:limm (6255)" },
+;         { "_comment": "asll.f RB:rb, ximm:ximm (6256)" },
+;         { "_comment": "asll.f 0:0, ximm:ximm (6257)" }
+;     ]
+;     }
+;   }
+; OUTPUT:ashldi3
+(define_insn "ashldi3" [
+    (set
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r")
+      (ashift:DI
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r")
+        (match_operand:DI 2 "nonmemory_operand" "r,ULIMM,U06S0,UXIMM,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  asll %0,%1,%2
+  asll %0,%1,%2
+  asll %0,%1,%2
+  asll %0,%1,%2
+  asll %0,%1,%2
+  asll %0,%1,%2
+  asll %0,%1,%2
+  asll %0,%1,%2
+  asll %0,%1,%2
+  asll %0,%1,%2
+  asll %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "asll,asll,asll,asll,asll,asll,asll,asll,asll,asll,asll")]
+)
+; END:ashldi3
+
+
+; START:ashlsi2_cnt1
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (ashift:SI @op1{mode=SI} (const_int 1)))]",
+;   "general_attributes":   {
+;     "type": "asl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "",
+;   "ordered_constraints": [
+;       { "_comment": "asl_s b:R3, c:R3 (196)", "assembly": "asl_s %0,%1", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q" } },
+;       { "_comment": "asl.f b:R6, u6:uimm6 (194)", "assembly": "asl %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "asl.f b:R6, limm:limm (191)", "assembly": "asl %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "asl.f b:R6, c:R6 (190)", "assembly": "asl %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "asl %0,%1",
+;       "asl_s %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ],
+;     "failed_for_operands": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:ashlsi2_cnt1
+(define_insn "ashlsi2_cnt1" [
+    (set
+      (match_operand:SI 0 "register_operand" "=q,r,r,r")
+      (ashift:SI
+        (match_operand:SI 1 "nonmemory_operand" "q,U06S0,ULIMM,r")
+        (const_int 1)))]
+ "true" "@
+  asl_s %0,%1
+  asl %0,%1
+  asl %0,%1
+  asl %0,%1" [
+    (set_attr "predicable" "no,no,no,no")
+    (set_attr "length" "2,4,8,4")
+    (set_attr "type" "asl,asl,asl,asl")]
+)
+; END:ashlsi2_cnt1
+
+; START:ashlsi2_cnt8
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (ashift:SI @op1{mode=SI} (const_int 8)))]",
+;   "general_attributes":   {
+;     "type": "asl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "",
+;   "ordered_constraints": [
+;       { "_comment": "lsl8.f b:R6, u6:uimm6 (1762)", "assembly": "lsl8 %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "lsl8.f b:R6, c:R6 (1758)", "assembly": "lsl8 %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } },
+;       { "_comment": "lsl8.f b:R6, limm:limm (1759)", "assembly": "lsl8 %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "lsl8_s %0,%1",
+;       "lsl8 %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:ashlsi2_cnt8
+(define_insn "ashlsi2_cnt8" [
+    (set
+      (match_operand:SI 0 "register_operand" "=r,r,r")
+      (ashift:SI
+        (match_operand:SI 1 "nonmemory_operand" "U06S0,r,ULIMM")
+        (const_int 8)))]
+ "true" "@
+  lsl8 %0,%1
+  lsl8 %0,%1
+  lsl8 %0,%1" [
+    (set_attr "predicable" "no,no,no")
+    (set_attr "length" "4,4,8")
+    (set_attr "type" "asl,asl,asl")]
+)
+; END:ashlsi2_cnt8
+
+; START:ashlsi2_cnt16
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (ashift:SI @op1{mode=SI} (const_int 16)))]",
+;   "general_attributes":   {
+;     "type": "asl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "",
+;   "ordered_constraints": [
+;       { "_comment": "lsl16.f b:R6, u6:uimm6 (1756)", "assembly": "lsl16 %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "lsl16.f b:R6, limm:limm (1753)", "assembly": "lsl16 %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "lsl16.f b:R6, c:R6 (1752)", "assembly": "lsl16 %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "lsl16_s %0,%1",
+;       "lsl16 %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:ashlsi2_cnt16
+(define_insn "ashlsi2_cnt16" [
+    (set
+      (match_operand:SI 0 "register_operand" "=r,r,r")
+      (ashift:SI
+        (match_operand:SI 1 "nonmemory_operand" "U06S0,ULIMM,r")
+        (const_int 16)))]
+ "true" "@
+  lsl16 %0,%1
+  lsl16 %0,%1
+  lsl16 %0,%1" [
+    (set_attr "predicable" "no,no,no")
+    (set_attr "length" "4,8,4")
+    (set_attr "type" "asl,asl,asl")]
+)
+; END:ashlsi2_cnt16
+
+; START:ashrsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (ashiftrt:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "asr"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "asr_s c:R3, b:R3, u3:uimm3 (271)", "assembly": "asr_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q", "op2": "U03S0" } },
+;       { "_comment": "asr_s b:R3, b:R3, u5:uimm5 (273)", "assembly": "asr_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "U05S0" } },
+;       { "_comment": "asr_s b:R3, b:R3, c:R3 (272)", "assembly": "asr_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "q" } },
+;       { "_comment": "asr.cc.f b:R6, b:R6, c:R6 (265)", "assembly": "asr %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "asr.cc.f b:R6, b:R6, limm:limm (266)", "assembly": "asr %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "asr.cc.f b:R6, b:R6, u6:uimm6 (269)", "assembly": "asr %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "asr.f a:R6, b:R6, u6:uimm6 (259)", "assembly": "asr %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "asr.f b:R6, b:R6, s12:simm12 (263)", "assembly": "asr %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "asr.f a:R6, b:R6, limm:limm (253)", "assembly": "asr %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "asr.f a:R6, limm:limm, c:R6 (252)", "assembly": "asr %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "asr.f a:R6, b:R6, c:R6 (251)", "assembly": "asr %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "asr_s %0,%1,%2",
+;       "asr %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ],
+;     "failed_for_operands": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:ashrsi3
+(define_insn "ashrsi3" [
+    (set
+      (match_operand:SI 0 "register_operand" "=q,q,q,r,r,r,r,r,r,r,r")
+      (ashiftrt:SI
+        (match_operand:SI 1 "nonmemory_operand" "q,0,0,0,0,0,r,0,r,ULIMM,r")
+        (match_operand:SI 2 "nonmemory_operand" "U03S0,U05S0,q,r,ULIMM,U06S0,U06S0,S12S0,ULIMM,r,r")))]
+ "true" "@
+  asr_s %0,%1,%2
+  asr_s %0,%1,%2
+  asr_s %0,%1,%2
+  asr %0,%1,%2
+  asr %0,%1,%2
+  asr %0,%1,%2
+  asr %0,%1,%2
+  asr %0,%1,%2
+  asr %0,%1,%2
+  asr %0,%1,%2
+  asr %0,%1,%2" [
+    (set_attr "predicable" "no,no,no,yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "2,2,2,4,8,4,4,4,8,8,4")
+    (set_attr "type" "asr,asr,asr,asr,asr,asr,asr,asr,asr,asr,asr")]
+)
+; END:ashrsi3
+
+; START:ashrsi2_cnt1
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (ashiftrt:SI @op1{mode=SI} (const_int 1)))]",
+;   "general_attributes":   {
+;     "type": "asr"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "",
+;   "ordered_constraints": [
+;       { "_comment": "asr_s b:R3, c:R3 (250)", "assembly": "asr_s %0,%1", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q" } },
+;       { "_comment": "asr.f b:R6, u6:uimm6 (248)", "assembly": "asr %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "asr.f b:R6, limm:limm (245)", "assembly": "asr %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "asr.f b:R6, c:R6 (244)", "assembly": "asr %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "asr_s %0,%1",
+;       "asr %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ],
+;     "failed_for_operands": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:ashrsi2_cnt1
+(define_insn "ashrsi2_cnt1" [
+    (set
+      (match_operand:SI 0 "register_operand" "=q,r,r,r")
+      (ashiftrt:SI
+        (match_operand:SI 1 "nonmemory_operand" "q,U06S0,ULIMM,r")
+        (const_int 1)))]
+ "true" "@
+  asr_s %0,%1
+  asr %0,%1
+  asr %0,%1
+  asr %0,%1" [
+    (set_attr "predicable" "no,no,no,no")
+    (set_attr "length" "2,4,8,4")
+    (set_attr "type" "asr,asr,asr,asr")]
+)
+; END:ashrsi2_cnt1
+
+; START:ashrsi2_cnt8
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (ashiftrt:SI @op1{mode=SI} (const_int 8)))]",
+;   "general_attributes":   {
+;     "type": "asr"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "",
+;   "ordered_constraints": [
+;       { "_comment": "asr8.f b:R6, u6:uimm6 (281)", "assembly": "asr8 %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "asr8.f b:R6, limm:limm (282)", "assembly": "asr8 %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "asr8.f b:R6, c:R6 (280)", "assembly": "asr8 %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "asr8_s %0,%1",
+;       "asr8 %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:ashrsi2_cnt8
+(define_insn "ashrsi2_cnt8" [
+    (set
+      (match_operand:SI 0 "register_operand" "=r,r,r")
+      (ashiftrt:SI
+        (match_operand:SI 1 "nonmemory_operand" "U06S0,ULIMM,r")
+        (const_int 8)))]
+ "true" "@
+  asr8 %0,%1
+  asr8 %0,%1
+  asr8 %0,%1" [
+    (set_attr "predicable" "no,no,no")
+    (set_attr "length" "4,8,4")
+    (set_attr "type" "asr,asr,asr")]
+)
+; END:ashrsi2_cnt8
+
+; START:ashrsi2_cnt16
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (ashiftrt:SI @op1{mode=SI} (const_int 16)))]",
+;   "general_attributes":   {
+;     "type": "asr"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "",
+;   "ordered_constraints": [
+;       { "_comment": "asr16.f b:R6, c:R6 (274)", "assembly": "asr16 %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } },
+;       { "_comment": "asr16.f b:R6, limm:limm (276)", "assembly": "asr16 %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "asr16.f b:R6, u6:uimm6 (275)", "assembly": "asr16 %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "asr16_s %0,%1",
+;       "asr16 %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:ashrsi2_cnt16
+(define_insn "ashrsi2_cnt16" [
+    (set
+      (match_operand:SI 0 "register_operand" "=r,r,r")
+      (ashiftrt:SI
+        (match_operand:SI 1 "nonmemory_operand" "r,ULIMM,U06S0")
+        (const_int 16)))]
+ "true" "@
+  asr16 %0,%1
+  asr16 %0,%1
+  asr16 %0,%1" [
+    (set_attr "predicable" "no,no,no")
+    (set_attr "length" "4,8,4")
+    (set_attr "type" "asr,asr,asr")]
+)
+; END:ashrsi2_cnt16
+
+
+; START:ashrdi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (ashiftrt:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "asrl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "asrl.cc.f RB:rb, RB:rb, RC:rc (5724)", "assembly": "asrl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "asrl.cc.f RB:rb, RB:rb, limm:limm (5734)", "assembly": "asrl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "asrl.cc.f RB:rb, RB:rb, u6:uimm6 (5727)", "assembly": "asrl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "asrl.cc.f RB:rb, RB:rb, ximm:ximm (5747)", "assembly": "asrl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "asrl.f RA:ra, RB:rb, u6:uimm6 (5725)", "assembly": "asrl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "asrl.f RB:rb, RB:rb, s12:simm12 (5728)", "assembly": "asrl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "asrl.f RA:ra, RB:rb, RC:rc (5722)", "assembly": "asrl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } },
+;       { "_comment": "asrl.f RA:ra, RB:rb, limm:limm (5730)", "assembly": "asrl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "asrl.f RA:ra, RB:rb, ximm:ximm (5743)", "assembly": "asrl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "asrl.f RA:ra, limm:limm, RC:rc (5729)", "assembly": "asrl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "asrl.f RA:ra, ximm:ximm, RC:rc (5742)", "assembly": "asrl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "asrl_s %0,%1,%2",
+;       "asrl %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ],
+;     "failed_for_operands": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:ashrdi3
+(define_insn "ashrdi3" [
+    (set
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r")
+      (ashiftrt:DI
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,r,ULIMM,UXIMM")
+        (match_operand:DI 2 "nonmemory_operand" "r,ULIMM,U06S0,UXIMM,U06S0,S12S0,r,ULIMM,UXIMM,r,r")))]
+ "true" "@
+  asrl %0,%1,%2
+  asrl %0,%1,%2
+  asrl %0,%1,%2
+  asrl %0,%1,%2
+  asrl %0,%1,%2
+  asrl %0,%1,%2
+  asrl %0,%1,%2
+  asrl %0,%1,%2
+  asrl %0,%1,%2
+  asrl %0,%1,%2
+  asrl %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,4,8,4,8,4")
+    (set_attr "type" "asrl,asrl,asrl,asrl,asrl,asrl,asrl,asrl,asrl,asrl,asrl")]
+)
+; END:ashrdi3
+
+; START:ashrdi2_cnt1
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (ashiftrt:DI @op1{mode=DI} (const_int 1)))]",
+;   "general_attributes":   {
+;     "type": "asrl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "asrl.f RB:rb, u6:uimm6 (6260)", "assembly": "asrl %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "asrl.f RB:rb, limm:limm (6262)", "assembly": "asrl %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "asrl.f RB:rb, ximm:ximm (6264)", "assembly": "asrl %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM" } },
+;       { "_comment": "asrl.f RB:rb, RC:rc (6258)", "assembly": "asrl %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "asrl_s %0,%1",
+;       "asrl %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;
+;     }
+;   }
+; OUTPUT:ashrdi2_cnt1
+(define_insn "ashrdi2_cnt1" [
+    (set
+      (match_operand:DI 0 "register_operand" "=r,r,r,r")
+      (ashiftrt:DI
+        (match_operand:DI 1 "nonmemory_operand" "U06S0,ULIMM,UXIMM,r")
+        (const_int 1)))]
+ "true" "@
+  asrl %0,%1
+  asrl %0,%1
+  asrl %0,%1
+  asrl %0,%1" [
+    (set_attr "predicable" "no,no,no,no")
+    (set_attr "length" "4,8,4,4")
+    (set_attr "type" "asrl,asrl,asrl,asrl")]
+)
+; END:ashrdi2_cnt1
+
+; START:lshrsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (lshiftrt:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "lsr"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "lsr_s b:R3, b:R3, c:R3 (1791)", "assembly": "lsr_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "q" } },
+;       { "_comment": "lsr.cc.f b:R6, b:R6, u6:uimm6 (1789)", "assembly": "lsr %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "lsr.cc.f b:R6, b:R6, limm:limm (1786)", "assembly": "lsr %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "lsr.cc.f b:R6, b:R6, c:R6 (1785)", "assembly": "lsr %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "lsr_s b:R3, b:R3, u5:uimm5 (1792)", "assembly": "lsr_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "U05S0" } },
+;       { "_comment": "lsr.f b:R6, b:R6, s12:simm12 (1783)", "assembly": "lsr %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "lsr.f a:R6, b:R6, limm:limm (1773)", "assembly": "lsr %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "lsr.f a:R6, b:R6, u6:uimm6 (1779)", "assembly": "lsr %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "lsr.f a:R6, limm:limm, c:R6 (1772)", "assembly": "lsr %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "lsr.f a:R6, b:R6, c:R6 (1771)", "assembly": "lsr %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "lsr_s %0,%1,%2",
+;       "lsr %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ],
+;     "failed_for_operands": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:lshrsi3
+(define_insn "lshrsi3" [
+    (set
+      (match_operand:SI 0 "register_operand" "=q,r,r,r,q,r,r,r,r,r")
+      (lshiftrt:SI
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,0,0,0,r,r,ULIMM,r")
+        (match_operand:SI 2 "nonmemory_operand" "q,U06S0,ULIMM,r,U05S0,S12S0,ULIMM,U06S0,r,r")))]
+ "true" "@
+  lsr_s %0,%1,%2
+  lsr %0,%1,%2
+  lsr %0,%1,%2
+  lsr %0,%1,%2
+  lsr_s %0,%1,%2
+  lsr %0,%1,%2
+  lsr %0,%1,%2
+  lsr %0,%1,%2
+  lsr %0,%1,%2
+  lsr %0,%1,%2" [
+    (set_attr "predicable" "no,yes,yes,yes,no,no,no,no,no,no")
+    (set_attr "length" "2,4,8,4,2,4,8,4,8,4")
+    (set_attr "type" "lsr,lsr,lsr,lsr,lsr,lsr,lsr,lsr,lsr,lsr")]
+)
+; END:lshrsi3
+
+; START:lshrsi2_cnt1
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (lshiftrt:SI @op1{mode=SI} (const_int 1)))]",
+;   "general_attributes":   {
+;     "type": "lsr"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "ordered_constraints": [
+;       { "_comment": "lsr_s b:R3, c:R3 (1770)", "assembly": "lsr_s %0,%1", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q" } },
+;       { "_comment": "lsr.f b:R6, u6:uimm6 (1768)", "assembly": "lsr %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "lsr.f b:R6, limm:limm (1765)", "assembly": "lsr %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "lsr.f b:R6, c:R6 (1764)", "assembly": "lsr %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "lsr_s %0,%1",
+;       "lsr %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ],
+;     "failed_for_operands": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:lshrsi2_cnt1
+(define_insn "lshrsi2_cnt1" [
+    (set
+      (match_operand:SI 0 "register_operand" "=q,r,r,r")
+      (lshiftrt:SI
+        (match_operand:SI 1 "nonmemory_operand" "q,U06S0,ULIMM,r")
+        (const_int 1)))]
+ "true" "@
+  lsr_s %0,%1
+  lsr %0,%1
+  lsr %0,%1
+  lsr %0,%1" [
+    (set_attr "predicable" "no,no,no,no")
+    (set_attr "length" "2,4,8,4")
+    (set_attr "type" "lsr,lsr,lsr,lsr")]
+)
+; END:lshrsi2_cnt1
+
+; START:lshrsi2_cnt8
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (lshiftrt:SI @op1{mode=SI} (const_int 8)))]",
+;   "general_attributes":   {
+;     "type": "lsr"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "ordered_constraints": [
+;       { "_comment": "lsr8.f b:R6, u6:uimm6 (1803)", "assembly": "lsr8 %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "lsr8.f b:R6, limm:limm (1800)", "assembly": "lsr8 %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "lsr8.f b:R6, c:R6 (1799)", "assembly": "lsr8 %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "lsr8_s %0,%1",
+;       "lsr8 %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ],
+;     "failed_for_operands": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:lshrsi2_cnt8
+(define_insn "lshrsi2_cnt8" [
+    (set
+      (match_operand:SI 0 "register_operand" "=r,r,r")
+      (lshiftrt:SI
+        (match_operand:SI 1 "nonmemory_operand" "U06S0,ULIMM,r")
+        (const_int 8)))]
+ "true" "@
+  lsr8 %0,%1
+  lsr8 %0,%1
+  lsr8 %0,%1" [
+    (set_attr "predicable" "no,no,no")
+    (set_attr "length" "4,8,4")
+    (set_attr "type" "lsr,lsr,lsr")]
+)
+; END:lshrsi2_cnt8
+
+; START:lshrsi2_cnt16
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (lshiftrt:SI @op1{mode=SI} (const_int 16)))]",
+;   "general_attributes":   {
+;     "type": "lsr"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "ordered_constraints": [
+;       { "_comment": "lsr16.f b:R6, u6:uimm6 (1797)", "assembly": "lsr16 %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "lsr16.f b:R6, limm:limm (1794)", "assembly": "lsr16 %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "lsr16.f b:R6, c:R6 (1793)", "assembly": "lsr16 %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "lsr16_s %0,%1",
+;       "lsr16 %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ],
+;     "failed_for_operands": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:lshrsi2_cnt16
+(define_insn "lshrsi2_cnt16" [
+    (set
+      (match_operand:SI 0 "register_operand" "=r,r,r")
+      (lshiftrt:SI
+        (match_operand:SI 1 "nonmemory_operand" "U06S0,ULIMM,r")
+        (const_int 16)))]
+ "true" "@
+  lsr16 %0,%1
+  lsr16 %0,%1
+  lsr16 %0,%1" [
+    (set_attr "predicable" "no,no,no")
+    (set_attr "length" "4,8,4")
+    (set_attr "type" "lsr,lsr,lsr")]
+)
+; END:lshrsi2_cnt16
+
+; START:lshrdi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (lshiftrt:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "lsrl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "lsrl.cc.f RB:rb, RB:rb, RC:rc (5691)", "assembly": "lsrl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "lsrl.cc.f RB:rb, RB:rb, limm:limm (5701)", "assembly": "lsrl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "lsrl.cc.f RB:rb, RB:rb, u6:uimm6 (5694)", "assembly": "lsrl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "lsrl.cc.f RB:rb, RB:rb, ximm:ximm (5714)", "assembly": "lsrl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "lsrl.f RA:ra, RB:rb, u6:uimm6 (5692)", "assembly": "lsrl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "lsrl.f RB:rb, RB:rb, s12:simm12 (5695)", "assembly": "lsrl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "lsrl.f RA:ra, RB:rb, limm:limm (5697)", "assembly": "lsrl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "lsrl.f RA:ra, RB:rb, ximm:ximm (5710)", "assembly": "lsrl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "lsrl.f RA:ra, limm:limm, RC:rc (5696)", "assembly": "lsrl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "lsrl.f RA:ra, ximm:ximm, RC:rc (5709)", "assembly": "lsrl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "lsrl.f RA:ra, RB:rb, RC:rc (5689)", "assembly": "lsrl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "lsrl_s %0,%1,%2",
+;       "lsrl %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:lshrdi3
+(define_insn "lshrdi3" [
+    (set
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r")
+      (lshiftrt:DI
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r")
+        (match_operand:DI 2 "nonmemory_operand" "r,ULIMM,U06S0,UXIMM,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  lsrl %0,%1,%2
+  lsrl %0,%1,%2
+  lsrl %0,%1,%2
+  lsrl %0,%1,%2
+  lsrl %0,%1,%2
+  lsrl %0,%1,%2
+  lsrl %0,%1,%2
+  lsrl %0,%1,%2
+  lsrl %0,%1,%2
+  lsrl %0,%1,%2
+  lsrl %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "lsrl,lsrl,lsrl,lsrl,lsrl,lsrl,lsrl,lsrl,lsrl,lsrl,lsrl")]
+)
+; END:lshrdi3
+
+; START:one_cmplsi2
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (not:SI @op1{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "not"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "ordered_constraints": [
+;       { "_comment": "not_s b:R3, c:R3 (2534)", "assembly": "not_s %0,%1", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0" } },
+;       { "_comment": "not.f b:R6, u6:uimm6 (2532)", "assembly": "not %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "not.f b:R6, limm:limm (2529)", "assembly": "not %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "not.f b:R6, c:R6 (2528)", "assembly": "not %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "not_s %0,%1",
+;       "not %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:one_cmplsi2
+(define_insn "one_cmplsi2" [
+    (set
+      (match_operand:SI 0 "register_operand" "=q,r,r,r")
+      (not:SI
+        (match_operand:SI 1 "nonmemory_operand" "0,U06S0,ULIMM,r")))]
+ "true" "@
+  not_s %0,%1
+  not %0,%1
+  not %0,%1
+  not %0,%1" [
+    (set_attr "predicable" "no,no,no,no")
+    (set_attr "length" "2,4,8,4")
+    (set_attr "type" "not,not,not,not")]
+)
+; END:one_cmplsi2
+
+
+; START:one_cmpldi2
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (not:DI @op1{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "notl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "ordered_constraints": [
+;       { "_comment": "notl.f RB:rb, u6:uimm6 (6308)", "assembly": "notl %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "notl.f RB:rb, limm:limm (6310)", "assembly": "notl %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "notl.f RB:rb, ximm:ximm (6312)", "assembly": "notl %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM" } },
+;       { "_comment": "notl.f RB:rb, RC:rc (6306)", "assembly": "notl %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "notl_s %0,%1",
+;       "notl %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:one_cmpldi2
+(define_insn "one_cmpldi2" [
+    (set
+      (match_operand:DI 0 "register_operand" "=r,r,r,r")
+      (not:DI
+        (match_operand:DI 1 "nonmemory_operand" "U06S0,ULIMM,UXIMM,r")))]
+ "true" "@
+  notl %0,%1
+  notl %0,%1
+  notl %0,%1
+  notl %0,%1" [
+    (set_attr "predicable" "no,no,no,no")
+    (set_attr "length" "4,8,4,4")
+    (set_attr "type" "notl,notl,notl,notl")]
+)
+; END:one_cmpldi2
+
+; START:rotrsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (rotatert:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "ror"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "ordered_constraints": [
+;       { "_comment": "ror.cc.f b:R6, b:R6, u6:uimm6 (2956)", "assembly": "ror %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "ror.cc.f b:R6, b:R6, limm:limm (2953)", "assembly": "ror %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "ror.cc.f b:R6, b:R6, c:R6 (2952)", "assembly": "ror %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "ror.f a:R6, b:R6, u6:uimm6 (2946)", "assembly": "ror %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "ror.f b:R6, b:R6, s12:simm12 (2950)", "assembly": "ror %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "ror.f a:R6, b:R6, limm:limm (2940)", "assembly": "ror %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "ror.f a:R6, limm:limm, c:R6 (2939)", "assembly": "ror %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "ror.f a:R6, b:R6, c:R6 (2938)", "assembly": "ror %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "ror_s %0,%1,%2",
+;       "ror %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ],
+;     "failed_for_operands": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:rotrsi3
+(define_insn "rotrsi3" [
+    (set
+      (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,r")
+      (rotatert:SI
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,r,0,r,ULIMM,r")
+        (match_operand:SI 2 "nonmemory_operand" "U06S0,ULIMM,r,U06S0,S12S0,ULIMM,r,r")))]
+ "true" "@
+  ror %0,%1,%2
+  ror %0,%1,%2
+  ror %0,%1,%2
+  ror %0,%1,%2
+  ror %0,%1,%2
+  ror %0,%1,%2
+  ror %0,%1,%2
+  ror %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,8,8,4")
+    (set_attr "type" "ror,ror,ror,ror,ror,ror,ror,ror")]
+)
+; END:rotrsi3
+
+; START:rotrsi2_cnt1
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (rotatert:SI @op1{mode=SI} (const_int 1)))]",
+;   "general_attributes":   {
+;     "type": "ror"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "ordered_constraints": [
+;       { "_comment": "ror.f b:R6, u6:uimm6 (2936)", "assembly": "ror %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "ror.f b:R6, limm:limm (2933)", "assembly": "ror %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "ror.f b:R6, c:R6 (2932)", "assembly": "ror %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "ror_s %0,%1",
+;       "ror %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ],
+;     "failed_for_operands": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:rotrsi2_cnt1
+(define_insn "rotrsi2_cnt1" [
+    (set
+      (match_operand:SI 0 "register_operand" "=r,r,r")
+      (rotatert:SI
+        (match_operand:SI 1 "nonmemory_operand" "U06S0,ULIMM,r")
+        (const_int 1)))]
+ "true" "@
+  ror %0,%1
+  ror %0,%1
+  ror %0,%1" [
+    (set_attr "predicable" "no,no,no")
+    (set_attr "length" "4,8,4")
+    (set_attr "type" "ror,ror,ror")]
+)
+; END:rotrsi2_cnt1
+
+; START:rotrsi2_cnt8
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (rotatert:SI @op1{mode=SI} (const_int 8)))]",
+;   "general_attributes":   {
+;     "type": "ror"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "ordered_constraints": [
+;       { "_comment": "ror8.f b:R6, u6:uimm6 (2962)", "assembly": "ror8 %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "ror8.f b:R6, limm:limm (2959)", "assembly": "ror8 %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "ror8.f b:R6, c:R6 (2958)", "assembly": "ror8 %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "ror8_s %0,%1",
+;       "ror8 %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ],
+;     "failed_for_operands": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:rotrsi2_cnt8
+(define_insn "rotrsi2_cnt8" [
+    (set
+      (match_operand:SI 0 "register_operand" "=r,r,r")
+      (rotatert:SI
+        (match_operand:SI 1 "nonmemory_operand" "U06S0,ULIMM,r")
+        (const_int 8)))]
+ "true" "@
+  ror8 %0,%1
+  ror8 %0,%1
+  ror8 %0,%1" [
+    (set_attr "predicable" "no,no,no")
+    (set_attr "length" "4,8,4")
+    (set_attr "type" "ror,ror,ror")]
+)
+; END:rotrsi2_cnt8
+
+; START:clrsbsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (clrsb:SI @op1{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "norm"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "ordered_constraints": [
+;       { "_comment": "norm.f b:R6, u6:uimm6 (2514)", "assembly": "norm %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "norm.f b:R6, limm:limm (2511)", "assembly": "norm %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "norm.f b:R6, c:R6 (2510)", "assembly": "norm %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "norm_s %0,%1",
+;       "norm %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:clrsbsi3
+(define_insn "clrsbsi3" [
+    (set
+      (match_operand:SI 0 "register_operand" "=r,r,r")
+      (clrsb:SI
+        (match_operand:SI 1 "nonmemory_operand" "U06S0,ULIMM,r")))]
+ "true" "@
+  norm %0,%1
+  norm %0,%1
+  norm %0,%1" [
+    (set_attr "predicable" "no,no,no")
+    (set_attr "length" "4,8,4")
+    (set_attr "type" "norm,norm,norm")]
+)
+; END:clrsbsi3
+
+; START:clrsbdi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (clrsb:DI @op1{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "norml"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "ordered_constraints": [
+;       { "_comment": "norml.f RB:rb, u6:uimm6 (6364)", "assembly": "norml %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "norml.f RB:rb, limm:limm (6366)", "assembly": "norml %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "norml.f RB:rb, ximm:ximm (6368)", "assembly": "norml %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM" } },
+;       { "_comment": "norml.f RB:rb, RC:rc (6362)", "assembly": "norml %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "norml_s %0,%1",
+;       "norml %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:clrsbdi3
+(define_insn "clrsbdi3" [
+    (set
+      (match_operand:DI 0 "register_operand" "=r,r,r,r")
+      (clrsb:DI
+        (match_operand:DI 1 "nonmemory_operand" "U06S0,ULIMM,UXIMM,r")))]
+ "true" "@
+  norml %0,%1
+  norml %0,%1
+  norml %0,%1
+  norml %0,%1" [
+    (set_attr "predicable" "no,no,no,no")
+    (set_attr "length" "4,8,4,4")
+    (set_attr "type" "norml,norml,norml,norml")]
+)
+; END:clrsbdi3
+
+; START:clrsbhi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=HI} (clrsb:HI @op1{mode=HI}))]",
+;   "general_attributes":   {
+;     "type": "normh"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "ordered_constraints": [
+;       { "_comment": "normh.f b:R6, u6:uimm6 (2526)", "assembly": "normh %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "normh.f b:R6, limm:limm (2523)", "assembly": "normh %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "normh.f b:R6, c:R6 (2522)", "assembly": "normh %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "normh_s %0,%1",
+;       "normh %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:clrsbhi3
+(define_insn "clrsbhi3" [
+    (set
+      (match_operand:HI 0 "register_operand" "=r,r,r")
+      (clrsb:HI
+        (match_operand:HI 1 "nonmemory_operand" "U06S0,ULIMM,r")))]
+ "true" "@
+  normh %0,%1
+  normh %0,%1
+  normh %0,%1" [
+    (set_attr "predicable" "no,no,no")
+    (set_attr "length" "4,8,4")
+    (set_attr "type" "normh,normh,normh")]
+)
+; END:clrsbhi3
+
+
+
+; START:orsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (ior:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "or"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "or_s b:R3, b:R3, c:R3 (2555)", "assembly": "or_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "q" } },
+;       { "_comment": "or.cc.f b:R6, b:R6, c:R6 (2549)", "assembly": "or %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "or.cc.f b:R6, b:R6, limm:limm (2550)", "assembly": "or %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "or.cc.f b:R6, b:R6, u6:uimm6 (2553)", "assembly": "or %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "or.f a:R6, b:R6, u6:uimm6 (2543)", "assembly": "or %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "or.f b:R6, b:R6, s12:simm12 (2547)", "assembly": "or %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "or.f a:R6, b:R6, limm:limm (2537)", "assembly": "or %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "or.f a:R6, limm:limm, c:R6 (2536)", "assembly": "or %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "or.f a:R6, b:R6, c:R6 (2535)", "assembly": "or %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "or_s %0,%1,%2",
+;       "or %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:orsi3
+(define_insn "orsi3" [
+    (set
+      (match_operand:SI 0 "register_operand" "=q,r,r,r,r,r,r,r,r")
+      (ior:SI
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,0,r,0,r,ULIMM,r")
+        (match_operand:SI 2 "nonmemory_operand" "q,r,ULIMM,U06S0,U06S0,S12S0,ULIMM,r,r")))]
+ "true" "@
+  or_s %0,%1,%2
+  or %0,%1,%2
+  or %0,%1,%2
+  or %0,%1,%2
+  or %0,%1,%2
+  or %0,%1,%2
+  or %0,%1,%2
+  or %0,%1,%2
+  or %0,%1,%2" [
+    (set_attr "predicable" "no,yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "2,4,8,4,4,4,8,8,4")
+    (set_attr "type" "or,or,or,or,or,or,or,or,or")]
+)
+; END:orsi3
+
+; START:ordi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (ior:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "orl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "orl_s b:R3, b:R3, c:R3 (6588)", "assembly": "orl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "q" } },
+;       { "_comment": "orl.cc.f RB:rb, RB:rb, RC:rc (5130)", "assembly": "orl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "orl.cc.f RB:rb, RB:rb, limm:limm (5140)", "assembly": "orl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "orl.cc.f RB:rb, RB:rb, u6:uimm6 (5133)", "assembly": "orl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "orl.cc.f RB:rb, RB:rb, ximm:ximm (5153)", "assembly": "orl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "orl.f RA:ra, RB:rb, u6:uimm6 (5131)", "assembly": "orl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "orl.f RB:rb, RB:rb, s12:simm12 (5134)", "assembly": "orl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "orl.f RA:ra, RB:rb, RC:rc (5128)", "assembly": "orl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } },
+;       { "_comment": "orl.f RA:ra, RB:rb, limm:limm (5136)", "assembly": "orl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "orl.f RA:ra, RB:rb, ximm:ximm (5149)", "assembly": "orl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "orl.f RA:ra, limm:limm, RC:rc (5135)", "assembly": "orl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "orl.f RA:ra, ximm:ximm, RC:rc (5148)", "assembly": "orl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "orl_s %0,%1,%2",
+;       "orl %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "not included": [
+;         { "_comment": "orl_s h:h, PCL:pcl, ximm:ximm (6591)", "assembly": "orl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "TODO:h", "op1": "FIPCL", "op2": "UXIMM" } },
+;         { "_comment": "orl_s h:h, h:h, ximm:ximm (6590)", "assembly": "orl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "TODO:h", "op1": "TODO:h", "op2": "UXIMM" } }
+;     ],
+;     "found_matches": [
+;
+;     ],
+;     "failed_for_operands": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:ordi3
+(define_insn "ordi3" [
+    (set
+      (match_operand:DI 0 "register_operand" "=q,r,r,r,r,r,r,r,r,r,r,r")
+      (ior:DI
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,0,r,0,r,r,r,ULIMM,UXIMM")
+        (match_operand:DI 2 "nonmemory_operand" "q,r,ULIMM,U06S0,UXIMM,U06S0,S12S0,r,ULIMM,UXIMM,r,r")))]
+ "true" "@
+  orl_s %0,%1,%2
+  orl %0,%1,%2
+  orl %0,%1,%2
+  orl %0,%1,%2
+  orl %0,%1,%2
+  orl %0,%1,%2
+  orl %0,%1,%2
+  orl %0,%1,%2
+  orl %0,%1,%2
+  orl %0,%1,%2
+  orl %0,%1,%2
+  orl %0,%1,%2" [
+    (set_attr "predicable" "no,yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "2,4,8,4,4,4,4,4,8,4,8,4")
+    (set_attr "type" "orl,orl,orl,orl,orl,orl,orl,orl,orl,orl,orl,orl")]
+)
+; END:ordi3
+
+; START:bswapsi2
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (bswap:SI @op1{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "swape"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "ordered_constraints": [
+;       { "_comment": "swape.f b:R6, u6:uimm6 (3372)", "assembly": "swape %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "swape.f b:R6, limm:limm (3371)", "assembly": "swape %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "swape.f b:R6, c:R6 (3370)", "assembly": "swape %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "swape_s %0,%1",
+;       "swape %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:bswapsi2
+(define_insn "bswapsi2" [
+    (set
+      (match_operand:SI 0 "register_operand" "=r,r,r")
+      (bswap:SI
+        (match_operand:SI 1 "nonmemory_operand" "U06S0,ULIMM,r")))]
+ "true" "@
+  swape %0,%1
+  swape %0,%1
+  swape %0,%1" [
+    (set_attr "predicable" "no,no,no")
+    (set_attr "length" "4,8,4")
+    (set_attr "type" "swape,swape,swape")]
+)
+; END:bswapsi2
+
+; START:bswapdi2
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (bswap:DI @op1{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "swapel"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "ordered_constraints": [
+;       { "_comment": "swapel.f RB:rb, u6:uimm6 (6372)", "assembly": "swapel %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "swapel.f RB:rb, limm:limm (6374)", "assembly": "swapel %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "swapel.f RB:rb, ximm:ximm (6376)", "assembly": "swapel %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM" } },
+;       { "_comment": "swapel.f RB:rb, RC:rc (6370)", "assembly": "swapel %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "swapel_s %0,%1",
+;       "swapel %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:bswapdi2
+(define_insn "bswapdi2" [
+    (set
+      (match_operand:DI 0 "register_operand" "=r,r,r,r")
+      (bswap:DI
+        (match_operand:DI 1 "nonmemory_operand" "U06S0,ULIMM,UXIMM,r")))]
+ "true" "@
+  swapel %0,%1
+  swapel %0,%1
+  swapel %0,%1
+  swapel %0,%1" [
+    (set_attr "predicable" "no,no,no,no")
+    (set_attr "length" "4,8,4,4")
+    (set_attr "type" "swapel,swapel,swapel,swapel")]
+)
+; END:bswapdi2
+
+; START:bsetsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (ior:SI @op1{mode=SI} (ashift:SI (const_int 1) @op2{mode=SI})))]",
+;   "general_attributes":   {
+;     "type": "bset"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "bset_s b:R3, b:R3, u5:uimm5 (501)", "assembly": "bset_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "U05S0" } },
+;       { "_comment": "bset.cc.f b:R6, b:R6, c:R6 (495)", "assembly": "bset %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "bset.cc.f b:R6, b:R6, limm:limm (496)", "assembly": "bset %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "bset.cc.f b:R6, b:R6, u6:uimm6 (499)", "assembly": "bset %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "bset.f a:R6, b:R6, u6:uimm6 (489)", "assembly": "bset %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "bset.f b:R6, b:R6, s12:simm12 (493)", "assembly": "bset %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "bset.f a:R6, b:R6, limm:limm (483)", "assembly": "bset %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "bset.f a:R6, limm:limm, c:R6 (482)", "assembly": "bset %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "bset.f a:R6, b:R6, c:R6 (481)", "assembly": "bset %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "bset_s %0,%1,%2",
+;       "bset %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:bsetsi3
+(define_insn "bsetsi3" [
+    (set
+      (match_operand:SI 0 "register_operand" "=q,r,r,r,r,r,r,r,r")
+      (ior:SI
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,0,r,0,r,ULIMM,r")
+        (ashift:SI
+          (const_int 1)
+          (match_operand:SI 2 "nonmemory_operand" "U05S0,r,ULIMM,U06S0,U06S0,S12S0,ULIMM,r,r"))))]
+ "true" "@
+  bset_s %0,%1,%2
+  bset %0,%1,%2
+  bset %0,%1,%2
+  bset %0,%1,%2
+  bset %0,%1,%2
+  bset %0,%1,%2
+  bset %0,%1,%2
+  bset %0,%1,%2
+  bset %0,%1,%2" [
+    (set_attr "predicable" "no,yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "2,4,8,4,4,4,8,8,4")
+    (set_attr "type" "bset,bset,bset,bset,bset,bset,bset,bset,bset")]
+)
+; END:bsetsi3
+
+; START:bsetdi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (ior:DI @op1{mode=DI} (ashift:DI (const_int 1) @op2{mode=DI})))]",
+;   "general_attributes":   {
+;     "type": "bsetl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "bsetl.cc.f RB:rb, RB:rb, RC:rc (5328)", "assembly": "bsetl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "bsetl.cc.f RB:rb, RB:rb, limm:limm (5338)", "assembly": "bsetl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "bsetl.cc.f RB:rb, RB:rb, u6:uimm6 (5331)", "assembly": "bsetl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "bsetl.cc.f RB:rb, RB:rb, ximm:ximm (5351)", "assembly": "bsetl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "bsetl.f RA:ra, RB:rb, u6:uimm6 (5329)", "assembly": "bsetl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "bsetl.f RB:rb, RB:rb, s12:simm12 (5332)", "assembly": "bsetl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "bsetl.f RA:ra, RB:rb, limm:limm (5334)", "assembly": "bsetl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "bsetl.f RA:ra, RB:rb, ximm:ximm (5347)", "assembly": "bsetl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "bsetl.f RA:ra, limm:limm, RC:rc (5333)", "assembly": "bsetl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "bsetl.f RA:ra, ximm:ximm, RC:rc (5346)", "assembly": "bsetl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "bsetl.f RA:ra, RB:rb, RC:rc (5326)", "assembly": "bsetl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "bsetl_s %0,%1,%2",
+;       "bsetl %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:bsetdi3
+(define_insn "bsetdi3" [
+    (set
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r")
+      (ior:DI
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r")
+        (ashift:DI
+          (const_int 1)
+          (match_operand:DI 2 "nonmemory_operand" "r,ULIMM,U06S0,UXIMM,U06S0,S12S0,ULIMM,UXIMM,r,r,r"))))]
+ "true" "@
+  bsetl %0,%1,%2
+  bsetl %0,%1,%2
+  bsetl %0,%1,%2
+  bsetl %0,%1,%2
+  bsetl %0,%1,%2
+  bsetl %0,%1,%2
+  bsetl %0,%1,%2
+  bsetl %0,%1,%2
+  bsetl %0,%1,%2
+  bsetl %0,%1,%2
+  bsetl %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "bsetl,bsetl,bsetl,bsetl,bsetl,bsetl,bsetl,bsetl,bsetl,bsetl,bsetl")]
+)
+; END:bsetdi3
+
+; START:bxorsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (xor:SI @op1{mode=SI} (ashift:SI (const_int 1) @op2{mode=SI})))]",
+;   "general_attributes":   {
+;     "type": "bxor"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "bxor.cc.f b:R6, b:R6, c:R6 (531)", "assembly": "bxor %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "bxor.cc.f b:R6, b:R6, limm:limm (532)", "assembly": "bxor %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "bxor.cc.f b:R6, b:R6, u6:uimm6 (535)", "assembly": "bxor %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "bxor.f a:R6, b:R6, u6:uimm6 (525)", "assembly": "bxor %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "bxor.f b:R6, b:R6, s12:simm12 (529)", "assembly": "bxor %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "bxor.f a:R6, b:R6, limm:limm (519)", "assembly": "bxor %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "bxor.f a:R6, limm:limm, c:R6 (518)", "assembly": "bxor %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "bxor.f a:R6, b:R6, c:R6 (517)", "assembly": "bxor %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "bxor_s %0,%1,%2",
+;       "bxor %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:bxorsi3
+(define_insn "bxorsi3" [
+    (set
+      (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,r")
+      (xor:SI
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,r,0,r,ULIMM,r")
+        (ashift:SI
+          (const_int 1)
+          (match_operand:SI 2 "nonmemory_operand" "r,ULIMM,U06S0,U06S0,S12S0,ULIMM,r,r"))))]
+ "true" "@
+  bxor %0,%1,%2
+  bxor %0,%1,%2
+  bxor %0,%1,%2
+  bxor %0,%1,%2
+  bxor %0,%1,%2
+  bxor %0,%1,%2
+  bxor %0,%1,%2
+  bxor %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,8,8,4")
+    (set_attr "type" "bxor,bxor,bxor,bxor,bxor,bxor,bxor,bxor")]
+)
+; END:bxorsi3
+
+; START:bxordi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (xor:DI @op1{mode=DI} (ashift:DI (const_int 1) @op2{mode=DI})))]",
+;   "general_attributes":   {
+;     "type": "bxorl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "bxorl.cc.f RB:rb, RB:rb, RC:rc (5394)", "assembly": "bxorl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "bxorl.cc.f RB:rb, RB:rb, limm:limm (5404)", "assembly": "bxorl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "bxorl.cc.f RB:rb, RB:rb, u6:uimm6 (5397)", "assembly": "bxorl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "bxorl.cc.f RB:rb, RB:rb, ximm:ximm (5417)", "assembly": "bxorl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "bxorl.f RA:ra, RB:rb, u6:uimm6 (5395)", "assembly": "bxorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "bxorl.f RB:rb, RB:rb, s12:simm12 (5398)", "assembly": "bxorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "bxorl.f RA:ra, RB:rb, limm:limm (5400)", "assembly": "bxorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "bxorl.f RA:ra, RB:rb, ximm:ximm (5413)", "assembly": "bxorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "bxorl.f RA:ra, limm:limm, RC:rc (5399)", "assembly": "bxorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "bxorl.f RA:ra, ximm:ximm, RC:rc (5412)", "assembly": "bxorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "bxorl.f RA:ra, RB:rb, RC:rc (5392)", "assembly": "bxorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "bxorl_s %0,%1,%2",
+;       "bxorl %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:bxordi3
+(define_insn "bxordi3" [
+    (set
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r")
+      (xor:DI
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r")
+        (ashift:DI
+          (const_int 1)
+          (match_operand:DI 2 "nonmemory_operand" "r,ULIMM,U06S0,UXIMM,U06S0,S12S0,ULIMM,UXIMM,r,r,r"))))]
+ "true" "@
+  bxorl %0,%1,%2
+  bxorl %0,%1,%2
+  bxorl %0,%1,%2
+  bxorl %0,%1,%2
+  bxorl %0,%1,%2
+  bxorl %0,%1,%2
+  bxorl %0,%1,%2
+  bxorl %0,%1,%2
+  bxorl %0,%1,%2
+  bxorl %0,%1,%2
+  bxorl %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "bxorl,bxorl,bxorl,bxorl,bxorl,bxorl,bxorl,bxorl,bxorl,bxorl,bxorl")]
+)
+; END:bxordi3
+
+; START:bmsksi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (and:SI @op1{mode=SI} (plus:SI (ashift:SI (const_int 1) (plus:SI @op2{mode=SI} (const_int 1))) (const_int -1))))]",
+;   "general_attributes":   {
+;     "type": "bmsk"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "bmsk_s b:R3, b:R3, u5:uimm5 (420)", "assembly": "bmsk_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "U05S0" } },
+;       { "_comment": "bmsk.cc.f b:R6, b:R6, c:R6 (414)", "assembly": "bmsk %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "bmsk.cc.f b:R6, b:R6, limm:limm (415)", "assembly": "bmsk %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "bmsk.cc.f b:R6, b:R6, u6:uimm6 (418)", "assembly": "bmsk %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "bmsk.f a:R6, b:R6, u6:uimm6 (408)", "assembly": "bmsk %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "bmsk.f b:R6, b:R6, s12:simm12 (412)", "assembly": "bmsk %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "bmsk.f a:R6, b:R6, limm:limm (402)", "assembly": "bmsk %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "bmsk.f a:R6, limm:limm, c:R6 (401)", "assembly": "bmsk %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "bmsk.f a:R6, b:R6, c:R6 (400)", "assembly": "bmsk %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "bmsk_s %0,%1,%2",
+;       "bmsk %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:bmsksi3
+(define_insn "bmsksi3" [
+    (set
+      (match_operand:SI 0 "register_operand" "=q,r,r,r,r,r,r,r,r")
+      (and:SI
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,0,r,0,r,ULIMM,r")
+        (plus:SI
+          (ashift:SI
+            (const_int 1)
+            (plus:SI
+              (match_operand:SI 2 "nonmemory_operand" "U05S0,r,ULIMM,U06S0,U06S0,S12S0,ULIMM,r,r")
+              (const_int 1)))
+          (const_int -1))))]
+ "true" "@
+  bmsk_s %0,%1,%2
+  bmsk %0,%1,%2
+  bmsk %0,%1,%2
+  bmsk %0,%1,%2
+  bmsk %0,%1,%2
+  bmsk %0,%1,%2
+  bmsk %0,%1,%2
+  bmsk %0,%1,%2
+  bmsk %0,%1,%2" [
+    (set_attr "predicable" "no,yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "2,4,8,4,4,4,8,8,4")
+    (set_attr "type" "bmsk,bmsk,bmsk,bmsk,bmsk,bmsk,bmsk,bmsk,bmsk")]
+)
+; END:bmsksi3
+
+; START:bmskdi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (and:DI @op1{mode=DI} (plus:DI (ashift:DI (const_int 1) (plus:DI @op2{mode=DI} (const_int 1))) (const_int -1))))]",
+;   "general_attributes":   {
+;     "type": "bmsk"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "bmskl.cc.f RB:rb, RB:rb, u6:uimm6 (5430)", "assembly": "bmskl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "bmskl.cc.f RB:rb, RB:rb, limm:limm (5437)", "assembly": "bmskl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "bmskl.cc.f RB:rb, RB:rb, ximm:ximm (5450)", "assembly": "bmskl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "bmskl.cc.f RB:rb, RB:rb, RC:rc (5427)", "assembly": "bmskl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "bmskl.f RA:ra, RB:rb, u6:uimm6 (5428)", "assembly": "bmskl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "bmskl.f RB:rb, RB:rb, s12:simm12 (5431)", "assembly": "bmskl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "bmskl.f RA:ra, RB:rb, limm:limm (5433)", "assembly": "bmskl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "bmskl.f RA:ra, RB:rb, ximm:ximm (5446)", "assembly": "bmskl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "bmskl.f RA:ra, limm:limm, RC:rc (5432)", "assembly": "bmskl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "bmskl.f RA:ra, ximm:ximm, RC:rc (5445)", "assembly": "bmskl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "bmskl.f RA:ra, RB:rb, RC:rc (5425)", "assembly": "bmskl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "bmskl_s %0,%1,%2",
+;       "bmskl %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;
+;     ]
+;     }
+;   }
+; OUTPUT:bmskdi3
+(define_insn "bmskdi3" [
+    (set
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r")
+      (and:DI
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r")
+        (plus:DI
+          (ashift:DI
+            (const_int 1)
+            (plus:DI
+              (match_operand:DI 2 "nonmemory_operand" "U06S0,ULIMM,UXIMM,r,U06S0,S12S0,ULIMM,UXIMM,r,r,r")
+              (const_int 1)))
+          (const_int -1))))]
+ "true" "@
+  bmskl %0,%1,%2
+  bmskl %0,%1,%2
+  bmskl %0,%1,%2
+  bmskl %0,%1,%2
+  bmskl %0,%1,%2
+  bmskl %0,%1,%2
+  bmskl %0,%1,%2
+  bmskl %0,%1,%2
+  bmskl %0,%1,%2
+  bmskl %0,%1,%2
+  bmskl %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "bmsk,bmsk,bmsk,bmsk,bmsk,bmsk,bmsk,bmsk,bmsk,bmsk,bmsk")]
+)
+; END:bmskdi3
diff --git a/gcc/config/arc64/hand_fixed/arith.md b/gcc/config/arc64/hand_fixed/arith.md
new file mode 100644
index 00000000000..ac3c2502332
--- /dev/null
+++ b/gcc/config/arc64/hand_fixed/arith.md
@@ -0,0 +1,1395 @@
+; HEADER FOR THE FILE
+
+
+; TODO: addsi3: add1, add2, add3 were not included.
+; START:addsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (plus:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "add"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "add_s c:R3, b:R3, u3:uimm3 (67)", "assembly": "add_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q", "op2": "U03S0" } },
+;       { "_comment": "add_s b:R3, b:R3, u7:uimm7 (66)", "assembly": "add_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q", "op2": "U07S0" } },
+;       { "_comment": "add_s a:R3, b:R3, c:R3 (60)", "assembly": "add_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q", "op2": "q" } },
+;       { "_comment": "add_s b:R3, b:R3, limm:limm (64)", "assembly": "add_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "6" }, "constraints":   { "op0": "q", "op1": "q", "op2": "ULIMM" } },
+;       { "_comment": "add.cc.f b:R6, b:R6, c:R6 (54)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } },
+;       { "_comment": "add.cc.f b:R6, b:R6, limm:limm (55)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "add.cc.f b:R6, b:R6, u6:uimm6 (58)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "add.f a:R6, b:R6, u6:uimm6 (48)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "add.f b:R6, b:R6, s12:simm12 (52)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "S12S0" } },
+;       { "_comment": "add.f a:R6, b:R6, c:R6 (40)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } },
+;       { "_comment": "add.f a:R6, limm:limm, c:R6 (41)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "add.f a:R6, limm:limm, limm:limm (43)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "ULIMM" } },
+;       { "_comment": "add.f a:R6, limm:limm, u6:uimm6 (49)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "U06S0" } },
+;       { "_comment": "add.f a:R6, b:R6, limm:limm (42)", "assembly": "add %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "add %0,%1,%2",
+;       "add_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "not included": [
+;         { "_comment": "add_s R0:r0, b:R3, u6:uimm6 (70)", "assembly": "add_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "TODO:R0", "op1": "q", "op2": "U06S0" } },
+;         { "_comment": "add_s R1:r1, b:R3, u6:uimm6 (71)", "assembly": "add_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "TODO:R1", "op1": "q", "op2": "U06S0" } },
+;         { "_comment": "add_s b:R3, b:R3, h:h (61)", "assembly": "add_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q", "op2": "TODO:h" } },
+;         { "_comment": "add_s h:h, h:h, s3:simm3 (62)", "assembly": "add_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "TODO:h", "op1": "TODO:h", "op2": "S03S0" } }
+;     ]
+;     }
+;   }
+; OUTPUT:addsi3
+(define_insn "*addsi3" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=q,q,q,q,r,r,r,r,r,r,r,r") 
+      (plus:SI 
+        (match_operand:SI 1 "nonmemory_operand" "%    q,    0,q,    0,0,    0,    0,    r,    r,r,ULIMM,    r") 
+        (match_operand:SI 2 "nonmemory_operand" " U03S0,U07S0,q,ULIMM,r,ULIMM,U06S0,U06S0,S12S0,r,    r,ULIMM")))]
+ "register_operand (operands[1], SImode)
+  || register_operand (operands[2], SImode)"
+ "@
+  add_s %0,%1,%2
+  add_s %0,%1,%2
+  add_s %0,%1,%2
+  add_s %0,%1,%2
+  add %0,%1,%2
+  add %0,%1,%2
+  add %0,%1,%2
+  add %0,%1,%2
+  add %0,%1,%2
+  add %0,%1,%2
+  add %0,%1,%2
+  add %0,%1,%2" [
+    (set_attr "predicable" "no,no,no,no,yes,yes,yes,no,no,no,no,no")
+    (set_attr "length"     "2,2,2,6,4,8,4,4,4,4,8,8")
+    (set_attr "type"       "add,add,add,add,add,add,add,add,add,add,add,add")]
+)
+; END:addsi3
+
+; START:adddi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (minus:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "addl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "addl_s R0:r0, GP:gp, s11:simm11 (6584)", "assembly": "addl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "SR_R0", "op1": "SR_GP", "op2": "S11S0" } },
+;       { "_comment": "addl_s SP:sp, SP:sp, u9:uimm9 (6575)", "assembly": "addl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "SR_SP", "op1": "0", "op2": "U09S0" } },
+;       { "_comment": "addl_s b:R3, SP:sp, u7:uimm7 (6574)", "assembly": "addl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "SR_SP", "op2": "U07S0" } },
+;       { "_comment": "addl_s b:R3, b:R3, c:R3 (6585)", "assembly": "addl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "q" } },
+;       { "_comment": "addl.cc.f RB:rb, RB:rb, u6:uimm6 (4968)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "addl.cc.f RB:rb, RB:rb, limm:limm (4975)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "addl.cc.f RB:rb, RB:rb, ximm:ximm (4988)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "addl.cc.f RB:rb, RB:rb, RC:rc (4965)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "addl.f RA:ra, RB:rb, u6:uimm6 (4966)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "addl.f RB:rb, RB:rb, s12:simm12 (4969)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "S12S0" } },
+;       { "_comment": "addl.f RA:ra, limm:limm, u6:uimm6 (4976)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "U06S0" } },
+;       { "_comment": "addl.f RA:ra, ximm:ximm, u6:uimm6 (4989)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "U06S0" } },
+;       { "_comment": "addl.f RA:ra, limm:limm, RC:rc (4970)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "addl.f RA:ra, ximm:ximm, RC:rc (4983)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "addl.f RA:ra, RB:rb, limm:limm (4971)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "addl.f RA:ra, RB:rb, ximm:ximm (4984)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "addl.f RA:ra, RB:rb, RC:rc (4963)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "addl %0,%1,%2",
+;       "addl_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "not included": [
+;         { "_comment": "addl_s h:h, PCL:pcl, ximm:ximm (6595)", "assembly": "addl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "TODO:h", "op1": "SRPCL", "op2": "UXIMM" } },
+;         { "_comment": "addl_s h:h, h:h, ximm:ximm (6594)", "assembly": "addl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "TODO:h", "op1": "TODO:h", "op2": "UXIMM" } },
+;         { "_comment": "addl.f RA:ra, limm:limm, limm:limm (4980)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "ULIMM" } },
+;         { "_comment": "addl.f RA:ra, ximm:ximm, ximm:ximm (4993)", "assembly": "addl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "UXIMM" } }
+;     ]
+;     }
+;   }
+; OUTPUT:adddi3
+(define_insn "adddi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=SR_R0,SR_SP,q,q,r,r,r,r,r,r,r,r,r,r,r,r,r") 
+      (minus:DI 
+        (match_operand:DI 1 "nonmemory_operand" "SR_GP,0,SR_SP,0,0,0,0,0,r,r,ULIMM,UXIMM,ULIMM,UXIMM,r,r,r") 
+        (match_operand:DI 2 "nonmemory_operand" "S11S0,U09S0,U07S0,q,U06S0,ULIMM,UXIMM,r,U06S0,S12S0,U06S0,U06S0,r,r,ULIMM,UXIMM,r")))]
+ "true" "@
+  addl_s %0,%1,%2
+  addl_s %0,%1,%2
+  addl_s %0,%1,%2
+  addl_s %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2
+  addl %0,%1,%2" [
+    (set_attr "predicable" "no,no,no,no,yes,yes,yes,yes,no,no,no,no,no,no,no,no,no")
+    (set_attr "length" "2,2,2,2,4,8,4,4,4,4,8,4,8,4,8,4,4")
+    (set_attr "type" "addl,addl,addl,addl,addl,addl,addl,addl,addl,addl,addl,addl,addl,addl,addl,addl,addl")]
+)
+; END:adddi3
+
+; START:subsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (minus:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "sub"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "sub_s b:R3, b:R3, c:R3 (3279)", "assembly": "sub_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "q" } },
+;       { "_comment": "sub_s c:R3, b:R3, u3:uimm3 (3277)", "assembly": "sub_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q", "op2": "U03S0" } },
+;       { "_comment": "sub_s b:R3, b:R3, u5:uimm5 (3280)", "assembly": "sub_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "U05S0" } },
+;       { "_comment": "sub_s a:R3, b:R3, c:R3 (3282)", "assembly": "sub_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q", "op2": "q" } },
+;       { "_comment": "sub.cc.f b:R6, b:R6, u6:uimm6 (3275)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "sub.cc.f b:R6, b:R6, limm:limm (3272)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "sub.cc.f b:R6, b:R6, c:R6 (3271)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "sub.f a:R6, b:R6, limm:limm (3259)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "sub.f a:R6, b:R6, u6:uimm6 (3265)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "sub.f b:R6, b:R6, s12:simm12 (3269)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "sub.f a:R6, limm:limm, c:R6 (3258)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "sub.f a:R6, limm:limm, u6:uimm6 (3266)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "U06S0" } },
+;       { "_comment": "sub.f a:R6, b:R6, c:R6 (3257)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "sub %0,%1,%2",
+;       "sub_s %0,%1,%2",
+;       "sub1 %0,%1,%2",
+;       "sub2 %0,%1,%2",
+;       "sub3 %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "not included": [
+;         { "_comment": "sub_s.NE b:R3, b:R3, b:R3 (3278)", "assembly": "sub_s %0,%1,%2", "attributes":   { "predicable": "yes", "length": "2" }, "constraints":   { "op0": "q", "op1": "q", "op2": "q" } },
+;         { "_comment": "sub.f a:R6, limm:limm, limm:limm (3260)", "assembly": "sub %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "ULIMM" } }
+;     ]
+;     }
+;   }
+; END:subsi3
+
+; START:subdi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (minus:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "sub"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "subl_s SP:sp, SP:sp, u9:uimm9 (6576)", "assembly": "subl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "SR_SP", "op1": "0", "op2": "U09S0" } },
+;       { "_comment": "subl_s b:R3, b:R3, c:R3 (6586)", "assembly": "subl_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "q" } },
+;       { "_comment": "subl.cc.f RB:rb, RB:rb, RC:rc (5031)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "subl.cc.f RB:rb, RB:rb, limm:limm (5041)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "subl.cc.f RB:rb, RB:rb, u6:uimm6 (5034)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "subl.cc.f RB:rb, RB:rb, ximm:ximm (5054)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "subl.f RA:ra, RB:rb, u6:uimm6 (5032)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "subl.f RB:rb, RB:rb, s12:simm12 (5035)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "subl.f RA:ra, RB:rb, limm:limm (5037)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "subl.f RA:ra, RB:rb, ximm:ximm (5050)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "subl.f RA:ra, limm:limm, RC:rc (5036)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "subl.f RA:ra, ximm:ximm, RC:rc (5049)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "subl.f RA:ra, RB:rb, RC:rc (5029)", "assembly": "subl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "subl %0,%1,%2",
+;       "subl_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:subdi3
+(define_insn "subdi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=SR_SP,q,r,r,r,r,r,r,r,r,r,r,r") 
+      (minus:DI 
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,0,0,r,0,r,r,ULIMM,UXIMM,r") 
+        (match_operand:DI 2 "nonmemory_operand" "U09S0,q,r,ULIMM,U06S0,UXIMM,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  subl_s %0,%1,%2
+  subl_s %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2
+  subl %0,%1,%2" [
+    (set_attr "predicable" "no,no,yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "2,2,4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "sub,sub,sub,sub,sub,sub,sub,sub,sub,sub,sub,sub,sub")]
+)
+; END:subdi3
+
+; START:abssi2
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (abs:SI @op1{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "abs"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "",
+;   "ordered_constraints": [
+;       { "_comment": "abs_s b:R3, c:R3 (7)", "assembly": "abs_s %0,%1", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q" } },
+;       { "_comment": "abs.f b:R6, u6:uimm6 (5)", "assembly": "abs %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "abs.f b:R6, limm:limm (2)", "assembly": "abs %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "abs.f b:R6, c:R6 (1)", "assembly": "abs %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "abs %0,%1",
+;       "abs_s %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:abssi2
+(define_insn "abssi2" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=q,r,r,r") 
+      (abs:SI 
+        (match_operand:SI 1 "nonmemory_operand" "q,U06S0,ULIMM,r")))]
+ "true" "@
+  abs_s %0,%1
+  abs %0,%1
+  abs %0,%1
+  abs %0,%1" [
+    (set_attr "predicable" "no,no,no,no")
+    (set_attr "length" "2,4,8,4")
+    (set_attr "type" "abs,abs,abs,abs")]
+)
+; END:abssi2
+
+
+; START:absdi2
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (abs:DI @op1{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "abs"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "",
+;   "ordered_constraints": [
+;       { "_comment": "absl.f RB:rb, u6:uimm6 (6300)", "assembly": "absl %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "U06S0" } },
+;       { "_comment": "absl.f RB:rb, limm:limm (6302)", "assembly": "absl %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "absl.f RB:rb, ximm:ximm (6304)", "assembly": "absl %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM" } },
+;       { "_comment": "absl.f RB:rb, RC:rc (6298)", "assembly": "absl %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "absl %0,%1",
+;       "absl_s %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:absdi2
+(define_insn "absdi2" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=r,r,r,r") 
+      (abs:DI 
+        (match_operand:DI 1 "nonmemory_operand" "U06S0,ULIMM,UXIMM,r")))]
+ "true" "@
+  absl %0,%1
+  absl %0,%1
+  absl %0,%1
+  absl %0,%1" [
+    (set_attr "predicable" "no,no,no,no")
+    (set_attr "length" "4,8,4,4")
+    (set_attr "type" "abs,abs,abs,abs")]
+)
+; END:absdi2
+
+
+; START:negsi2
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (neg:SI @op1{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "neg"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "neg_s b:R3, c:R3 (2495)", "assembly": "neg_s %0,%1", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "q" } },
+;       { "_comment": "neg.cc.f b:R6, b:R6 (2493)", "assembly": "neg %0,%1", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0" } },
+;       { "_comment": "neg.f a:R6, limm:limm (2492)", "assembly": "neg %0,%1", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM" } },
+;       { "_comment": "neg.f a:R6, b:R6 (2491)", "assembly": "neg %0,%1", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "neg %0,%1",
+;       "neg_s %0,%1"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:negsi2
+(define_insn "negsi2" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=q,r,r,r") 
+      (neg:SI 
+        (match_operand:SI 1 "nonmemory_operand" "q,0,ULIMM,r")))]
+ "true" "@
+  neg_s %0,%1
+  neg %0,%1
+  neg %0,%1
+  neg %0,%1" [
+    (set_attr "predicable" "no,yes,no,no")
+    (set_attr "length" "2,4,8,4")
+    (set_attr "type" "neg,neg,neg,neg")]
+)
+; END:negsi2
+
+; START:divsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (div:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "div"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "div.cc.f b:R6, b:R6, c:R6 (780)", "assembly": "div %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "div.cc.f b:R6, b:R6, u6:uimm6 (784)", "assembly": "div %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "div.cc.f b:R6, b:R6, limm:limm (781)", "assembly": "div %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "div.f b:R6, b:R6, s12:simm12 (778)", "assembly": "div %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "div.f a:R6, b:R6, u6:uimm6 (774)", "assembly": "div %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "div.f a:R6, b:R6, limm:limm (768)", "assembly": "div %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "div.f a:R6, limm:limm, c:R6 (767)", "assembly": "div %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "div.f a:R6, b:R6, c:R6 (766)", "assembly": "div %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "div %0,%1,%2",
+;       "div_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:divsi3
+(define_insn "divsi3" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,r") 
+      (div:SI 
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,0,r,r,ULIMM,r") 
+        (match_operand:SI 2 "nonmemory_operand" "r,U06S0,ULIMM,S12S0,U06S0,ULIMM,r,r")))]
+ "true" "@
+  div %0,%1,%2
+  div %0,%1,%2
+  div %0,%1,%2
+  div %0,%1,%2
+  div %0,%1,%2
+  div %0,%1,%2
+  div %0,%1,%2
+  div %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "4,4,8,4,4,8,8,4")
+    (set_attr "type" "div,div,div,div,div,div,div,div")]
+)
+; END:divsi3
+
+; START:divdi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (div:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "div"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "divl.cc.f RB:rb, RB:rb, u6:uimm6 (5760)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "divl.cc.f RB:rb, RB:rb, limm:limm (5767)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "divl.cc.f RB:rb, RB:rb, ximm:ximm (5780)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "divl.cc.f RB:rb, RB:rb, RC:rc (5757)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "divl.f RA:ra, RB:rb, u6:uimm6 (5758)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "divl.f RB:rb, RB:rb, s12:simm12 (5761)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "divl.f RA:ra, RB:rb, limm:limm (5763)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "divl.f RA:ra, RB:rb, ximm:ximm (5776)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "divl.f RA:ra, limm:limm, RC:rc (5762)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "divl.f RA:ra, ximm:ximm, RC:rc (5775)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "divl.f RA:ra, RB:rb, RC:rc (5755)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "divl %0,%1,%2",
+;       "divl_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:divdi3
+(define_insn "divdi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r") 
+      (div:DI 
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r") 
+        (match_operand:DI 2 "nonmemory_operand" "U06S0,ULIMM,UXIMM,r,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "div,div,div,div,div,div,div,div,div,div,div")]
+)
+; END:divdi3
+
+; START:udivsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (udiv:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "udiv"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "divu.cc.f b:R6, b:R6, u6:uimm6 (804)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "divu.cc.f b:R6, b:R6, limm:limm (801)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "divu.cc.f b:R6, b:R6, c:R6 (800)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "divu.f a:R6, b:R6, u6:uimm6 (794)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "divu.f b:R6, b:R6, s12:simm12 (798)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "divu.f a:R6, b:R6, limm:limm (788)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "divu.f a:R6, limm:limm, c:R6 (787)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "divu.f a:R6, limm:limm, limm:limm (789)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "ULIMM" } },
+;       { "_comment": "divu.f a:R6, limm:limm, u6:uimm6 (795)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "U06S0" } },
+;       { "_comment": "divu.f a:R6, b:R6, c:R6 (786)", "assembly": "divu %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "divu %0,%1,%2",
+;       "divu_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:udivsi3
+(define_insn "udivsi3" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r") 
+      (udiv:SI 
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,r,0,r,ULIMM,ULIMM,ULIMM,r") 
+        (match_operand:SI 2 "nonmemory_operand" "U06S0,ULIMM,r,U06S0,S12S0,ULIMM,r,ULIMM,U06S0,r")))]
+ "true" "@
+  divu %0,%1,%2
+  divu %0,%1,%2
+  divu %0,%1,%2
+  divu %0,%1,%2
+  divu %0,%1,%2
+  divu %0,%1,%2
+  divu %0,%1,%2
+  divu %0,%1,%2
+  divu %0,%1,%2
+  divu %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,8,8,8,8,4")
+    (set_attr "type" "udiv,udiv,udiv,udiv,udiv,udiv,udiv,udiv,udiv,udiv")]
+)
+; END:udivsi3
+
+; START:udivdi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (udiv:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "udivl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "divl.cc.f RB:rb, RB:rb, u6:uimm6 (5760)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "divl.cc.f RB:rb, RB:rb, limm:limm (5767)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "divl.cc.f RB:rb, RB:rb, ximm:ximm (5780)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "divl.cc.f RB:rb, RB:rb, RC:rc (5757)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "divl.f RA:ra, RB:rb, u6:uimm6 (5758)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "divl.f RB:rb, RB:rb, s12:simm12 (5761)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "divl.f RA:ra, RB:rb, limm:limm (5763)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "divl.f RA:ra, RB:rb, ximm:ximm (5776)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "divl.f RA:ra, limm:limm, RC:rc (5762)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "divl.f RA:ra, ximm:ximm, RC:rc (5775)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "divl.f RA:ra, RB:rb, RC:rc (5755)", "assembly": "divl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "divul %0,%1,%2",
+;       "divul_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:udivdi3
+(define_insn "udivdi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r") 
+      (udiv:DI 
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r") 
+        (match_operand:DI 2 "nonmemory_operand" "U06S0,ULIMM,UXIMM,r,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2
+  divl %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "udivl,udivl,udivl,udivl,udivl,udivl,udivl,udivl,udivl,udivl,udivl")]
+)
+; END:udivdi3
+
+; START:smaxsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (smax:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "max"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "max.cc.f b:R6, b:R6, u6:uimm6 (2043)", "assembly": "max %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "max.cc.f b:R6, b:R6, limm:limm (2040)", "assembly": "max %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "max.cc.f b:R6, b:R6, c:R6 (2039)", "assembly": "max %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "max.f a:R6, b:R6, u6:uimm6 (2033)", "assembly": "max %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "max.f b:R6, b:R6, s12:simm12 (2037)", "assembly": "max %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "max.f a:R6, b:R6, limm:limm (2027)", "assembly": "max %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "max.f a:R6, limm:limm, c:R6 (2026)", "assembly": "max %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "max.f a:R6, b:R6, c:R6 (2025)", "assembly": "max %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "max %0,%1,%2",
+;       "max_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:smaxsi3
+(define_insn "smaxsi3" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,r") 
+      (smax:SI 
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,r,0,r,ULIMM,r") 
+        (match_operand:SI 2 "nonmemory_operand" "U06S0,ULIMM,r,U06S0,S12S0,ULIMM,r,r")))]
+ "true" "@
+  max %0,%1,%2
+  max %0,%1,%2
+  max %0,%1,%2
+  max %0,%1,%2
+  max %0,%1,%2
+  max %0,%1,%2
+  max %0,%1,%2
+  max %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,8,8,4")
+    (set_attr "type" "max,max,max,max,max,max,max,max")]
+)
+; END:smaxsi3
+
+; START:smaxdi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (smax:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "maxl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "maxl.cc.f RB:rb, RB:rb, u6:uimm6 (5232)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "maxl.cc.f RB:rb, RB:rb, limm:limm (5239)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "maxl.cc.f RB:rb, RB:rb, ximm:ximm (5252)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "maxl.cc.f RB:rb, RB:rb, RC:rc (5229)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "maxl.f RA:ra, RB:rb, u6:uimm6 (5230)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "maxl.f RB:rb, RB:rb, s12:simm12 (5233)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "maxl.f RA:ra, RB:rb, limm:limm (5235)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "maxl.f RA:ra, RB:rb, ximm:ximm (5248)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "maxl.f RA:ra, limm:limm, RC:rc (5234)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "maxl.f RA:ra, ximm:ximm, RC:rc (5247)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "maxl.f RA:ra, RB:rb, RC:rc (5227)", "assembly": "maxl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "maxl %0,%1,%2",
+;       "maxl_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ],
+;     "failed_for_operands": [
+;         { "_comment": "maxl.aq RB:rb, RC:rc (6426)" },
+;         { "_comment": "maxl.aq 0:0, RC:rc (6427)" },
+;         { "_comment": "maxl.aq RB:rb, u6:uimm6 (6428)" },
+;         { "_comment": "maxl.aq 0:0, u6:uimm6 (6429)" },
+;         { "_comment": "maxl.aq RB:rb, limm:limm (6430)" },
+;         { "_comment": "maxl.aq 0:0, limm:limm (6431)" },
+;         { "_comment": "maxl.aq RB:rb, ximm:ximm (6432)" },
+;         { "_comment": "maxl.aq 0:0, ximm:ximm (6433)" }
+;     ]
+;     }
+;   }
+; OUTPUT:smaxdi3
+(define_insn "smaxdi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r") 
+      (smax:DI 
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r") 
+        (match_operand:DI 2 "nonmemory_operand" "U06S0,ULIMM,UXIMM,r,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2
+  maxl %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "maxl,maxl,maxl,maxl,maxl,maxl,maxl,maxl,maxl,maxl,maxl")]
+)
+; END:smaxdi3
+
+
+; START:sminsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (smin:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "min"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "min.cc.f b:R6, b:R6, c:R6 (2059)", "assembly": "min %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "min.cc.f b:R6, b:R6, limm:limm (2060)", "assembly": "min %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "min.cc.f b:R6, b:R6, u6:uimm6 (2063)", "assembly": "min %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "min.f a:R6, b:R6, u6:uimm6 (2053)", "assembly": "min %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "min.f b:R6, b:R6, s12:simm12 (2057)", "assembly": "min %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "min.f a:R6, b:R6, limm:limm (2047)", "assembly": "min %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "min.f a:R6, limm:limm, c:R6 (2046)", "assembly": "min %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "min.f a:R6, b:R6, c:R6 (2045)", "assembly": "min %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "min %0,%1,%2",
+;       "min_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:sminsi3
+(define_insn "sminsi3" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,r") 
+      (smin:SI 
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,r,0,r,ULIMM,r") 
+        (match_operand:SI 2 "nonmemory_operand" "r,ULIMM,U06S0,U06S0,S12S0,ULIMM,r,r")))]
+ "true" "@
+  min %0,%1,%2
+  min %0,%1,%2
+  min %0,%1,%2
+  min %0,%1,%2
+  min %0,%1,%2
+  min %0,%1,%2
+  min %0,%1,%2
+  min %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,8,8,4")
+    (set_attr "type" "min,min,min,min,min,min,min,min")]
+)
+; END:sminsi3
+
+
+; START:smindi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (smin:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "minl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "minl.cc.f RB:rb, RB:rb, RC:rc (5262)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "minl.cc.f RB:rb, RB:rb, limm:limm (5272)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "minl.cc.f RB:rb, RB:rb, u6:uimm6 (5265)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "minl.cc.f RB:rb, RB:rb, ximm:ximm (5285)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "minl.f RA:ra, RB:rb, u6:uimm6 (5263)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "minl.f RB:rb, RB:rb, s12:simm12 (5266)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "minl.f RA:ra, RB:rb, limm:limm (5268)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "minl.f RA:ra, RB:rb, ximm:ximm (5281)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "minl.f RA:ra, limm:limm, RC:rc (5267)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "minl.f RA:ra, ximm:ximm, RC:rc (5280)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "minl.f RA:ra, RB:rb, RC:rc (5260)", "assembly": "minl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "minl %0,%1,%2",
+;       "minl_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ],
+;     "failed_for_operands": [
+;         { "_comment": "minl.aq RB:rb, RC:rc (6410)" },
+;         { "_comment": "minl.aq 0:0, RC:rc (6411)" },
+;         { "_comment": "minl.aq RB:rb, u6:uimm6 (6412)" },
+;         { "_comment": "minl.aq 0:0, u6:uimm6 (6413)" },
+;         { "_comment": "minl.aq RB:rb, limm:limm (6414)" },
+;         { "_comment": "minl.aq 0:0, limm:limm (6415)" },
+;         { "_comment": "minl.aq RB:rb, ximm:ximm (6416)" },
+;         { "_comment": "minl.aq 0:0, ximm:ximm (6417)" }
+;     ]
+;     }
+;   }
+; OUTPUT:smindi3
+(define_insn "smindi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r") 
+      (smin:DI 
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r") 
+        (match_operand:DI 2 "nonmemory_operand" "r,ULIMM,U06S0,UXIMM,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2
+  minl %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "minl,minl,minl,minl,minl,minl,minl,minl,minl,minl,minl")]
+)
+; END:smindi3
+
+; START:modsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (mod:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "rem"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "rem.cc.f b:R6, b:R6, c:R6 (2882)", "assembly": "rem %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "rem.cc.f b:R6, b:R6, limm:limm (2883)", "assembly": "rem %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "rem.cc.f b:R6, b:R6, u6:uimm6 (2886)", "assembly": "rem %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "rem.f a:R6, b:R6, u6:uimm6 (2876)", "assembly": "rem %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "rem.f b:R6, b:R6, s12:simm12 (2880)", "assembly": "rem %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "rem.f a:R6, b:R6, limm:limm (2870)", "assembly": "rem %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "rem.f a:R6, limm:limm, c:R6 (2869)", "assembly": "rem %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "rem.f a:R6, b:R6, c:R6 (2868)", "assembly": "rem %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "rem %0,%1,%2",
+;       "rem_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:modsi3
+(define_insn "modsi3" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,r") 
+      (mod:SI 
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,r,0,r,ULIMM,r") 
+        (match_operand:SI 2 "nonmemory_operand" "r,ULIMM,U06S0,U06S0,S12S0,ULIMM,r,r")))]
+ "true" "@
+  rem %0,%1,%2
+  rem %0,%1,%2
+  rem %0,%1,%2
+  rem %0,%1,%2
+  rem %0,%1,%2
+  rem %0,%1,%2
+  rem %0,%1,%2
+  rem %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,8,8,4")
+    (set_attr "type" "rem,rem,rem,rem,rem,rem,rem,rem")]
+)
+; END:modsi3
+
+; START:moddi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (mod:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "reml"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "reml.cc.f RB:rb, RB:rb, u6:uimm6 (5826)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "reml.cc.f RB:rb, RB:rb, RC:rc (5823)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "reml.cc.f RB:rb, RB:rb, limm:limm (5833)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "reml.cc.f RB:rb, RB:rb, ximm:ximm (5846)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "reml.f RA:ra, RB:rb, u6:uimm6 (5824)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "reml.f RB:rb, RB:rb, s12:simm12 (5827)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "reml.f RA:ra, RB:rb, limm:limm (5829)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "reml.f RA:ra, RB:rb, ximm:ximm (5842)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "reml.f RA:ra, limm:limm, RC:rc (5828)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "reml.f RA:ra, ximm:ximm, RC:rc (5841)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "reml.f RA:ra, RB:rb, RC:rc (5821)", "assembly": "reml %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "reml %0,%1,%2",
+;       "reml_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:moddi3
+(define_insn "moddi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r") 
+      (mod:DI 
+        (match_operand:DI 1 "nonmemory_operand" "r,0,0,0,r,0,r,r,ULIMM,UXIMM,r") 
+        (match_operand:DI 2 "nonmemory_operand" "U06S0,r,ULIMM,UXIMM,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2
+  reml %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,4,8,4,4,4,8,4,8,4,4")
+    (set_attr "type" "reml,reml,reml,reml,reml,reml,reml,reml,reml,reml,reml")]
+)
+; END:moddi3
+
+; START:umodsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (umod:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "remu"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "remu.cc.f b:R6, b:R6, c:R6 (2902)", "assembly": "remu %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "remu.cc.f b:R6, b:R6, limm:limm (2903)", "assembly": "remu %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "remu.cc.f b:R6, b:R6, u6:uimm6 (2906)", "assembly": "remu %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "remu.f a:R6, b:R6, u6:uimm6 (2896)", "assembly": "remu %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "remu.f b:R6, b:R6, s12:simm12 (2900)", "assembly": "remu %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "remu.f a:R6, b:R6, limm:limm (2890)", "assembly": "remu %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "remu.f a:R6, limm:limm, c:R6 (2889)", "assembly": "remu %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "remu.f a:R6, b:R6, c:R6 (2888)", "assembly": "remu %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "remu %0,%1,%2",
+;       "remu_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:umodsi3
+(define_insn "umodsi3" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,r") 
+      (umod:SI 
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,r,0,r,ULIMM,r") 
+        (match_operand:SI 2 "nonmemory_operand" "r,ULIMM,U06S0,U06S0,S12S0,ULIMM,r,r")))]
+ "true" "@
+  remu %0,%1,%2
+  remu %0,%1,%2
+  remu %0,%1,%2
+  remu %0,%1,%2
+  remu %0,%1,%2
+  remu %0,%1,%2
+  remu %0,%1,%2
+  remu %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,8,8,4")
+    (set_attr "type" "remu,remu,remu,remu,remu,remu,remu,remu")]
+)
+; END:umodsi3
+
+; START:umoddi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (umod:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "remul"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "remul.cc.f RB:rb, RB:rb, RC:rc (5856)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "remul.cc.f RB:rb, RB:rb, limm:limm (5866)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "remul.cc.f RB:rb, RB:rb, u6:uimm6 (5859)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "remul.cc.f RB:rb, RB:rb, ximm:ximm (5879)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "remul.f RB:rb, RB:rb, s12:simm12 (5860)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "S12S0" } },
+;       { "_comment": "remul.f RA:ra, RB:rb, u6:uimm6 (5857)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "remul.f RA:ra, RB:rb, limm:limm (5862)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "remul.f RA:ra, RB:rb, ximm:ximm (5875)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "remul.f RA:ra, limm:limm, RC:rc (5861)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "remul.f RA:ra, ximm:ximm, RC:rc (5874)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "remul.f RA:ra, RB:rb, RC:rc (5854)", "assembly": "remul %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "remul %0,%1,%2",
+;       "remul_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:umoddi3
+(define_insn "umoddi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r") 
+      (umod:DI 
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r") 
+        (match_operand:DI 2 "nonmemory_operand" "r,ULIMM,U06S0,UXIMM,S12S0,U06S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2
+  remul %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "remul,remul,remul,remul,remul,remul,remul,remul,remul,remul,remul")]
+)
+; END:umoddi3
+
+
+; START:xorsi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=SI} (xor:SI @op1{mode=SI} @op2{mode=SI}))]",
+;   "general_attributes":   {
+;     "type": "xor"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], SImode) || register_operand (operands[2], SImode)",
+;   "ordered_constraints": [
+;       { "_comment": "xor.cc.f b:R6, b:R6, c:R6 (4502)", "assembly": "xor %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "xor.cc.f b:R6, b:R6, limm:limm (4504)", "assembly": "xor %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "xor.cc.f b:R6, b:R6, u6:uimm6 (4506)", "assembly": "xor %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "xor.f b:R6, b:R6, s12:simm12 (4500)", "assembly": "xor %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "xor.f a:R6, b:R6, limm:limm (4490)", "assembly": "xor %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "xor.f a:R6, b:R6, u6:uimm6 (4496)", "assembly": "xor %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "xor.f a:R6, limm:limm, c:R6 (4489)", "assembly": "xor %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "xor_s b:R3, b:R3, c:R3 (4508)", "assembly": "xor_s %0,%1,%2", "attributes":   { "predicable": "no", "length": "2" }, "constraints":   { "op0": "q", "op1": "0", "op2": "q" } },
+;       { "_comment": "xor.f a:R6, b:R6, c:R6 (4488)", "assembly": "xor %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "xor %0,%1,%2",
+;       "xor_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ]
+;     }
+;   }
+; OUTPUT:xorsi3
+(define_insn "xorsi3" [
+    (set 
+      (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r,q,r") 
+      (xor:SI 
+        (match_operand:SI 1 "nonmemory_operand" "0,0,0,0,r,r,ULIMM,0,r") 
+        (match_operand:SI 2 "nonmemory_operand" "r,ULIMM,U06S0,S12S0,ULIMM,U06S0,r,q,r")))]
+ "true" "@
+  xor %0,%1,%2
+  xor %0,%1,%2
+  xor %0,%1,%2
+  xor %0,%1,%2
+  xor %0,%1,%2
+  xor %0,%1,%2
+  xor %0,%1,%2
+  xor_s %0,%1,%2
+  xor %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,8,4,8,2,4")
+    (set_attr "type" "xor,xor,xor,xor,xor,xor,xor,xor,xor")]
+)
+; END:xorsi3
+
+; START:xordi3
+;   {
+;   "valid_actions": "generate/db_constraints",
+;   "type": "define_insn",
+;   "match_rule": "[(set @op0{mode=DI} (xor:DI @op1{mode=DI} @op2{mode=DI}))]",
+;   "general_attributes":   {
+;     "type": "xorl"
+;     },
+;   "operand_predicates":   {
+;     "op0": "register_operand",
+;     "op1": "nonmemory_operand",
+;     "op2": "nonmemory_operand"
+;     },
+;   "constraint_predecessor":   {
+;     "op0": "="
+;     },
+;   "pattern_predicate": "true",
+;   "to_become_pattern_predicate": "register_operand (operands[1], DImode) || register_operand (operands[2], DImode)",
+;   "ordered_constraints": [
+;       { "_comment": "xorl.cc.f RB:rb, RB:rb, RC:rc (5196)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "r" } },
+;       { "_comment": "xorl.cc.f RB:rb, RB:rb, limm:limm (5206)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "8" }, "constraints":   { "op0": "r", "op1": "0", "op2": "ULIMM" } },
+;       { "_comment": "xorl.cc.f RB:rb, RB:rb, u6:uimm6 (5199)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "U06S0" } },
+;       { "_comment": "xorl.cc.f RB:rb, RB:rb, ximm:ximm (5219)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "yes", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "UXIMM" } },
+;       { "_comment": "xorl.f RA:ra, RB:rb, u6:uimm6 (5197)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "U06S0" } },
+;       { "_comment": "xorl.f RB:rb, RB:rb, s12:simm12 (5200)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "0", "op2": "S12S0" } },
+;       { "_comment": "xorl.f RA:ra, RB:rb, limm:limm (5202)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "r", "op2": "ULIMM" } },
+;       { "_comment": "xorl.f RA:ra, RB:rb, ximm:ximm (5215)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "UXIMM" } },
+;       { "_comment": "xorl.f RA:ra, limm:limm, RC:rc (5201)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "8" }, "constraints":   { "op0": "r", "op1": "ULIMM", "op2": "r" } },
+;       { "_comment": "xorl.f RA:ra, ximm:ximm, RC:rc (5214)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "UXIMM", "op2": "r" } },
+;       { "_comment": "xorl.f RA:ra, RB:rb, RC:rc (5194)", "assembly": "xorl %0,%1,%2", "attributes":   { "predicable": "no", "length": "4" }, "constraints":   { "op0": "r", "op1": "r", "op2": "r" } }
+;   ],
+;   "DB_match_information":   {
+;     "instructions_to_match": [
+;       "xorl %0,%1,%2",
+;       "xorl_s %0,%1,%2"
+;     ]
+;     },
+;   "DB_generated":   {
+;     "found_matches": [
+;     
+;     ],
+;     "failed_for_operands": [
+;         { "_comment": "xorl.aq RB:rb, RC:rc (6394)" },
+;         { "_comment": "xorl.aq 0:0, RC:rc (6395)" },
+;         { "_comment": "xorl.aq RB:rb, u6:uimm6 (6396)" },
+;         { "_comment": "xorl.aq 0:0, u6:uimm6 (6397)" },
+;         { "_comment": "xorl.aq RB:rb, limm:limm (6398)" },
+;         { "_comment": "xorl.aq 0:0, limm:limm (6399)" },
+;         { "_comment": "xorl.aq RB:rb, ximm:ximm (6400)" },
+;         { "_comment": "xorl.aq 0:0, ximm:ximm (6401)" }
+;     ]
+;     }
+;   }
+; OUTPUT:xordi3
+(define_insn "xordi3" [
+    (set 
+      (match_operand:DI 0 "register_operand" "=r,r,r,r,r,r,r,r,r,r,r") 
+      (xor:DI 
+        (match_operand:DI 1 "nonmemory_operand" "0,0,0,0,r,0,r,r,ULIMM,UXIMM,r") 
+        (match_operand:DI 2 "nonmemory_operand" "r,ULIMM,U06S0,UXIMM,U06S0,S12S0,ULIMM,UXIMM,r,r,r")))]
+ "true" "@
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2
+  xorl %0,%1,%2" [
+    (set_attr "predicable" "yes,yes,yes,yes,no,no,no,no,no,no,no")
+    (set_attr "length" "4,8,4,4,4,4,8,4,8,4,4")
+    (set_attr "type" "xorl,xorl,xorl,xorl,xorl,xorl,xorl,xorl,xorl,xorl,xorl")]
+)
+; END:xordi3
+
+
diff --git a/gcc/config/arc64/linux.h b/gcc/config/arc64/linux.h
new file mode 100644
index 00000000000..f869b12414d
--- /dev/null
+++ b/gcc/config/arc64/linux.h
@@ -0,0 +1,92 @@
+/* Target macros for arc64-*-linux targets.
+
+   Copyright (C) 2020 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Enable DWARF 2 exceptions.  */
+#undef DWARF2_UNWIND_INFO
+#define DWARF2_UNWIND_INFO 1
+
+#define TARGET_OS_CPP_BUILTINS()		\
+  do						\
+    {						\
+      GNU_USER_TARGET_OS_CPP_BUILTINS ();	\
+    }						\
+  while (0)
+
+#define GLIBC_DYNAMIC_LINKER   "/lib/ld-linux-arc64.so.2"
+
+/* Note that the default is to link against dynamic libraries, if they are
+   available.  Override with -static.  */
+#undef LINK_SPEC
+#define LINK_SPEC "%{h*} \
+  %{static:-Bstatic} \
+  %{shared:-shared} \
+  %{symbolic:-Bsymbolic} \
+  %{!static: \
+    %{rdynamic:-export-dynamic} \
+    %{!shared:-dynamic-linker " GNU_USER_DYNAMIC_LINKER "}} \
+  -X "
+
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC							\
+  LINUX_OR_ANDROID_LD (GNU_USER_TARGET_STARTFILE_SPEC, ANDROID_STARTFILE_SPEC)
+
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC							\
+  LINUX_OR_ANDROID_LD (GNU_USER_TARGET_ENDFILE_SPEC, ANDROID_ENDFILE_SPEC)
+
+#undef LIB_SPEC
+#define LIB_SPEC  \
+  "%{pthread:-lpthread} \
+   %{shared:-lc} \
+   %{!shared:%{profile:-lc_p}%{!profile:-lc}}"
+
+#undef TARGET_ASM_FILE_END
+#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
+
+/* We do not have any MULTILIB_OPTIONS specified, so there are no
+   MULTILIB_DEFAULTS.  */
+#undef  MULTILIB_DEFAULTS
+
+#undef SUBTARGET_CPP_SPEC
+#define SUBTARGET_CPP_SPEC "\
+   %{pthread:-D_REENTRANT} \
+"
+
+#if DEFAULT_LIBC == LIBC_GLIBC
+/* Override linux.h LINK_EH_SPEC definition.
+   Signalize that because we have fde-glibc, we don't need all C shared libs
+   linked against -lgcc_s.  */
+#undef LINK_EH_SPEC
+#define LINK_EH_SPEC "--eh-frame-hdr "
+#endif
+
+/* Clear the instruction cache from `beg' to `end'.  This makes an
+   inline system call to SYS_cacheflush.  */
+#undef CLEAR_INSN_CACHE
+#define CLEAR_INSN_CACHE(beg, end)					\
+{									\
+  register unsigned long _beg __asm ("r0") = (unsigned long) (beg);	\
+  register unsigned long _end __asm ("r1") = (unsigned long) (end);	\
+  register unsigned long _xtr __asm ("r2") = 0;				\
+  register unsigned long _scno __asm ("r8") = 244;			\
+  __asm __volatile ("trap_s 0		; sys_cache_sync"		\
+		    : "=r" (_beg)					\
+		    : "0" (_beg), "r" (_end), "r" (_xtr), "r" (_scno));	\
+}
diff --git a/gcc/config/arc64/predicates.md b/gcc/config/arc64/predicates.md
new file mode 100644
index 00000000000..c3415f9b289
--- /dev/null
+++ b/gcc/config/arc64/predicates.md
@@ -0,0 +1,206 @@
+;; Machine description for arc64 architecture.
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+;; Contributed by Claudiu Zissulescu
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful, but
+;; WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;; General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; Place holder for mov operand predicate
+(define_predicate "arc64_movl_operand"
+  (and (match_code "unspec,reg, subreg, mem, const, const_int, symbol_ref, label_ref")
+       (ior (match_operand 0 "register_operand")
+	    (and (ior (match_code "label_ref")
+		      (match_code "symbol_ref"))
+		 (match_test "arc64_allow_direct_access_p (op)"))
+	    (match_operand 0 "memory_operand")
+	    (and (match_code "unspec")
+		 (ior (match_test "XINT (op,1) == ARC64_UNSPEC_PCREL")
+		      (match_test "XINT (op,1) == ARC64_UNSPEC_TLS_GD")))
+	    (and (match_code "const_int")
+		 (ior (match_test "UNSIGNED_INT32 (INTVAL (op))")
+		      (match_test "SIGNED_INT32 (INTVAL (op))"))))))
+
+(define_predicate "arc64_movf_operand"
+  (and (match_code "reg, subreg, mem, const, const_double")
+       (ior (match_operand 0 "register_operand")
+	    (match_operand 0 "memory_operand")
+	    (and (match_code "const_double")
+		 (ior (match_test "GET_MODE_SIZE (GET_MODE (op)) <= 4")
+		      (match_test "op == CONST0_RTX (DFmode)"))))))
+
+;; A restricted version of the above, still accepting symbols and label refs.
+(define_predicate "arc64_regsym_operand"
+  (ior (match_operand 0 "register_operand")
+       (and (ior (match_code "label_ref")
+		 (match_code "symbol_ref"))
+	    (match_test "arc64_allow_direct_access_p (op)"))
+       (and (match_code "const_int")
+	    (ior (match_test "UNSIGNED_INT32 (INTVAL (op))")
+		 (match_test "SIGNED_INT32 (INTVAL (op))")))))
+
+(define_predicate "arc64_nonmem_operand"
+  (ior (match_operand 0 "register_operand")
+       (and (match_code "const_int")
+	    (ior (match_test "UNSIGNED_INT32 (INTVAL (op))")
+		 (match_test "SIGNED_INT32 (INTVAL (op))")))))
+
+;; Used for HIGH or LO_SUM patterns
+(define_predicate "arc64_immediate_or_pic"
+  (ior (match_operand 0 "immediate_operand")
+       (match_code "unspec")))
+
+;; Acceptable arguments for the call insn.
+(define_predicate "arc64_call_insn_operand"
+  (ior (and (match_code "symbol_ref")
+	    (match_test "!arc64_is_long_call_p (op)"))
+       (match_operand 0 "nonmemory_operand")))
+
+; to be used for b{eq/ne}_s instructions.
+(define_predicate "equality_comparison_operator"
+  (match_code "eq, ne"))
+
+; to be used for b{eq/ne/...}_s instructions.
+(define_predicate "ccmode_comparison_operator"
+  (match_code "eq, ne, gt, ge, lt, le, gtu, geu, ltu, leu,
+	       unlt, unle, unge, ungt")
+  {
+   enum rtx_code code = GET_CODE (op);
+
+   switch (GET_MODE (XEXP (op, 0)))
+   {
+     case E_CC_FPUmode:
+     case E_CC_FPUEmode:
+     case E_CCmode:
+       return 1;
+
+     case E_CC_ZNmode:
+       return (code == EQ || code == NE);
+
+     default:
+       return 0;
+     }
+  })
+
+
+;; True for integer comparisons and for FP comparisons other then LTGT or UNEQ
+(define_special_predicate "arc64_comparison_operator"
+  (match_code "eq, ne, le, lt, ge, gt, geu, gtu, leu, ltu, unordered,
+	       ordered, unlt, unle, unge, ungt"))
+
+(define_special_predicate "cc_register"
+  (match_code "reg")
+{
+  if (mode == VOIDmode)
+    {
+      mode = GET_MODE (op);
+      if (GET_MODE_CLASS (mode) != MODE_CC)
+	return FALSE;
+    }
+
+  if (mode == GET_MODE (op) && GET_CODE (op) == REG && REGNO (op) == CC_REGNUM)
+    return TRUE;
+
+  return FALSE;
+})
+
+;; Return TRUE if OP is a shimm 6bit value
+(define_predicate "S06S0_immediate_operand"
+  (and (match_code "const_int")
+       (match_test "SIGNED_INT6 (INTVAL (op))"))
+)
+
+;; Return true if OP is a MEM that when used as a load or store address will
+;; require an 8 byte insn.
+;; Load and store instructions don't allow the same possibilities but they're
+;; similar enough that this one function will do.
+;; This is currently only used when calculating length attributes.  */
+(define_predicate "limm_ldst_operand"
+  (and (match_code "mem")
+       (match_test "arc64_limm_addr_p (op)")))
+
+;; Allows only 1,2,3 values.  It is used with add/sub shifted operations.
+(define_predicate "_1_2_3_operand"
+  (and (match_code "const_int")
+       (match_test "INTVAL (op) == 1 || INTVAL (op) == 2 || INTVAL (op) == 3"))
+)
+
+;; Allows only 2,4,8 values.  It is used with add/sub shifted operations.
+(define_predicate "_2_4_8_operand"
+  (and (match_code "const_int")
+       (match_test "INTVAL (op) == 2 || INTVAL (op) == 4 || INTVAL (op) == 8"))
+)
+
+;; Return TRUE if OP can be used as a destination for any move
+;; (mov,st,ld) instruction.
+(define_predicate "arc64_dest_operand"
+  (match_code "reg, subreg, mem")
+  {
+   if (MEM_P (op))
+      return arc64_legitimate_store_address_p (mode, XEXP (op, 0));
+   return nonimmediate_operand (op, mode);
+  })
+
+(define_predicate "mem_noofs_operand"
+  (and (match_code "mem")
+       (match_code "reg" "0")))
+
+;; Used by vector floating point instructions.
+(define_predicate "arc64_fsimd_register"
+  (match_code "reg,subreg")
+  {
+    if (GET_CODE (op) == SUBREG)
+      op = SUBREG_REG (op);
+
+    if (REGNO (op) >= FIRST_PSEUDO_REGISTER)
+      return 1;
+
+    /* Check if it is a register. */
+    if (!REG_P (op))
+      return 0;
+
+    /* FIXME! check: REGNO_REG_CLASS (REGNO (op)) != FP_REGS */
+
+    /* Return true/false depending on the SIMD length.  */
+    switch (mode)
+      {
+	/* All vector modes equal with the size of a fp-register.  */
+      case E_V2SFmode:
+      case E_V4HFmode:
+      case E_V2HFmode:
+	return 1;
+
+	/* All vector modes double the size of a fp-register.  */
+      case E_V8HFmode:
+      case E_V4SFmode:
+      case E_V2DFmode:
+	return (ARC64_VFP_128 && ((REGNO (op) & 0x01) == 0));
+
+      default:
+	gcc_unreachable ();
+      }
+  })
+
+(define_predicate "arc64_fsimd_moperand"
+  (ior (match_operand 0 "arc64_fsimd_register")
+       (match_operand 0 "memory_operand")))
+
+(define_predicate "short_immediate_operand"
+  (and (match_code "const_int")
+       (match_test "SIGNED_INT16 (INTVAL (op))")))
+
+(define_predicate "unsign_immediate_operand"
+  (and (match_code "const_int")
+       (match_test "UNSIGNED_INT16 (INTVAL (op))")))
diff --git a/gcc/config/arc64/t-arc64 b/gcc/config/arc64/t-arc64
new file mode 100644
index 00000000000..f3656a45bcd
--- /dev/null
+++ b/gcc/config/arc64/t-arc64
@@ -0,0 +1,25 @@
+# GCC Makefile fragment for Synopsys ARC64.
+#
+# Copyright (C) 2020 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it under the
+# terms of the GNU General Public License as published by the Free Software
+# Foundation; either version 3, or (at your option) any later version.
+#
+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+# details.
+#
+# You should have received a copy of the GNU General Public License along
+# with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+TM_H += $(srcdir)/config/arc64/arc64-c.def
+
+arc64-c.o: $(srcdir)/config/arc64/arc64-c.c $(CONFIG_H) $(SYSTEM_H) \
+$(TREE_H) $(TM_H) $(TM_P_H) coretypes.h
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+		$(srcdir)/config/arc64/arc64-c.c
diff --git a/gcc/config/arc64/t-multilib b/gcc/config/arc64/t-multilib
new file mode 100644
index 00000000000..635daa82856
--- /dev/null
+++ b/gcc/config/arc64/t-multilib
@@ -0,0 +1,21 @@
+# Copyright (C) 2021 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 3, or (at your option) any later
+# version.
+#
+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+MULTILIB_OPTIONS = mfpu=fpus/mfpu=fpud/m128
+
+MULTILIB_DIRNAMES = fpus fpud m128
diff --git a/gcc/configure b/gcc/configure
index 8fe9c91fd7c..5c2c94a7db7 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -24690,12 +24690,18 @@ foo:	.long	25
 	tls_first_minor=13
 	tls_as_opt=--fatal-warnings
 	;;
-  arc*-*-*)
+  arc-*-*)
     conftest_s='
 	add_s r0,r0, @foo@tpoff'
 	tls_first_major=2
 	tls_first_minor=23
 	;;
+  arc64-*-*)
+    conftest_s='
+	addl r0,r0, @foo@tpoff'
+	tls_first_major=2
+	tls_first_minor=23
+	;;
   cris-*-*|crisv32-*-*)
     conftest_s='
 	.section ".tdata","awT",@progbits
@@ -28303,9 +28309,9 @@ esac
 # ??? Once 2.11 is released, probably need to add first known working
 # version to the per-target configury.
 case "$cpu_type" in
-  aarch64 | alpha | arc | arm | avr | bfin | cris | csky | i386 | m32c | m68k \
-  | microblaze | mips | nds32 | nios2 | pa | riscv | rs6000 | score | sparc \
-  | tilegx | tilepro | visium | xstormy16 | xtensa)
+  aarch64 | alpha | arc | arc64 | arm | avr | bfin | cris | csky | i386 | m32c \
+  | m68k | microblaze | mips | nds32 | nios2 | pa | riscv | rs6000 | score \
+  | sparc | tilegx | tilepro | visium | xstormy16 | xtensa)
     insn="nop"
     ;;
   ia64 | s390)
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 84dceb8074a..9f7ab193e3a 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -3452,12 +3452,18 @@ foo:	.long	25
 	tls_first_minor=13
 	tls_as_opt=--fatal-warnings
 	;;
-  arc*-*-*)
+  arc-*-*)
     conftest_s='
 	add_s r0,r0, @foo@tpoff'
 	tls_first_major=2
 	tls_first_minor=23
 	;;
+  arc64-*-*)
+    conftest_s='
+	addl r0,r0, @foo@tpoff'
+	tls_first_major=2
+	tls_first_minor=23
+	;;
   cris-*-*|crisv32-*-*)
     conftest_s='
 	.section ".tdata","awT",@progbits
@@ -5141,9 +5147,9 @@ esac
 # ??? Once 2.11 is released, probably need to add first known working
 # version to the per-target configury.
 case "$cpu_type" in
-  aarch64 | alpha | arc | arm | avr | bfin | cris | csky | i386 | m32c | m68k \
-  | microblaze | mips | nds32 | nios2 | pa | riscv | rs6000 | score | sparc \
-  | tilegx | tilepro | visium | xstormy16 | xtensa)
+  aarch64 | alpha | arc |arc64 | arm | avr | bfin | cris | csky | i386 | m32c \
+  | m68k | microblaze | mips | nds32 | nios2 | pa | riscv | rs6000 | score \
+  | sparc | tilegx | tilepro | visium | xstormy16 | xtensa)
     insn="nop"
     ;;
   ia64 | s390)
diff --git a/gcc/testsuite/gcc.c-torture/execute/20101011-1.c b/gcc/testsuite/gcc.c-torture/execute/20101011-1.c
index 649e168e0b1..7b16e13e1a4 100644
--- a/gcc/testsuite/gcc.c-torture/execute/20101011-1.c
+++ b/gcc/testsuite/gcc.c-torture/execute/20101011-1.c
@@ -62,7 +62,7 @@
 /* By default we emit a sequence with DIVU, which "never signals an
    exceptional condition, even when dividing by zero".  */
 # define DO_TEST 0
-#elif defined (__arc__)
+#elif defined (__arc__) || defined (__ARC64__)
   /* No SIGFPE for ARC integer division.  */
 # define DO_TEST 0
 #elif defined (__arm__) && defined (__ARM_EABI__)
diff --git a/gcc/testsuite/gcc.dg/builtin-apply2.c b/gcc/testsuite/gcc.dg/builtin-apply2.c
index 06ef24ef56b..0dc51c14b76 100644
--- a/gcc/testsuite/gcc.dg/builtin-apply2.c
+++ b/gcc/testsuite/gcc.dg/builtin-apply2.c
@@ -1,7 +1,7 @@
 /* { dg-do run } */
 /* { dg-require-effective-target untyped_assembly } */
 /* { dg-skip-if "Variadic funcs have all args on stack. Normal funcs have args in registers." { "avr-*-* nds32*-*-* amdgcn-*-*" } } */
-/* { dg-skip-if "Variadic funcs use different argument passing from normal funcs." { "riscv*-*-* or1k*-*-* msp430-*-* pru-*-*" } } */
+/* { dg-skip-if "Variadic funcs use different argument passing from normal funcs." { "arc64*-*-* riscv*-*-* or1k*-*-* msp430-*-* pru-*-*" } } */
 /* { dg-skip-if "Variadic funcs use Base AAPCS.  Normal funcs use VFP variant." { arm*-*-* && arm_hf_eabi } } */
 
 /* PR target/12503 */
diff --git a/gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c b/gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c
index 31585a0ae69..52bfd1929f2 100644
--- a/gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c
+++ b/gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c
@@ -9,7 +9,7 @@
 /* arm_hf_eabi: Variadic funcs use Base AAPCS.  Normal funcs use VFP variant.
    avr: Variadic funcs don't pass arguments in registers, while normal funcs
         do.  */
-/* { dg-skip-if "Variadic funcs use different argument passing from normal funcs" { arm_hf_eabi || { avr-*-* riscv*-*-* or1k*-*-* msp430-*-* amdgcn-*-* pru-*-* } } } */
+/* { dg-skip-if "Variadic funcs use different argument passing from normal funcs" { arm_hf_eabi || { arc64-*-* avr-*-* riscv*-*-* or1k*-*-* msp430-*-* amdgcn-*-* pru-*-* } } } */
 /* { dg-skip-if "Variadic funcs have all args on stack. Normal funcs have args in registers." { nds32*-*-* } { v850*-*-* } } */
 /* { dg-require-effective-target untyped_assembly } */
    
diff --git a/gcc/testsuite/gcc.dg/torture/vshuf-4.inc b/gcc/testsuite/gcc.dg/torture/vshuf-4.inc
index d041b33871b..309671ace09 100644
--- a/gcc/testsuite/gcc.dg/torture/vshuf-4.inc
+++ b/gcc/testsuite/gcc.dg/torture/vshuf-4.inc
@@ -137,4 +137,18 @@ T (223,	0, 5, 3, 4) \
 T (224,	2, 3, 1, 4) \
 T (225,	2, 3, 5, 1) \
 T (226,	4, 3, 1, 0) \
-T (227,	2, 3, 5, 5)
+T (227,	2, 3, 5, 5) \
+T (228,	1, 1, 1, 1) \
+T (229,	2, 2, 2, 2) \
+T (230,	3, 3, 3, 3) \
+T (231,	0, 2, 0, 2) \
+T (232,	0, 2, 4, 6) \
+T (233,	1, 3, 1, 3) \
+T (234,	1, 3, 5, 7) \
+T (235,	4, 6, 0, 2) \
+T (236,	5, 7, 1, 3) \
+T (237,	1, 0, 3, 2) \
+T (238,	0, 1, 0, 1) \
+T (239,	2, 3, 2, 3) \
+T (240,	2, 3, 6, 7) \
+
diff --git a/gcc/testsuite/gcc.target/arc/arc.exp b/gcc/testsuite/gcc.target/arc/arc.exp
index 501d4589c53..ffec8138d81 100644
--- a/gcc/testsuite/gcc.target/arc/arc.exp
+++ b/gcc/testsuite/gcc.target/arc/arc.exp
@@ -17,7 +17,7 @@
 # GCC testsuite that uses the `dg.exp' driver.
 
 # Exit immediately if this isn't an arc target.
-if ![istarget arc*-*-*] then {
+if { ![istarget arc-*-*] && ![istarget arceb-*-*] } then {
   return
 }
 
diff --git a/gcc/testsuite/gcc.target/arc64/addsubx-1.c b/gcc/testsuite/gcc.target/arc64/addsubx-1.c
new file mode 100644
index 00000000000..348f4596518
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/addsubx-1.c
@@ -0,0 +1,38 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+/* Checks if the compiler generates shifted adds and subs.  */
+
+int foo (int a, int b)
+{
+  return a + (b << 1);
+}
+
+long int bar (long int a, long int b)
+{
+  return a + (b << 1);
+}
+
+int minus1 (int a, int b)
+{
+  return a - (b << 1);
+}
+
+long int minus1l (long int a, long int b)
+{
+  return a - (b << 1);
+}
+
+int plus1 (int a, int b)
+{
+  int x = a + (b << 3);
+  if (x != 0)
+    return x;
+  return 20;
+}
+
+/* { dg-final { scan-assembler "add1_s\\s+" } } */
+/* { dg-final { scan-assembler "add1l\\s+" } } */
+/* { dg-final { scan-assembler "sub1\\s+" } } */
+/* { dg-final { scan-assembler "sub1l\\s+" } } */
+/* { dg-final { scan-assembler "add3\\.f\\s+" } } */
diff --git a/gcc/testsuite/gcc.target/arc/arc.exp b/gcc/testsuite/gcc.target/arc64/arc64.exp
similarity index 88%
copy from gcc/testsuite/gcc.target/arc/arc.exp
copy to gcc/testsuite/gcc.target/arc64/arc64.exp
index 501d4589c53..8230ad5eba9 100644
--- a/gcc/testsuite/gcc.target/arc/arc.exp
+++ b/gcc/testsuite/gcc.target/arc64/arc64.exp
@@ -1,4 +1,4 @@
-# Copyright (C) 2007-2020 Free Software Foundation, Inc.
+# Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -89,21 +89,19 @@ proc check_effective_target_clmcpu { } {
 proc check_effective_target_barrelshifter { } {
     return [check_no_compiler_messages barrelshifter assembly {
 	#if !defined(__ARC_BARREL_SHIFTER__)
-	#error No barrel shifter for this confi
+	#error No barrel shifter for this config
 	#endif
     }]
 }
 
-#return 1 if we have code density option on.
 proc check_effective_target_codedensity { } {
     return [check_no_compiler_messages codedensity assembly {
-        #if !defined(__ARC_CODE_DENSITY__)
-        #error No code density option for this config
-        #endif
+	#if !defined(__ARC_CODE_DENSITY__)
+	#error No code density option for this config
+	#endif
     }]
 }
 
-
 #return 1 if we use ARCv2 Accumulator registers
 proc check_effective_target_accregs { } {
     return [check_no_compiler_messages accregs assembly {
@@ -122,15 +120,6 @@ proc check_effective_target_dpfp { } {
     }]
 }
 
-# Return 1 if this is a compiler supporting LL64 option.
-proc check_effective_target_ll64 { } {
-    return [check_no_compiler_messages ll64 assembly {
-	#if !defined(__ARC_LL64__)
-	#error No ARC LL64
-	#endif
-    }]
-}
-
 # If a testcase doesn't have special options, use these.
 global DEFAULT_CFLAGS
 if ![info exists DEFAULT_CFLAGS] then {
diff --git a/gcc/testsuite/gcc.target/arc64/movd-1.c b/gcc/testsuite/gcc.target/arc64/movd-1.c
new file mode 100644
index 00000000000..ba9920bd2f8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movd-1.c
@@ -0,0 +1,38 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+
+/* "movdi" is about assigning 32-bit of data (byte).  *
+ *                                                    *
+ * This is one of the tests in series of testing for  *
+ * "movdi" support. The test scenarios are as the     *
+ * following table:                                   *
+ *                                                    *
+ * ,--------.----------.----------.-----------------. *
+ * | test   | notation | dest.    | source          | *
+ * |--------|---------------------------------------| *
+ * | movd-1 | r <- i   | register | immediate       | *
+ * | movd-2 | r <- r   |          | register        | *
+ * | movd-3 | r <- m   |          | memory          | *
+ * |--------+----------+----------+-----------------| *
+ * | movd-4 | m <- r   |          | register        | *
+ * | movd-5 | m <- i   | memroy   | immediate small | *
+ * | movd-6 | m <- I   |          | immediate big   | *
+ * | movd-7 | m <- m   |          | memory          | *
+ * `--------^----------^----------^-----------------' */
+
+/* assign immediate to register */
+volatile int dummy;
+void foo(void)
+{
+  volatile register int dst;
+  dst = 0x12344321;
+  dst = 0x40000000;
+  dst = 0x7FFFFFFF;   /* largest positive number in 32-bit */
+  dst = -2147483648;  /* smallest negative number in 32-bit */
+  dst = 0xFFFFFFFF;  /* -1 */
+  dummy = dst;
+}
+/* { dg-final { scan-assembler "mov_s\\s+r\[0-9\]+,305414945" } } */
+/* { dg-final { scan-assembler "mov_s\\s+r\[0-9\]+,1073741824" } } */
+/* { dg-final { scan-assembler "mov_s\\s+r\[0-9\]+,2147483647" } } */
+/* { dg-final { scan-assembler "mov_s\\s+r\[0-9\]+,-2147483648" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movd-2.c b/gcc/testsuite/gcc.target/arc64/movd-2.c
new file mode 100644
index 00000000000..43e786d3c09
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movd-2.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+/* check "movd-1.c" for further details. */
+
+/* assign a register to register */
+int foo(int a, int b)
+{
+  return b;
+}
+/* { dg-final { scan-assembler "mov_s\\s+r\[0-9\]+,r\[0-9\]+" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movd-3.c b/gcc/testsuite/gcc.target/arc64/movd-3.c
new file mode 100644
index 00000000000..11d0259722f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movd-3.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+
+/* check "movd-1.c" for further details. */
+
+/* assign memory to register */
+volatile int mem;
+void foo(void)
+{
+  register int dst = mem;
+}
+/* { dg-final { scan-assembler "ld_s\\s+r\[0-9\]+,\\\[" } } */
+
diff --git a/gcc/testsuite/gcc.target/arc64/movd-4.c b/gcc/testsuite/gcc.target/arc64/movd-4.c
new file mode 100644
index 00000000000..c62642e521b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movd-4.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+
+/* check "movd-1.c" for further details. */
+
+/* register to memory */
+int mem;
+void foo(void)
+{
+  register int reg_int;
+  mem = reg_int;
+}
+/* { dg-final { scan-assembler "st_s\\s+r\[0-9\]+,\\\[" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movd-5.c b/gcc/testsuite/gcc.target/arc64/movd-5.c
new file mode 100644
index 00000000000..eed0f346e29
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movd-5.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+
+/* check "movd-1.c" for further details. */
+
+/* assign immediate to a memory: this immediate is small *
+ * enough to be covered by w6 (signed 6 bit number).     */
+int mem;
+void foo(void)
+{
+  mem = 0x00;    /* the usual suspect: 0 */
+  mem =  31;     /* largest positive number in w6 */
+  mem = -32;     /* smallest negative number in w6 */
+  mem = -1;      /* just a -1 (all bits 1) */
+}
+/* { dg-final { scan-assembler "st\\s+0,\\\[" } } */
+/* { dg-final { scan-assembler "st\\s+31,\\\[" } } */
+/* { dg-final { scan-assembler "st\\s+-32,\\\[" } } */
+/* { dg-final { scan-assembler "st\\s+-1,\\\[" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movd-6.c b/gcc/testsuite/gcc.target/arc64/movd-6.c
new file mode 100644
index 00000000000..c69ea021448
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movd-6.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+
+/* check "movd-1.c" for further details. */
+
+/* assign immediate to a memory: this immediate cannot be   *
+ * represented by 6-bit, hence stb w6, mem is not an option */
+int mem;
+void foo(void)
+{
+  mem = 0x40;    /* smallest 7-bit number */
+  mem = 0x7F;    /* largest  7-bit number */
+  mem = 0x80;    /* 128 */
+  mem = -128;    /* smallest 8-bit number */
+  mem = -33;     /* first negative number outside w6's range. else,
+                    it would use something like 'sth -32, [@mem]'  */
+}
+/* { dg-final { scan-assembler "mov_s\\s+r\\d,64" } } */
+/* { dg-final { scan-assembler "mov_s\\s+r\\d,127" } } */
+/* { dg-final { scan-assembler "mov_s\\s+r\\d,128" } } */
+/* { dg-final { scan-assembler "mov\\s+r\\d,-128" } } */
+/* { dg-final { scan-assembler "mov\\s+r\\d,-33" } } */
+/* { dg-final { scan-assembler-times "st_s\\s+r\\d,\\\[" 5 } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movd-7.c b/gcc/testsuite/gcc.target/arc64/movd-7.c
new file mode 100644
index 00000000000..d1539d0b22d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movd-7.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -fomit-frame-pointer" } */
+
+/* check "movd-1.c" for further details. */
+
+/* assign memory to a memory */
+int mem_dst, mem_src;
+void foo(void)
+{
+  mem_dst = mem_src;
+}
+/* { dg-final { scan-assembler "ld\\s+r\[0-9\]+,\\\[" } } */
+/* { dg-final { scan-assembler-not "ext\[bhw\]\\s+" } } */
+/* { dg-final { scan-assembler "st_s\\s+r\\d,\\\[" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movh-1.c b/gcc/testsuite/gcc.target/arc64/movh-1.c
new file mode 100644
index 00000000000..4667f357af7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movh-1.c
@@ -0,0 +1,40 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+
+/* "movhi" is about assigning 16-bit of data (byte).  *
+ *                                                    *
+ * This is one of the tests in series of testing for  *
+ * "movhi" support. The test scenarios are as the     *
+ * following table:                                   *
+ *                                                    *
+ * ,--------.----------.----------.-----------------. *
+ * | test   | notation | dest.    | source          | *
+ * |--------|---------------------------------------| *
+ * | movh-1 | r <- i   | register | immediate       | *
+ * | movh-2 | r <- r   |          | register        | *
+ * | movh-3 | r <- m   |          | memory          | *
+ * |--------+----------+----------+-----------------| *
+ * | movh-4 | m <- r   |          | register        | *
+ * | movh-5 | m <- i   | memroy   | immediate small | *
+ * | movh-6 | m <- I   |          | immediate big   | *
+ * | movh-7 | m <- m   |          | memory          | *
+ * | movh-8 | m <- m   | volatile causes sex, why?  | *
+ * `--------^----------^----------^-----------------' */
+
+/* assign immediate to register */
+volatile short dummy;
+void foo(void)
+{
+  volatile register short dst;
+  dst = 0x1234;
+  dst = 0x4000;
+  dst = 0x7FFF;  /* largest positive number in short */
+  dst = -32768;  /* smallest negative number in short */
+  dst = 0xFFFF;  /* -1 */
+  dummy = dst;
+}
+/* { dg-final { scan-assembler "mov_s\\s+r\[0-9\]+,4660" } } */
+/* { dg-final { scan-assembler "mov_s\\s+r\[0-9\]+,16384" } } */
+/* { dg-final { scan-assembler "mov_s\\s+r\[0-9\]+,32767" } } */
+/* { dg-final { scan-assembler "mov_s\\s+r\[0-9\]+,-32768" } } */
+/* { dg-final { scan-assembler "sth\.as\\s+-1,\\\[" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movh-2.c b/gcc/testsuite/gcc.target/arc64/movh-2.c
new file mode 100644
index 00000000000..b0780523a22
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movh-2.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+/* check "movh-1.c" for further details. */
+
+/* assign a register to register */
+short foo(short a, short b)
+{
+  return b;
+}
+/* { dg-final { scan-assembler "sexh_s\\s+r\[0-9\]+,r\[0-9\]+" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movh-3.c b/gcc/testsuite/gcc.target/arc64/movh-3.c
new file mode 100644
index 00000000000..b63ca7a67f1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movh-3.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+
+/* check "movh-1.c" for further details. */
+
+/* assign memory to register */
+volatile short mem;
+void foo(void)
+{
+  register short dst = mem;
+}
+/* { dg-final { scan-assembler "ldh_s\\s+r\[0-9\]+,\\\[" } } */
+
diff --git a/gcc/testsuite/gcc.target/arc64/movh-4.c b/gcc/testsuite/gcc.target/arc64/movh-4.c
new file mode 100644
index 00000000000..4e64f6657f0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movh-4.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+
+/* check "movh-1.c" for further details. */
+
+/* register to memory */
+short mem;
+void foo(void)
+{
+  register short reg_short;
+  mem = reg_short;
+}
+/* { dg-final { scan-assembler "sth_s\\s+r\[0-9\]+,\\\[" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movh-5.c b/gcc/testsuite/gcc.target/arc64/movh-5.c
new file mode 100644
index 00000000000..25c64ae3c19
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movh-5.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+
+/* check "movh-1.c" for further details. */
+
+/* assign immediate to a memory: this immediate is small *
+ * enough to be covered by w6 (signed 6 bit number).     */
+short mem;
+void foo(void)
+{
+  mem = 0x00;    /* the usual suspect: 0 */
+  mem =  31;     /* largest positive number in w6 */
+  mem = -32;     /* smallest negative number in w6 */
+  mem = -1;      /* just a -1 (all bits 1) */
+}
+/* { dg-final { scan-assembler "sth\\s+0,\\\[" } } */
+/* { dg-final { scan-assembler "sth\\s+31,\\\[" } } */
+/* { dg-final { scan-assembler "sth\\s+-32,\\\[" } } */
+/* { dg-final { scan-assembler "sth\\s+-1,\\\[" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movh-6.c b/gcc/testsuite/gcc.target/arc64/movh-6.c
new file mode 100644
index 00000000000..6fd79d246b8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movh-6.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+
+/* check "movh-1.c" for further details. */
+
+/* assign immediate to a memory: this immediate cannot be   *
+ * represented by 6-bit, hence stb w6, mem is not an option */
+short mem;
+void foo(void)
+{
+  mem = 0x40;    /* smallest 7-bit number */
+  mem = 0x7F;    /* largest  7-bit number */
+  mem = 0x80;    /* 128 */
+  mem = -128;    /* smallest 8-bit number */
+  mem = -33;     /* first negative number outside w6's range. else,
+                    it would use something like 'sth -32, [@mem]'  */
+}
+/* { dg-final { scan-assembler "mov_s\\s+r\\d,64" } } */
+/* { dg-final { scan-assembler "mov_s\\s+r\\d,127" } } */
+/* { dg-final { scan-assembler "mov_s\\s+r\\d,128" } } */
+/* { dg-final { scan-assembler "mov\\s+r\\d,-128" } } */
+/* { dg-final { scan-assembler "mov\\s+r\\d,-33" } } */
+/* { dg-final { scan-assembler-times "sth_s\\s+r\\d,\\\[" 5 } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movh-7.c b/gcc/testsuite/gcc.target/arc64/movh-7.c
new file mode 100644
index 00000000000..fd0fb7608e5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movh-7.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -fomit-frame-pointer" } */
+
+/* check "movh-1.c" for further details. */
+
+/* assign memory to a memory */
+short mem_dst, mem_src;
+void foo(void)
+{
+  mem_dst = mem_src;
+}
+/* { dg-final { scan-assembler "ldh\\s+r\[0-9\]+,\\\[" } } */
+/* { dg-final { scan-assembler-not "ext\[bhw\]\\s+" } } */
+/* { dg-final { scan-assembler "sth_s\\s+r\\d,\\\[" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movh-8.c b/gcc/testsuite/gcc.target/arc64/movh-8.c
new file mode 100644
index 00000000000..2bd80f5a9f3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movh-8.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -fomit-frame-pointer" } */
+
+/* check "movh-1.c" for further details. */
+
+/* FIXME: with a 'volatile' this test generates an unnecessary sexh */
+/* assign memory to a memory */
+volatile short mem_dst, mem_src;
+void foo(void)
+{
+  mem_dst = mem_src;
+}
+/* { dg-final { scan-assembler "ldh\\s+r\[0-9\]+,\\\[" } } */
+/* { dg-final { scan-assembler-not "sexh" } } */
+/* { dg-final { scan-assembler "sth_s\\s+r\\d,\\\[" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movh-9.c b/gcc/testsuite/gcc.target/arc64/movh-9.c
new file mode 100644
index 00000000000..6d69a8f335c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movh-9.c
@@ -0,0 +1,31 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -fomit-frame-pointer" } */
+
+/* "movqi" is about assigning 8-bit of data (byte).   *
+ *                                                    *
+ * This is one of the tests in series of testing for  *
+ * "movqi" support. The test scenarios are as the     *
+ * following table:                                   *
+ *                                                    *
+ * ,--------.----------.----------.-----------------. *
+ * | test   | notation | dest.    | source          | *
+ * |--------|---------------------------------------| *
+ * | movq-1 | r <- i   | register | immediate       | *
+ * | movq-2 | r <- r   |          | register        | *
+ * | movq-3 | r <- m   |          | memory          | *
+ * |--------+----------+----------+-----------------| *
+ * | movq-4 | m <- r   |          | register        | *
+ * | movq-5 | m <- i   | memroy   | immediate small | *
+ * | movq-6 | m <- I   |          | immediate big   | *
+ * | movq-7 | m <- m   |          | memory          | *
+ * `--------^----------^----------^-----------------' */
+
+/* FIXME: this test fails trying to assign memory to memory directly */
+/* assign memory to a memory */
+char mem_dst, mem_src;
+void foo(void)
+{
+  mem_dst = mem_src;
+}
+/* { dg-final { scan-assembler "ldb\\s+r\[0-9\]+,\\\[" } } */
+/* { dg-final { scan-assembler "stb_s\\s+r\\d,\\\[" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movq-1.c b/gcc/testsuite/gcc.target/arc64/movq-1.c
new file mode 100644
index 00000000000..3ea1c665cf9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movq-1.c
@@ -0,0 +1,42 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+
+/* "movqi" is about assigning 8-bit of data (byte).   *
+ *                                                    *
+ * This is one of the tests in series of testing for  *
+ * "movqi" support. The test scenarios are as the     *
+ * following table:                                   *
+ *                                                    *
+ * ,--------.----------.----------.-----------------. *
+ * | test   | notation | dest.    | source          | *
+ * |--------|---------------------------------------| *
+ * | movq-1 | r <- i   | register | immediate       | *
+ * | movq-2 | r <- r   |          | register        | *
+ * | movq-3 | r <- m   |          | memory          | *
+ * |--------+----------+----------+-----------------| *
+ * | movq-4 | m <- r   |          | register        | *
+ * | movq-5 | m <- i   | memroy   | immediate small | *
+ * | movq-6 | m <- I   |          | immediate big   | *
+ * | movq-7 | m <- m   |          | memory          | *
+ * | movq-8 | m <- m   | volatile causes ext, why?  | *
+ * `--------^----------^----------^-----------------' */
+
+/* assign immediate to register */
+volatile char dummy;
+void foo(void)
+{
+  volatile register char dst;
+  dst = 0x0;
+  dst = 0x22;
+  dst = 0x40;
+  dst = 0x80;
+  dst = -128;
+  dst = 0xFF;
+  dummy = dst;
+}
+/* { dg-final { scan-assembler "stb\\s+0,\\\[" } } */
+/* { dg-final { scan-assembler "mov_s\\s+r\\d,34" } } */
+/* { dg-final { scan-assembler "mov_s\\s+r\\d,64" } } */
+/* expecting "mov_s r0,128" twice to cover both dst=-/+128 */
+/* { dg-final { scan-assembler-times "mov\\s+r\\d,-128" 2 } } */
+/* { dg-final { scan-assembler "stb\\s+-1,\\\[" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movq-2.c b/gcc/testsuite/gcc.target/arc64/movq-2.c
new file mode 100644
index 00000000000..78515c1f63b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movq-2.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+/* check "movq-1.c" for further details. */
+
+/* assign a register to register */
+char foo(char a, char b)
+{
+  return b;
+}
+/* { dg-final { scan-assembler "extb_s\\s+r\\d+,r\\d+" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movq-3.c b/gcc/testsuite/gcc.target/arc64/movq-3.c
new file mode 100644
index 00000000000..cc129fb5237
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movq-3.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+
+/* check "movq-1.c" for further details. */
+
+/* assign memory to register */
+volatile char mem;
+void foo(void)
+{
+  register char dst = mem;
+}
+/* { dg-final { scan-assembler "ldb_s\\s+r\[0-9\]+,\\\[" } } */
+
diff --git a/gcc/testsuite/gcc.target/arc64/movq-4.c b/gcc/testsuite/gcc.target/arc64/movq-4.c
new file mode 100644
index 00000000000..7d477084672
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movq-4.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+
+/* check "movq-1.c" for further details. */
+
+/* register to memory */
+char mem;
+void foo(void)
+{
+  register char reg_char;
+  mem = reg_char;
+}
+/* { dg-final { scan-assembler "stb_s\\s+r\[0-9\]+,\\\[" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movq-5.c b/gcc/testsuite/gcc.target/arc64/movq-5.c
new file mode 100644
index 00000000000..8546af11832
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movq-5.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+
+/* check "movq-1.c" for further details. */
+
+/* assign immediate to a memory: this immediate is small *
+ * enough to be covered by w6 (signed 6 bit number).     */
+volatile char mem;
+void foo(void)
+{
+  mem = 0x00;    /* the usual suspect: 0 */
+  mem =  31;     /* largest positive number in w6 */
+  mem = -32;     /* smallest negative number in w6 */
+  mem = -1;      /* just a -1 (all bits 1) */
+}
+/* { dg-final { scan-assembler "stb\\s+0,\\\[" } } */
+/* { dg-final { scan-assembler "stb\\s+31,\\\[" } } */
+/* { dg-final { scan-assembler "stb\\s+-32,\\\[" } } */
+/* { dg-final { scan-assembler "stb\\s+-1,\\\[" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movq-6.c b/gcc/testsuite/gcc.target/arc64/movq-6.c
new file mode 100644
index 00000000000..17d8546179a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movq-6.c
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+
+/* check "movq-1.c" for further details. */
+
+/* assign immediate to a memory: this immediate cannot be   *
+ * represented by 6-bit, hence stb w6, mem is not an option */
+char mem;
+void foo(void)
+{
+  mem = 0x40;    /* smallest 7-bit number */
+  mem = 0x7F;    /* largest  7-bit number */
+  mem = 0x80;    /* 128 */
+  mem = -128;    /* smallest 8-bit number */
+  mem = -33;     /* first negative number outside w6's range. else,
+                    it would use something like 'stb -32, [@mem]'  */
+}
+/* { dg-final { scan-assembler "mov_s\\s+r\\d,64" } } */
+/* { dg-final { scan-assembler "mov_s\\s+r\\d,127" } } */
+/* { dg-final { scan-assembler-times "mov\\s+r\\d,-128" 2 } } */
+/* { dg-final { scan-assembler "mov\\s+r\\d,-33" } } */
+/* { dg-final { scan-assembler-times "stb_s\\s+r\\d,\\\[" 5 } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movq-7.c b/gcc/testsuite/gcc.target/arc64/movq-7.c
new file mode 100644
index 00000000000..d0a6b631fa1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movq-7.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -fomit-frame-pointer" } */
+
+/* check "movq-1.c" for further details. */
+
+/* assign memory to a memory */
+char mem_dst, mem_src;
+void foo(void)
+{
+  mem_dst = mem_src;
+}
+/* { dg-final { scan-assembler "ldb\\s+r\[0-9\]+,\\\[" } } */
+/* { dg-final { scan-assembler-not "ext\[bhw\]\\s+" } } */
+/* { dg-final { scan-assembler "stb_s\\s+r\\d,\\\[" } } */
diff --git a/gcc/testsuite/gcc.target/arc64/movq-8.c b/gcc/testsuite/gcc.target/arc64/movq-8.c
new file mode 100644
index 00000000000..5a1cd5fefbd
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc64/movq-8.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+
+/* check "movq-1.c" for further details. */
+
+/* FIXME: with a 'volatile' this test generates an unnecessary extb */
+/* assign memory to a memory */
+volatile char mem_dst, mem_src;
+void foo(void)
+{
+  mem_dst = mem_src;
+}
+/* { dg-final { scan-assembler "ldb_s\\s+r\[0-9\]+,\\\[" } } */
+/* { dg-final { scan-assembler "stb_s\\s+r\\d,\\\[" } } */
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index bd62a0d9e79..a3df550394b 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -753,6 +753,10 @@ proc check_effective_target_freestanding { } {
 
 # Check to see that file I/O functions are available.
 proc check_effective_target_fileio { } {
+    if { [istarget arc64-*-*] } {
+	return 0
+    }
+
     return [check_no_compiler_messages fileio_available executable {
 #include <stdio.h>
 int main() {
@@ -3553,6 +3557,15 @@ proc check_effective_target_arc_atomic { } {
     }]
 }
 
+# Return 1 if this is a compiler supporting ARC atomic operations
+proc check_effective_target_arc64_atomic { } {
+    return [check_no_compiler_messages arc_atomic assembly {
+	#if !defined(__ARC64_ATOMIC__)
+	#error NO_ATOMIC64
+	#endif
+    }]
+}
+
 # Return 1 if this is an arm target using 32-bit instructions
 proc check_effective_target_arm32 { } {
     if { ![istarget arm*-*-*] } {
@@ -7543,6 +7556,7 @@ proc check_effective_target_sync_int_128_runtime { } {
 proc check_effective_target_sync_long_long { } {
     if { [istarget i?86-*-*] || [istarget x86_64-*-*])
 	 || [istarget aarch64*-*-*]
+	 || ([istarget arc64-*-*] && [check_effective_target_arc64_atomic])
 	 || [istarget arm*-*-*]
 	 || [istarget alpha*-*-*]
 	 || ([istarget sparc*-*-*] && [check_effective_target_lp64])
@@ -7607,6 +7621,7 @@ proc check_effective_target_sync_long_long_runtime { } {
 	      } ""
 	  }])
 	 || [istarget aarch64*-*-*]
+	 || ([istarget arc64-*-*] && [check_effective_target_arc64_atomic])
 	 || [istarget arm*-*-uclinuxfdpiceabi]
 	 || ([istarget arm*-*-linux-*]
 	     && [check_runtime sync_longlong_runtime {
@@ -7676,6 +7691,7 @@ proc check_effective_target_sync_int_long { } {
 	     || [istarget powerpc*-*-*]
 	     || [istarget crisv32-*-*] || [istarget cris-*-*]
 	     || ([istarget sparc*-*-*] && [check_effective_target_sparc_v9])
+	     || ([istarget arc64-*-*] && [check_effective_target_arc64_atomic])
 	     || ([istarget arc*-*-*] && [check_effective_target_arc_atomic])
 	     || [check_effective_target_mips_llsc] }}]
 }
@@ -7699,7 +7715,9 @@ proc check_effective_target_sync_char_short { } {
 	     || [istarget powerpc*-*-*]
 	     || [istarget crisv32-*-*] || [istarget cris-*-*]
 	     || ([istarget sparc*-*-*] && [check_effective_target_sparc_v9])
-	     || ([istarget arc*-*-*] && [check_effective_target_arc_atomic])
+	     || ([istarget arc64-*-*] && [check_effective_target_arc64_atomic])
+	     || ([istarget arc-*-*] && [check_effective_target_arc_atomic])
+	     || ([istarget arceb-*-*] && [check_effective_target_arc_atomic])
 	     || [check_effective_target_mips_llsc] }}]
 }
 
diff --git a/libgcc/config.host b/libgcc/config.host
index c529cc40f0c..4c1230c69b8 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -95,9 +95,12 @@ amdgcn*-*-*)
 	cpu_type=gcn
 	tmake_file="${tmake_file} t-softfp-sfdf t-softfp"
 	;;
-arc*-*-*)
+arc-*-* | arceb-*-*)
 	cpu_type=arc
 	;;
+arc64-*-*)
+	cpu_type=arc64
+	;;
 arm*-*-*)
 	cpu_type=arm
 	;;
@@ -427,17 +430,25 @@ amdgcn*-*-amdhsa)
 	tmake_file="$tmake_file gcn/t-amdgcn"
 	extra_parts="crt0.o"
 	;;
-arc*-*-elf*)
+arc-*-elf* | arceb-*-elf*)
 	tmake_file="arc/t-arc"
 	extra_parts="crti.o crtn.o crtend.o crtbegin.o crtendS.o crtbeginS.o"
 	extra_parts="$extra_parts crttls.o"
 	;;
-arc*-*-linux*)
+arc-*-linux* | arceb-*-linux*)
 	tmake_file="${tmake_file} t-slibgcc-libgcc t-slibgcc-nolc-override arc/t-arc-uClibc arc/t-arc"
 	extra_parts="$extra_parts crti.o crtn.o"
 	extra_parts="$extra_parts crttls.o"
 	md_unwind_header=arc/linux-unwind.h
 	;;
+arc64-*-elf)
+	tmake_file="${tmake_file} arc64/t-arc64 arc64/t-softfp t-softfp t-softfp-sfdf"
+	;;
+arc64-*-linux*)
+	tmake_file="${tmake_file} arc64/t-arc64 arc64/t-softfp t-softfp t-softfp-sfdf"
+	tmake_file="${tmake_file} t-slibgcc-libgcc t-slibgcc-nolc-override"
+	#FIXME! add unwind support md_unwind_header=arc64/linux-unwind.h
+	;;
 arm-wrs-vxworks7*)
 	tmake_file="$tmake_file arm/t-arm arm/t-elf arm/t-bpabi arm/t-vxworks7"
         tmake_file="$tmake_file t-softfp-sfdf t-softfp-excl arm/t-softfp t-softfp"
diff --git a/libgcc/config/arc64/lib2funcs.c b/libgcc/config/arc64/lib2funcs.c
new file mode 100644
index 00000000000..55f0993d0b3
--- /dev/null
+++ b/libgcc/config/arc64/lib2funcs.c
@@ -0,0 +1,151 @@
+/* libgcc routines for ARC64
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+
+typedef          int  sint64_t   __attribute__ ((mode (DI)));
+typedef unsigned int  uint64_t   __attribute__ ((mode (DI)));
+typedef int           word_t     __attribute__ ((mode (__word__)));
+
+
+sint64_t __muldi3 (sint64_t, sint64_t);
+sint64_t __divdi3 (sint64_t, sint64_t);
+sint64_t __moddi3 (sint64_t, sint64_t);
+
+sint64_t
+__muldi3 (sint64_t a, sint64_t b)
+{
+  sint64_t res = 0;
+  uint64_t cnt = a;
+
+  while (cnt)
+    {
+      if (cnt & 1)
+        res += b;
+      b <<= 1;
+      cnt >>= 1;
+    }
+  return res;
+}
+
+/* Unsigned integer division/modulus.  */
+
+static inline __attribute__ ((__always_inline__))
+uint64_t
+udivmoddi4 (uint64_t num, uint64_t den, word_t modwanted)
+{
+  uint64_t bit = 1;
+  uint64_t res = 0;
+
+  while (den < num && bit && !(den & (1LL << 63)))
+    {
+      den <<= 1;
+      bit <<= 1;
+    }
+  while (bit)
+    {
+      if (num >= den)
+	{
+	  num -= den;
+	  res |= bit;
+	}
+      bit >>= 1;
+      den >>= 1;
+    }
+  if (modwanted)
+    return num;
+  return res;
+}
+
+sint64_t
+__divdi3 (sint64_t a, sint64_t b)
+{
+  word_t neg = 0;
+  sint64_t res;
+
+  if (a < 0)
+    {
+      a = -a;
+      neg = !neg;
+    }
+
+  if (b < 0)
+    {
+      b = -b;
+      neg = !neg;
+    }
+
+  res = udivmoddi4 (a, b, 0);
+
+  if (neg)
+    res = -res;
+
+  return res;
+}
+
+sint64_t
+__moddi3 (sint64_t a, sint64_t b)
+{
+  word_t neg = 0;
+  sint64_t res;
+
+  if (a < 0)
+    {
+      a = -a;
+      neg = 1;
+    }
+
+  if (b < 0)
+    b = -b;
+
+  res = udivmoddi4 (a, b, 1);
+
+  if (neg)
+    res = -res;
+
+  return res;
+}
+
+uint64_t
+__udivdi3 (uint64_t a, uint64_t b)
+{
+  return udivmoddi4 (a, b, 0);
+}
+
+uint64_t
+__umoddi3 (uint64_t a, uint64_t b)
+{
+  return udivmoddi4 (a, b, 1);
+}
+
+/* We need 32bit version for some of the functions defined in
+   libgcc2.c.  */
+#define LIBGCC2_UNITS_PER_WORD 4
+
+#define L_clzsi2
+#define L_ctzsi2
+#define L_ffssi2
+#define L_paritysi2
+#define L_popcountsi2
+
+#include "libgcc2.c"
diff --git a/libgcc/config/arc64/sfp-machine.h b/libgcc/config/arc64/sfp-machine.h
new file mode 100644
index 00000000000..433800874e3
--- /dev/null
+++ b/libgcc/config/arc64/sfp-machine.h
@@ -0,0 +1,57 @@
+#define _FP_W_TYPE_SIZE         64
+#define _FP_W_TYPE              unsigned long long
+#define _FP_WS_TYPE             signed long long
+#define _FP_I_TYPE              long long
+
+#define _FP_MUL_MEAT_S(R,X,Y)                                   \
+  _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S,R,X,Y)
+#define _FP_MUL_MEAT_D(R,X,Y)                                   \
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)                                   \
+  _FP_MUL_MEAT_2_wide_3mul(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)   _FP_DIV_MEAT_1_imm(S,R,X,Y,_FP_DIV_HELP_imm)
+#define _FP_DIV_MEAT_D(R,X,Y)   _FP_DIV_MEAT_1_udiv_norm(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)   _FP_DIV_MEAT_2_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_H		_FP_QNANBIT_H
+#define _FP_NANFRAC_S           _FP_QNANBIT_S
+#define _FP_NANFRAC_D           _FP_QNANBIT_D
+#define _FP_NANFRAC_Q           _FP_QNANBIT_Q, 0
+
+typedef int TItype __attribute__ ((mode (TI)));
+typedef unsigned int UTItype __attribute__ ((mode (TI)));
+#define TI_BITS (__CHAR_BIT__ * (int)sizeof(TItype))
+
+/* The type of the result of a floating point comparison.  This must
+   match __libgcc_cmp_return__ in GCC for the target.  */
+typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));
+#define CMPtype __gcc_CMPtype
+
+#define _FP_NANSIGN_H           0
+#define _FP_NANSIGN_S           0
+#define _FP_NANSIGN_D           0
+#define _FP_NANSIGN_Q           0
+
+#define _FP_KEEPNANFRACP 0
+#define _FP_QNANNEGATEDP 0
+
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)      \
+  do {                                          \
+    R##_s = _FP_NANSIGN_##fs;                   \
+    _FP_FRAC_SET_##wc(R,_FP_NANFRAC_##fs);      \
+    R##_c = FP_CLS_NAN;                         \
+  } while (0)
+
+/* Not checked.  */
+#define _FP_TININESS_AFTER_ROUNDING 0
+
+#define __LITTLE_ENDIAN 1234
+#define __BIG_ENDIAN    4321
+
+# define __BYTE_ORDER __LITTLE_ENDIAN
+
+/* Define ALIASNAME as a strong alias for NAME.  */
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# define _strong_alias(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));
diff --git a/libgcc/config/arc64/t-arc64 b/libgcc/config/arc64/t-arc64
new file mode 100644
index 00000000000..aeb982ec088
--- /dev/null
+++ b/libgcc/config/arc64/t-arc64
@@ -0,0 +1,21 @@
+# GCC Makefile fragment for Synopsys DesignWare ARC
+
+# Copyright (C) 2019 Free Software Foundation, Inc.
+
+# This file is part of GCC.
+
+# GCC is free software; you can redistribute it and/or modify it under the
+# terms of the GNU General Public License as published by the Free Software
+# Foundation; either version 3, or (at your option) any later version.
+
+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+# details.
+
+# You should have received a copy of the GNU General Public License along
+# with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+LIB2ADD += $(srcdir)/config/arc64/lib2funcs.c
+
diff --git a/libgcc/config/arc64/t-softfp b/libgcc/config/arc64/t-softfp
new file mode 100644
index 00000000000..e15321acc40
--- /dev/null
+++ b/libgcc/config/arc64/t-softfp
@@ -0,0 +1,8 @@
+softfp_float_modes := sf df
+softfp_int_modes := si di ti
+softfp_extensions := sfdf
+softfp_truncations := dfsf
+softfp_exclude_libgcc2 := n
+#softfp_extras := fixhfti fixunshfti floattihf floatuntihf
+
+#TARGET_LIBGCC2_CFLAGS += -Wno-missing-prototypes
-- 
2.16.2

